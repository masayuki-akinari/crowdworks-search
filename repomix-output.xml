This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.eslintrc.js
.github/workflows/ci.yml
.gitignore
.prettierrc
app.ts
docker-compose.yml
Dockerfile
Dockerfile.lambda
docs/README.md
env.example
jest.config.js
package.json
readme.md
scripts/analyze-details.ts
scripts/analyze-lancers-jobs.ts
scripts/calculate-recommendation-score.ts
scripts/create-small-unified-report.ts
scripts/create-unified-report.ts
scripts/deploy-lambda.ts
scripts/extract-high-hourly-jobs.ts
scripts/filter-active-jobs.ts
scripts/full-pipeline.ts
scripts/integrated-job-search.ts
scripts/scrape-crowdworks-50jobs.ts
scripts/scrape-crowdworks.ts
scripts/scrape-lancers.ts
scripts/setup-github-oidc.sh
scripts/test-lancers-5jobs.ts
scripts/test-scraping-5jobs.ts
src/analysis/unified-analysis.ts
src/index.ts
src/infrastructure/crowdworks-searcher-stack.ts
src/lambda/handler.ts
src/services/AppliedJobsService.ts
src/services/index.ts
src/services/LancersService.ts
src/types/index.ts
src/utils/index.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="scripts/deploy-lambda.ts">
#!/usr/bin/env node

/**
 * AWS Lambda関数デプロイスクリプト
 * CrowdWorks & Lancers統合スクレイピングシステム
 */

import { LambdaClient, CreateFunctionCommand, UpdateFunctionCodeCommand, GetFunctionCommand } from '@aws-sdk/client-lambda';
import * as fs from 'fs';
import * as path from 'path';

// Lambda設定の読み込み
const configPath = path.join(__dirname, '../lambda-config.json');
const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));

// Lambda クライアントの初期化
const lambda = new LambdaClient({ region: 'ap-northeast-1' });

/**
 * Lambda関数の存在確認
 */
async function checkFunctionExists(functionName: string): Promise<boolean> {
  try {
    await lambda.send(new GetFunctionCommand({ FunctionName: functionName }));
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Lambda関数の作成
 */
async function createFunction(config: any, zipBuffer: Buffer): Promise<void> {
  const params = {
    ...config,
    Code: {
      ZipFile: zipBuffer
    }
  };

  try {
    const result = await lambda.send(new CreateFunctionCommand(params));
    console.log('✅ Lambda関数を作成しました:', result.FunctionArn);
  } catch (error) {
    console.error('❌ Lambda関数の作成に失敗しました:', error);
    throw error;
  }
}

/**
 * Lambda関数の更新
 */
async function updateFunction(functionName: string, zipBuffer: Buffer): Promise<void> {
  const params = {
    FunctionName: functionName,
    ZipFile: zipBuffer
  };

  try {
    const result = await lambda.send(new UpdateFunctionCodeCommand(params));
    console.log('✅ Lambda関数を更新しました:', result.FunctionArn);
  } catch (error) {
    console.error('❌ Lambda関数の更新に失敗しました:', error);
    throw error;
  }
}

/**
 * メイン実行関数
 */
async function main(): Promise<void> {
  try {
    console.log('🚀 Lambda デプロイプロセス開始');
    
    // ZIPファイルの読み込み
    const zipPath = path.join(__dirname, '../lambda-function.zip');
    
    if (!fs.existsSync(zipPath)) {
      console.error('❌ lambda-function.zip が見つかりません');
      console.log('💡 まず `npm run lambda:build` を実行してください');
      process.exit(1);
    }
    
    const zipBuffer = fs.readFileSync(zipPath);
    console.log(`📦 ZIPファイル読み込み完了: ${(zipBuffer.length / 1024 / 1024).toFixed(2)}MB`);
    
    // 関数の存在確認
    const functionExists = await checkFunctionExists(config.FunctionName);
    
    if (functionExists) {
      console.log('🔄 既存の関数を更新します...');
      await updateFunction(config.FunctionName, zipBuffer);
    } else {
      console.log('🆕 新しい関数を作成します...');
      await createFunction(config, zipBuffer);
    }
    
    console.log('🎉 デプロイが完了しました！');
    console.log('');
    console.log('📋 Lambda関数情報:');
    console.log(`   関数名: ${config.FunctionName}`);
    console.log(`   ハンドラー: ${config.Handler}`);
    console.log(`   ランタイム: ${config.Runtime}`);
    console.log(`   メモリ: ${config.MemorySize}MB`);
    console.log(`   タイムアウト: ${config.Timeout}秒`);
    console.log('');
    console.log('🔥 テスト実行コマンド:');
    console.log('   aws lambda invoke --function-name crowdworks-scraper --payload \'{"action":"full-pipeline","minHourlyRate":2000,"count":10}\' response.json');
    
  } catch (error) {
    console.error('❌ デプロイプロセスでエラーが発生しました:', error);
    process.exit(1);
  }
}

// CLI実行時の処理
if (require.main === module) {
  main().catch(error => {
    console.error('❌ デプロイエラー:', error);
    process.exit(1);
  });
}

export { main as deployLambda };
</file>

<file path=".prettierrc">
{
    "semi": true,
    "trailingComma": "es5",
    "singleQuote": true,
    "printWidth": 100,
    "tabWidth": 2,
    "useTabs": false,
    "bracketSpacing": true,
    "arrowParens": "avoid",
    "endOfLine": "lf",
    "quoteProps": "as-needed",
    "bracketSameLine": false,
    "embeddedLanguageFormatting": "auto"
}
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  # メイン開発環境
  crowdworks-search:
    build:
      context: .
      dockerfile: Dockerfile
      target: development  # 開発用ステージを使用
    container_name: crowdworks-search-dev
    volumes:
      # ソースコードのマウント（リアルタイム開発用）
      - .:/workspace
      - /workspace/node_modules  # node_modulesは除外
      - /workspace/dist          # distは除外
      # AWS認証情報のマウント（必要に応じて）
      - ~/.aws:/root/.aws:ro
    environment:
      # 開発環境用の環境変数
      - NODE_ENV=development
      - AWS_REGION=ap-northeast-1
      - LOG_LEVEL=debug
      # Playwright設定
      - PLAYWRIGHT_BROWSERS_PATH=/ms-playwright
    ports:
      - "3000:3000"  # 将来的なAPI Gateway Local用
      - "9229:9229"  # Node.js デバッグポート
    working_dir: /workspace
    # 開発用のコマンドオーバーライド
    command: tail -f /dev/null  # コンテナを起動状態で維持
    stdin_open: true
    tty: true

  # テスト実行専用コンテナ
  test:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: crowdworks-search-test
    volumes:
      - .:/workspace
      - /workspace/node_modules
      - /workspace/dist
    environment:
      - NODE_ENV=test
      - AWS_REGION=ap-northeast-1
    working_dir: /workspace
    command: npm run test:coverage
    profiles:
      - test  # docker-compose --profile test up で実行

  # AWS CDK専用コンテナ
  cdk:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: crowdworks-search-cdk
    volumes:
      - .:/workspace
      - /workspace/node_modules
      - /workspace/cdk.out
      - ~/.aws:/root/.aws:ro
    environment:
      - AWS_REGION=ap-northeast-1
      - CDK_DEFAULT_REGION=ap-northeast-1
    working_dir: /workspace
    command: tail -f /dev/null
    profiles:
      - cdk  # docker-compose --profile cdk up で実行

  # 本番環境テスト用（Lambda環境シミュレーション）
  lambda-test:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: crowdworks-search-lambda
    environment:
      - AWS_LAMBDA_RUNTIME_API=localhost:9000
      - _HANDLER=dist/lambda/handler.lambdaHandler
    ports:
      - "9000:8080"  # Lambda Runtime Interface Emulator
    profiles:
      - lambda  # docker-compose --profile lambda up で実行

networks:
  default:
    name: crowdworks-search-network
</file>

<file path="Dockerfile.lambda">
# ================================================
# Lambda Container用Dockerfile
# Playwright + Chromium環境の最適化版
# ================================================

# AWS Lambda Node.js基盤イメージ
FROM public.ecr.aws/lambda/nodejs:18

# ビルド引数
ARG STAGE=development
ARG NODE_ENV=production

# 環境変数設定
ENV NODE_ENV=${NODE_ENV}
ENV STAGE=${STAGE}
ENV PLAYWRIGHT_BROWSERS_PATH=/usr/bin
ENV PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1

# 作業ディレクトリ設定
WORKDIR ${LAMBDA_TASK_ROOT}

# システム依存関係のインストール（Chromium + 関連ライブラリ）
RUN dnf update -y && \
    dnf install -y \
    chromium \
    nss \
    atk \
    at-spi2-atk \
    gtk3 \
    cups-libs \
    drm \
    libXt \
    libXext \
    libXdamage \
    libXrandr \
    libXcomposite \
    libXcursor \
    libXss \
    libXi \
    GConf2 \
    alsa-lib \
    && dnf clean all \
    && rm -rf /var/cache/dnf

# Chromiumの動作確認とバイナリパス設定
RUN ln -sf /usr/bin/chromium-browser /usr/bin/chromium \
    && chromium --version \
    && echo "Chromium installed successfully"

# Node.js依存関係のコピーとインストール
COPY package*.json ./
RUN npm ci --omit=dev --ignore-scripts && \
    npm cache clean --force

# アプリケーションコードのコピー
COPY dist/ ./dist/
COPY src/types/ ./src/types/

# パーミッション設定
RUN chmod +x dist/lambda/handler.js

# Playwright設定確認
RUN node -e "console.log('Node.js version:', process.version)" && \
    node -e "const { chromium } = require('playwright'); console.log('Playwright loaded successfully')"

# ヘルスチェック（ビルド時確認）
RUN node -e "console.log('Lambda Container build completed successfully')"

# Lambda関数エントリポイント
CMD ["dist/lambda/handler.lambdaHandler"]
</file>

<file path="docs/README.md">
# 設計書インデックス

クラウドワークス案件自動検索・評価システムの設計書です。

## 📚 設計書一覧

### 1. [要件定義書](./01_requirements.md)
プロジェクトの目的、機能要件、非機能要件を定義

### 2. [システム設計書](./02_system_design.md)  
システム全体のアーキテクチャとコンポーネント設計

### 3. [データ設計書](./03_data_design.md)
データベース設計とデータ型定義

### 4. [API設計書](./04_api_design.md)
内部API・外部API連携の仕様定義

### 5. [実装計画書](./05_implementation_plan.md)
開発フェーズとタスク分解、スケジュール

## 🔄 設計書作成の進め方

1. **要件定義書** から開始
2. **システム設計書** で全体像を整理
3. **データ設計書** でデータ構造を決定
4. **API設計書** でインターフェースを定義
5. **実装計画書** で開発を計画

## 📝 更新履歴

| 日付 | 更新者 | 更新内容 |
|------|--------|----------|
|      |        |          |
</file>

<file path="scripts/analyze-lancers-jobs.ts">
import { readFileSync, writeFileSync } from 'fs';
import OpenAI from 'openai';

require('dotenv').config();

const openai = new OpenAI({
    apiKey: process.env['OPENAI_API_KEY'],
});

/**
 * ランサーズ案件からCrowdWorks互換のAI分析データを生成
 */
interface LancersJob {
    id: string;
    title: string;
    description: string;
    url: string;
    budget: {
        type: 'fixed' | 'hourly' | 'unknown';
        amount: number;
        currency: string;
    };
    category: string;
    tags: string[];
    client: {
        name: string;
        rating: number;
        reviewCount: number;
    };
    postedAt: string;
    deadline?: string;
    applicants: number;
    scrapedAt: string;
}

interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    難易度: string;
    gpt_summary: string;
    category?: string;
}

/**
 * ランサーズ案件をAI分析する関数
 */
async function analyzeLancersJob(job: LancersJob): Promise<AnalysisResult | null> {
    const prompt = `以下のランサーズ案件を分析して、下記の項目を出力してください。

【案件情報】
タイトル: ${job.title}
詳細説明: ${job.description}
予算: ${job.budget.amount}円 (${job.budget.type === 'fixed' ? '固定' : job.budget.type === 'hourly' ? '時給' : '不明'})
カテゴリ: ${job.category}
タグ: ${job.tags.join(', ')}
応募者数: ${job.applicants}人

【出力項目】
1. 工数見積もり（例：10時間、30時間、100時間など）
2. 想定時給（例：3000円、4500円など - 予算と工数から逆算）
3. 難易度（初級、中級、上級、エキスパート）
4. 案件概要（50文字程度の簡潔な要約）

【評価の観点】
- 技術的な複雑さ
- 作業規模
- 求められるスキルレベル
- 納期の余裕度

【出力フォーマット】
工数見積もり: <時間数>
想定時給: <金額>
難易度: <レベル>
概要: <50文字程度の要約>`;

    try {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたはフリーランス案件の分析専門家です。技術案件の工数見積もりと難易度評価に長けています。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 500,
            temperature: 0.3,
        });

        const text = res.choices[0]?.message?.content || '';

        // 結果をパース
        const workloadMatch = text.match(/工数見積もり[:：]\s*([^\n]+)/);
        const hourlyRateMatch = text.match(/想定時給[:：]\s*([^\n]+)/);
        const difficultyMatch = text.match(/難易度[:：]\s*([^\n]+)/);
        const summaryMatch = text.match(/概要[:：]\s*([^\n]+)/);

        const workload = workloadMatch?.[1]?.trim() || '不明';
        const hourlyRate = hourlyRateMatch?.[1]?.trim() || '不明';
        const difficulty = difficultyMatch?.[1]?.trim() || '不明';
        const summary = summaryMatch?.[1]?.trim() || '';

        return {
            jobId: job.id,
            title: job.title,
            工数_見積もり: workload,
            想定時給: hourlyRate,
            難易度: difficulty,
            gpt_summary: summary,
            category: job.category
        };

    } catch (error) {
        console.error(`❌ 案件分析エラー (${job.id}):`, error);
        return null;
    }
}

/**
 * メイン処理
 */
async function main(): Promise<void> {
    console.log('🚀 ランサーズ案件のAI分析を開始します...');

    // ランサーズ案件データを読み込み
    let lancersJobs: LancersJob[] = [];
    try {
        const lancersData = JSON.parse(readFileSync('output/lancers-all-jobs.json', 'utf8'));
        lancersJobs = lancersData.jobs || [];
        console.log(`📂 ランサーズ案件データ読み込み: ${lancersJobs.length}件`);
    } catch (error) {
        console.error('❌ ランサーズ案件データの読み込みに失敗:', error);
        return;
    }

    if (lancersJobs.length === 0) {
        console.log('⚠️ 分析対象の案件がありません');
        return;
    }

    // システム開発関連の案件のみをフィルタリング
    const targetJobs = lancersJobs.filter(job => {
        const title = job.title.toLowerCase();
        const description = job.description.toLowerCase();
        const category = job.category.toLowerCase();

        // システム開発・Web関連のキーワード
        const keywords = [
            'システム', 'web', 'api', 'データベース', 'javascript', 'typescript', 'react', 'node',
            'php', 'python', 'java', 'sql', 'database', 'サイト', 'アプリ', 'cms', 'wordpress',
            'ec', 'ecommerce', 'ショッピング', 'プログラミング', '開発', 'フロントエンド', 'バックエンド'
        ];

        return keywords.some(keyword =>
            title.includes(keyword) ||
            description.includes(keyword) ||
            category.includes(keyword)
        );
    });

    console.log(`🎯 技術案件をフィルタリング: ${targetJobs.length}件 (全${lancersJobs.length}件中)`);

    if (targetJobs.length === 0) {
        console.log('⚠️ 技術関連の案件が見つかりませんでした');
        return;
    }

    // 案件を順次分析
    const analyzedJobs: AnalysisResult[] = [];
    const batchSize = 5; // 5件ずつ処理

    for (let i = 0; i < targetJobs.length; i += batchSize) {
        const batch = targetJobs.slice(i, i + batchSize);
        console.log(`\n📋 バッチ ${Math.floor(i / batchSize) + 1}: ${i + 1}~${Math.min(i + batchSize, targetJobs.length)}件目を分析中...`);

        // バッチ内の案件を並列で分析
        const batchPromises = batch.map(async (job, index) => {
            const globalIndex = i + index + 1;
            try {
                console.log(`🔍 [${globalIndex}/${targetJobs.length}] 分析中: ${job.title.substring(0, 40)}...`);
                const result = await analyzeLancersJob(job);

                if (result) {
                    console.log(`✅ [${globalIndex}/${targetJobs.length}] 分析完了: ${result.想定時給}, ${result.難易度}`);
                    return result;
                } else {
                    console.log(`❌ [${globalIndex}/${targetJobs.length}] 分析失敗`);
                    return null;
                }
            } catch (error) {
                console.error(`❌ [${globalIndex}/${targetJobs.length}] エラー:`, error);
                return null;
            }
        });

        const batchResults = await Promise.allSettled(batchPromises);

        // 成功した結果のみを追加
        batchResults.forEach((result) => {
            if (result.status === 'fulfilled' && result.value) {
                analyzedJobs.push(result.value);
            }
        });

        // バッチ間の待機時間（API制限対策）
        if (i + batchSize < targetJobs.length) {
            console.log('⏱️ 次のバッチまで3秒待機...');
            await new Promise(resolve => setTimeout(resolve, 3000));
        }
    }

    console.log(`\n🎉 ランサーズ案件AI分析完了!`);
    console.log(`📊 結果: ${analyzedJobs.length}件成功 / ${targetJobs.length}件処理`);

    // 結果をファイルに保存
    if (analyzedJobs.length > 0) {
        const outputFile = 'output/analyzed-lancers.json';
        writeFileSync(outputFile, JSON.stringify(analyzedJobs, null, 2), 'utf8');
        console.log(`💾 分析結果を保存: ${outputFile}`);

        // 統計情報を表示
        console.log(`\n📈 分析結果統計:`);

        // 難易度分布
        const difficultyDist = analyzedJobs.reduce((acc, job) => {
            acc[job.難易度] = (acc[job.難易度] || 0) + 1;
            return acc;
        }, {} as Record<string, number>);

        console.log(`難易度分布:`);
        Object.entries(difficultyDist).forEach(([level, count]) => {
            console.log(`  ${level}: ${count}件`);
        });

        // 想定時給分布
        const hourlyRates = analyzedJobs
            .map(job => {
                const match = job.想定時給.match(/(\d+)/);
                return match && match[1] ? parseInt(match[1]) : 0;
            })
            .filter(rate => rate > 0);

        if (hourlyRates.length > 0) {
            const avgRate = Math.round(hourlyRates.reduce((sum, rate) => sum + rate, 0) / hourlyRates.length);
            const maxRate = Math.max(...hourlyRates);
            const minRate = Math.min(...hourlyRates);

            console.log(`想定時給統計:`);
            console.log(`  平均: ${avgRate}円`);
            console.log(`  最高: ${maxRate}円`);
            console.log(`  最低: ${minRate}円`);
        }
    }
}

// スクリプト実行
if (require.main === module) {
    main().catch(error => {
        console.error('💥 スクリプト実行エラー:', error);
        process.exit(1);
    });
}

export default main;
</file>

<file path="scripts/create-small-unified-report.ts">
import fs from 'fs';

interface Job {
    title: string;
    budget: string;
    url: string;
    description: string;
    hourlyRate: number;
    platform: string;
}

interface LancersJob {
    jobId: string;
    title: string;
    budget: string;
    url: string;
    detailedDescription: string;
}

interface CrowdWorksJob {
    jobId: string;
    title: string;
    budget: string;
    url: string;
    description: string;
}

class SmallUnifiedReportGenerator {

    constructor() { }

    /**
     * 新しいデータから統合レポートを生成
     */
    async generateReport(): Promise<void> {
        console.log('🚀 小規模統合レポート生成開始...');

        // データ読み込み
        const data = this.loadJobData();

        console.log(`📊 読み込み結果:`);
        console.log(`   ランサーズ: ${data.lancers.length}件`);
        console.log(`   CrowdWorks: ${data.crowdworks.length}件`);

        // 高時給案件抽出（1000円以上）
        const minHourlyRate = 1000;
        const highPayingJobs = this.filterHighPayingJobs(data.lancers, data.crowdworks, minHourlyRate);

        console.log(`\n🔥 高時給案件 (${minHourlyRate}円以上):`);
        console.log(`   ランサーズ: ${highPayingJobs.lancers.length}件`);
        console.log(`   CrowdWorks: ${highPayingJobs.crowdworks.length}件`);

        if (highPayingJobs.lancers.length === 0 && highPayingJobs.crowdworks.length === 0) {
            console.log(`⚠️ 時給${minHourlyRate}円以上の案件が見つかりませんでした。`);
            return;
        }

        // レポート生成
        const report = this.createMarkdownReport(highPayingJobs.lancers, highPayingJobs.crowdworks, minHourlyRate);

        // ファイル保存
        const timestamp = new Date().toISOString().split('T')[0];
        const filename = `output/unified-small-report-${timestamp}.md`;
        fs.writeFileSync(filename, report, 'utf8');

        console.log(`\n📄 レポート生成完了！`);
        console.log(`💾 保存先: ${filename}`);
    }

    /**
     * データ読み込み
     */
    private loadJobData(): { lancers: LancersJob[], crowdworks: CrowdWorksJob[] } {
        console.log('📚 データ読み込み中...');

        // ランサーズデータ読み込み
        const lancersData: LancersJob[] = [];
        const lancersFile = 'output/lancers-details-2025-06-09T17-38-02-401Z.json';
        if (fs.existsSync(lancersFile)) {
            const data = JSON.parse(fs.readFileSync(lancersFile, 'utf8'));
            lancersData.push(...data);
            console.log(`📁 ランサーズデータ読み込み: ${data.length}件`);
        }

        // CrowdWorksデータ読み込み（新しい50件データを優先使用）
        const crowdworksData: CrowdWorksJob[] = [];

        // 新しい50件データファイル
        const newCrowdWorksFile = 'output/crowdworks-web-jobs-2025-06-09T18-47-49-913Z.json';
        if (fs.existsSync(newCrowdWorksFile)) {
            const data = JSON.parse(fs.readFileSync(newCrowdWorksFile, 'utf8'));
            crowdworksData.push(...data);
            console.log(`📁 CrowdWorks修正データ読み込み: ${data.length}件`);
        } else {
            // フォールバック：前のデータ
            const oldCrowdWorksFile = 'output/crowdworks-web-jobs-2025-06-09T18-39-50-670Z.json';
            if (fs.existsSync(oldCrowdWorksFile)) {
                const data = JSON.parse(fs.readFileSync(oldCrowdWorksFile, 'utf8'));
                crowdworksData.push(...data);
                console.log(`📁 CrowdWorks旧データ読み込み: ${data.length}件`);
            }
        }

        return { lancers: lancersData, crowdworks: crowdworksData };
    }

    /**
     * 予算文字列から時給を推定
     */
    private estimateHourlyRate(budgetText: string): number {
        if (!budgetText || budgetText === '未取得' || budgetText === 'エラー') return 0;

        // タイトルが混入している場合は除外
        if (budgetText.length > 100 || budgetText.includes('募集') || budgetText.includes('開発')) {
            return 0;
        }

        // 金額を抽出
        const amounts = budgetText.match(/(\d{1,3}(?:,\d{3})*)/g);
        if (!amounts || amounts.length === 0) return 0;

        let amount = parseInt(amounts[0].replace(/,/g, ''));

        // 時給表記の場合
        if (budgetText.includes('時間') || budgetText.includes('/時') || budgetText.includes('時給')) {
            return amount;
        }

        // 範囲がある場合は最大値を使用
        if (amounts.length > 1) {
            const lastAmount = amounts[amounts.length - 1];
            if (lastAmount) {
                amount = parseInt(lastAmount.replace(/,/g, ''));
            }
        }

        // 固定報酬の場合
        // 異常に高い金額（月100万円以上）の場合は年額と仮定して月額に変換
        if (amount > 1000000) {
            // 年額の場合は12で割って月額に変換
            const monthlyAmount = amount / 12;
            // 月額を160時間（月20日×8時間）で割って時給を推定
            return Math.round(monthlyAmount / 160);
        }

        // 通常の月額報酬の場合は160時間で割る
        if (amount > 50000) {
            return Math.round(amount / 160);
        }

        // 小額の場合は時給として扱う
        return amount;
    }

    /**
     * 高時給案件フィルタリング
     */
    private filterHighPayingJobs(
        lancersJobs: LancersJob[],
        crowdworksJobs: CrowdWorksJob[],
        minHourlyRate: number
    ): { lancers: Job[], crowdworks: Job[] } {

        // ランサーズ案件処理
        const processedLancers: Job[] = lancersJobs
            .filter(job => job.budget && job.budget.trim() !== '')
            .map(job => ({
                title: job.title || 'タイトル不明',
                budget: job.budget,
                url: job.url,
                description: job.detailedDescription || '',
                hourlyRate: this.estimateHourlyRate(job.budget),
                platform: 'ランサーズ'
            }))
            .filter(job => job.hourlyRate >= minHourlyRate);

        // CrowdWorks案件処理
        const processedCrowdworks: Job[] = crowdworksJobs
            .filter(job => job.budget && job.budget.trim() !== '')
            .map(job => ({
                title: job.title || 'タイトル不明',
                budget: job.budget,
                url: job.url,
                description: job.description || '',
                hourlyRate: this.estimateHourlyRate(job.budget),
                platform: 'CrowdWorks'
            }))
            .filter(job => job.hourlyRate >= minHourlyRate);

        return { lancers: processedLancers, crowdworks: processedCrowdworks };
    }

    /**
     * Markdownレポート作成
     */
    private createMarkdownReport(lancersJobs: Job[], crowdworksJobs: Job[], minHourlyRate: number): string {
        const allJobs = [...lancersJobs, ...crowdworksJobs]
            .sort((a, b) => b.hourlyRate - a.hourlyRate);

        const timestamp = new Date().toLocaleString('ja-JP');

        let report = `# 統合高時給案件レポート（時給${minHourlyRate}円以上）\n\n`;
        report += `> **生成日時**: ${timestamp}\n`;
        report += `> **データ**: ランサーズ${lancersJobs.length}件 + CrowdWorks${crowdworksJobs.length}件 = 合計${allJobs.length}件\n\n`;

        // 統計情報
        if (allJobs.length > 0) {
            const maxRate = Math.max(...allJobs.map(job => job.hourlyRate));
            const avgRate = Math.round(allJobs.reduce((sum, job) => sum + job.hourlyRate, 0) / allJobs.length);

            report += `## 📊 統計情報\n\n`;
            report += `| 項目 | ランサーズ | CrowdWorks | 合計 |\n`;
            report += `|------|------------|------------|------|\n`;
            report += `| 案件数 | ${lancersJobs.length}件 | ${crowdworksJobs.length}件 | ${allJobs.length}件 |\n`;
            report += `| 最高時給 | ${lancersJobs.length > 0 ? Math.max(...lancersJobs.map(j => j.hourlyRate)).toLocaleString() : '0'}円 | ${crowdworksJobs.length > 0 ? Math.max(...crowdworksJobs.map(j => j.hourlyRate)).toLocaleString() : '0'}円 | ${maxRate.toLocaleString()}円 |\n`;
            report += `| 平均時給 | ${lancersJobs.length > 0 ? Math.round(lancersJobs.reduce((sum, j) => sum + j.hourlyRate, 0) / lancersJobs.length).toLocaleString() : '0'}円 | ${crowdworksJobs.length > 0 ? Math.round(crowdworksJobs.reduce((sum, j) => sum + j.hourlyRate, 0) / crowdworksJobs.length).toLocaleString() : '0'}円 | ${avgRate.toLocaleString()}円 |\n\n`;
        }

        // 案件一覧
        report += `## 🏆 高時給案件ランキング\n\n`;

        allJobs.forEach((job, index) => {
            report += `### ${index + 1}位: ${job.platform} - ${job.title}\n\n`;
            report += `**💰 推定時給:** ${job.hourlyRate.toLocaleString()}円\n`;
            report += `**💵 予算:** ${job.budget}\n`;
            report += `**🔗 URL:** ${job.url}\n\n`;
            report += `**📝 概要:**\n`;
            report += `${job.description.substring(0, 300)}...\n\n`;
            report += `---\n\n`;
        });

        return report;
    }
}

// メイン実行
async function main() {
    const generator = new SmallUnifiedReportGenerator();
    await generator.generateReport();
}

if (require.main === module) {
    main().catch(error => {
        console.error('💥 エラー:', error);
        process.exit(1);
    });
}
</file>

<file path="scripts/filter-active-jobs.ts">
import * as fs from 'fs';
import * as path from 'path';

// Job型定義
interface Job {
    id: string;
    title: string;
    platform: 'ランサーズ' | 'クラウドワークス';
    url: string;
    budget: string;
    hourlyRate: number;
    category: string;
    subcategory: string;
    description: string;
    client: string;
    clientRating: number;
    clientOrderCount: number;
    postedAt: Date | string;
    deadline: string;
    tags: string[];
    workType: string;
    isUrgent: boolean;
    isPremium: boolean;
    industry: string;
    workRank: string;
    appliedCount: number;
    recruitCount: number;
}

class JobFilter {
    private outputDir: string;

    constructor() {
        this.outputDir = path.join(process.cwd(), 'output');
    }

    // 終了済み案件を判定
    private isJobClosed(job: Job): boolean {
        const closedKeywords = [
            '募集終了',
            '締切済み',
            '終了済み',
            '募集停止',
            '募集中止',
            '受付終了'
        ];

        const textToCheck = [
            job.title,
            job.description,
            job.budget
        ].join(' ');

        return closedKeywords.some(keyword => textToCheck.includes(keyword));
    }

    // ランサーズファイルをフィルタリング
    async filterLancersJobs(): Promise<void> {
        console.log('🔍 ランサーズファイルを検索中...');

        const files = fs.readdirSync(this.outputDir)
            .filter(file => file.includes('lancers-jobs') && file.endsWith('.json'))
            .sort();

        for (const filename of files) {
            const filePath = path.join(this.outputDir, filename);

            try {
                console.log(`📄 処理中: ${filename}`);

                const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));

                if (!Array.isArray(data)) {
                    console.log(`⚠️ スキップ: ${filename} (配列形式ではありません)`);
                    continue;
                }

                const originalCount = data.length;
                const activeJobs = data.filter((job: Job) => !this.isJobClosed(job));
                const removedCount = originalCount - activeJobs.length;

                if (removedCount > 0) {
                    // フィルタリング後のファイルを保存
                    const newFilename = filename.replace('.json', '-active.json');
                    const newFilePath = path.join(this.outputDir, newFilename);

                    fs.writeFileSync(newFilePath, JSON.stringify(activeJobs, null, 2));

                    console.log(`✅ ${filename}:`);
                    console.log(`   元の案件数: ${originalCount}`);
                    console.log(`   有効案件数: ${activeJobs.length}`);
                    console.log(`   除外案件数: ${removedCount}`);
                    console.log(`   保存先: ${newFilename}`);
                } else {
                    console.log(`✨ ${filename}: 終了済み案件なし (${originalCount}件すべて有効)`);
                }

            } catch (error) {
                console.error(`❌ エラー処理 ${filename}:`, error);
            }
        }
    }

    // 統計情報を表示
    async showFilterStatistics(): Promise<void> {
        console.log('\n📊 フィルタリング統計:');

        const files = fs.readdirSync(this.outputDir)
            .filter(file => file.includes('lancers-jobs') && file.endsWith('.json'));

        const originalFiles = files.filter(f => !f.includes('-active'));
        const activeFiles = files.filter(f => f.includes('-active'));

        let totalOriginal = 0;
        let totalActive = 0;

        for (const filename of originalFiles) {
            try {
                const data = JSON.parse(fs.readFileSync(path.join(this.outputDir, filename), 'utf8'));
                if (Array.isArray(data)) totalOriginal += data.length;
            } catch (error) {
                // エラーは無視
            }
        }

        for (const filename of activeFiles) {
            try {
                const data = JSON.parse(fs.readFileSync(path.join(this.outputDir, filename), 'utf8'));
                if (Array.isArray(data)) totalActive += data.length;
            } catch (error) {
                // エラーは無視
            }
        }

        console.log(`🔢 元の総案件数: ${totalOriginal}`);
        console.log(`✅ 有効案件数: ${totalActive}`);
        console.log(`⏹️ 除外案件数: ${totalOriginal - totalActive}`);
        console.log(`📈 有効案件率: ${totalOriginal > 0 ? ((totalActive / totalOriginal) * 100).toFixed(1) : 0}%`);
    }

    async run(): Promise<void> {
        console.log('🚀 ランサーズ案件フィルタリングを開始します...');

        await this.filterLancersJobs();
        await this.showFilterStatistics();

        console.log('🎉 フィルタリング完了！');
    }
}

// メイン実行部分
async function main(): Promise<void> {
    const filter = new JobFilter();
    await filter.run();
}

if (require.main === module) {
    main().catch(console.error);
}

export { JobFilter };
</file>

<file path="scripts/full-pipeline.ts">
#!/usr/bin/env npx ts-node

import { spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

interface PipelineConfig {
  minHourlyRate: number;
  crowdWorksCategories: string[];
  lancersCategories: string[];
  scrapeCount: number;
}

class FullPipeline {
  private config: PipelineConfig;
  private outputDir: string;

  constructor(config: PipelineConfig) {
    this.config = config;
    this.outputDir = 'output';
  }

  /**
   * コマンドを実行してPromiseで結果を返す
   */
  private executeCommand(command: string, args: string[] = []): Promise<number> {
    return new Promise((resolve, reject) => {
      console.log(`🚀 実行中: ${command} ${args.join(' ')}`);
      
      const childProcess = spawn(command, args, {
        stdio: 'inherit',
        shell: true,
        cwd: process.cwd()
      });

      childProcess.on('close', (code) => {
        if (code === 0) {
          console.log(`✅ 完了: ${command}`);
          resolve(code);
        } else {
          console.error(`❌ エラー: ${command} (exit code: ${code})`);
          reject(new Error(`Command failed: ${command}`));
        }
      });

      childProcess.on('error', (error) => {
        console.error(`❌ プロセスエラー: ${error.message}`);
        reject(error);
      });
    });
  }

  /**
   * 1. CrowdWorksスクレイピング実行
   */
  private async scrapeCrowdWorks(): Promise<void> {
    console.log('\n📊 === STEP 1: CrowdWorksスクレイピング ===');
    
    for (const category of this.config.crowdWorksCategories) {
      try {
        await this.executeCommand('npm', ['run', 'handler', `scrape-${category}`, this.config.scrapeCount.toString()]);
        console.log(`✅ CrowdWorks ${category}カテゴリ完了`);
      } catch (error) {
        console.warn(`⚠️ CrowdWorks ${category}スキップ: ${error}`);
      }
    }
  }

  /**
   * 2. Lancersスクレイピング実行
   */
  private async scrapeLancers(): Promise<void> {
    console.log('\n🎯 === STEP 2: Lancersスクレイピング ===');
    
    for (const category of this.config.lancersCategories) {
      try {
        await this.executeCommand('npm', ['run', 'handler', `lancers-${category}`, this.config.scrapeCount.toString()]);
        console.log(`✅ Lancers ${category}カテゴリ完了`);
      } catch (error) {
        console.warn(`⚠️ Lancers ${category}スキップ: ${error}`);
      }
    }
  }

  /**
   * 3. 統合分析レポート生成
   */
  private async generateAnalysisReport(): Promise<void> {
    console.log('\n📈 === STEP 3: 統合分析レポート生成 ===');
    
    try {
      await this.executeCommand('npx', ['ts-node', 'scripts/create-unified-report.ts', this.config.minHourlyRate.toString()]);
      console.log('✅ 統合分析レポート生成完了');
    } catch (error) {
      console.error('❌ 分析レポート生成失敗:', error);
      throw error;
    }
  }

  /**
   * 4. 結果サマリー表示
   */
  private displaySummary(): void {
    console.log('\n🎉 === パイプライン実行完了！ ===');
    
    // outputディレクトリの最新ファイルを確認
    if (fs.existsSync(this.outputDir)) {
      const files = fs.readdirSync(this.outputDir)
        .filter(file => file.endsWith('.json') || file.endsWith('.md'))
        .map(file => ({
          name: file,
          path: path.join(this.outputDir, file),
          stats: fs.statSync(path.join(this.outputDir, file))
        }))
        .sort((a, b) => b.stats.mtime.getTime() - a.stats.mtime.getTime())
        .slice(0, 5);

      console.log('\n📁 生成されたファイル（最新5件）:');
      files.forEach((file, index) => {
        const sizeKB = Math.round(file.stats.size / 1024);
        const timestamp = file.stats.mtime.toLocaleString('ja-JP');
        console.log(`  ${index + 1}. ${file.name} (${sizeKB}KB) - ${timestamp}`);
      });

      // 最新のレポートファイルを特定
      const latestReport = files.find(f => f.name.includes('unified-high-paying-jobs') && f.name.endsWith('.md'));
      if (latestReport) {
        console.log(`\n🎯 最新分析レポート: ${latestReport.name}`);
        console.log(`   パス: ${latestReport.path}`);
      }
    }

    console.log(`\n💰 設定情報:`);
    console.log(`   最低時給: ${this.config.minHourlyRate.toLocaleString()}円`);
    console.log(`   CrowdWorksカテゴリ: ${this.config.crowdWorksCategories.join(', ')}`);
    console.log(`   Lancersカテゴリ: ${this.config.lancersCategories.join(', ')}`);
    console.log(`   スクレイピング件数: ${this.config.scrapeCount}件/カテゴリ`);
  }

  /**
   * フルパイプライン実行
   */
  async execute(): Promise<void> {
    const startTime = Date.now();
    
    console.log('🚀 === フル自動化パイプライン開始 ===');
    console.log(`開始時刻: ${new Date().toLocaleString('ja-JP')}`);
    
    try {
      // STEP 1: CrowdWorksスクレイピング
      await this.scrapeCrowdWorks();
      
      // STEP 2: Lancersスクレイピング  
      await this.scrapeLancers();
      
      // STEP 3: 統合分析
      await this.generateAnalysisReport();
      
      // STEP 4: 結果表示
      this.displaySummary();
      
      const executionTime = Math.round((Date.now() - startTime) / 1000);
      console.log(`\n🎉 パイプライン実行完了！ (実行時間: ${executionTime}秒)`);
      
    } catch (error) {
      console.error('\n❌ パイプライン実行中にエラーが発生しました:', error);
      process.exit(1);
    }
  }
}

// メイン実行
async function main() {
  // コマンドライン引数の解析
  const args = process.argv.slice(2);
  const minHourlyRate = args[0] ? parseInt(args[0]) : 3000;
  const scrapeCount = args[1] ? parseInt(args[1]) : 10;

  const config: PipelineConfig = {
    minHourlyRate,
    scrapeCount,
    crowdWorksCategories: ['ec', 'web', 'app', 'dev'], // CrowdWorksカテゴリ
    lancersCategories: ['system', 'web', 'app', 'design'] // Lancersカテゴリ
  };

  console.log('⚙️ パイプライン設定:');
  console.log(`   最低時給: ${config.minHourlyRate.toLocaleString()}円`);
  console.log(`   スクレイピング件数: ${config.scrapeCount}件/カテゴリ`);
  console.log(`   CrowdWorksカテゴリ: ${config.crowdWorksCategories.join(', ')}`);
  console.log(`   Lancersカテゴリ: ${config.lancersCategories.join(', ')}`);

  const pipeline = new FullPipeline(config);
  await pipeline.execute();
}

if (require.main === module) {
  main().catch(console.error);
}

export { FullPipeline };
</file>

<file path="scripts/integrated-job-search.ts">
require('dotenv').config();

import {
    IntegratedJobSearchService,
    CurrencyService
} from '../src/services/index';
import {
    UpworkCredentials,
    IntegratedSearchConfig,
    IntegratedJobReport
} from '../src/types/index';
import { writeFileSync, existsSync, mkdirSync } from 'fs';
import * as path from 'path';

/**
 * 統合ジョブサーチスクリプト
 * CrowdWorksとUpworkから高時給案件を検索してレポート生成
 */

// 出力ディレクトリの確保
const outputDir = 'output';
if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
}

// 環境変数から設定を取得
function getUpworkCredentials(): UpworkCredentials {
    const consumerKey = process.env['UPWORK_CONSUMER_KEY'];
    const consumerSecret = process.env['UPWORK_CONSUMER_SECRET'];
    const accessToken = process.env['UPWORK_ACCESS_TOKEN'];
    const accessTokenSecret = process.env['UPWORK_ACCESS_TOKEN_SECRET'];

    if (!consumerKey || !consumerSecret) {
        throw new Error('Upwork認証情報が不足しています。UPWORK_CONSUMER_KEY, UPWORK_CONSUMER_SECRETを設定してください。');
    }

    const credentials: UpworkCredentials = {
        consumerKey,
        consumerSecret
    };

    if (accessToken) {
        credentials.accessToken = accessToken;
    }

    if (accessTokenSecret) {
        credentials.accessTokenSecret = accessTokenSecret;
    }

    return credentials;
}

// デフォルト統合検索設定
function createDefaultSearchConfig(): IntegratedSearchConfig {
    return {
        enabled: {
            crowdworks: true,
            upwork: true
        },
        limits: {
            maxJobsPerSource: 50,
            maxExecutionTime: 300 // 5分
        },
        filtering: {
            minHourlyRateJPY: 3000, // 最低時給3000円
            minBudgetJPY: 50000, // 最低予算5万円
            excludeKeywords: ['テスト', 'アンケート', '単純作業'],
            requiredSkills: []
        },
        currency: {
            exchangeRateUSDToJPY: 150, // USD→JPY換算レート
            lastUpdated: new Date()
        }
    };
}

/**
 * メイン実行関数
 */
async function executeIntegratedJobSearch(options: {
    minHourlyRate?: number;
    maxJobsPerSource?: number;
    categories?: string[];
    keywords?: string[];
    outputFormat?: 'json' | 'markdown' | 'both';
}): Promise<void> {
    console.log('🚀 統合ジョブサーチを開始します...');
    console.log(`📊 設定: 最低時給${options.minHourlyRate || 3000}円, 最大取得件数${options.maxJobsPerSource || 50}件/サイト`);

    const startTime = Date.now();

    try {
        // 認証情報とサービス初期化
        console.log('🔐 Upwork認証情報を取得中...');
        const upworkCredentials = getUpworkCredentials();

        console.log('⚙️ 検索設定を初期化中...');
        const searchConfig = createDefaultSearchConfig();

        // カスタム設定の適用
        if (options.minHourlyRate) {
            searchConfig.filtering.minHourlyRateJPY = options.minHourlyRate;
        }
        if (options.maxJobsPerSource) {
            searchConfig.limits.maxJobsPerSource = options.maxJobsPerSource;
        }

        // 統合サービスの初期化
        const integratedService = new IntegratedJobSearchService(
            upworkCredentials,
            searchConfig
        );

        console.log('🔍 統合案件検索を実行中...');

        console.log('📝 検索結果レポートを生成中...');

        // レポート生成
        const reportParams = {
            minHourlyRate: options.minHourlyRate || 3000,
            categories: options.categories || [],
            maxJobsPerSource: options.maxJobsPerSource || 50
        };

        const report = await integratedService.generateReport(reportParams);

        // 結果の出力
        await saveResults(report, options.outputFormat || 'both');

        // 実行サマリーの表示
        displaySummary(report, Date.now() - startTime);

    } catch (error) {
        console.error('❌ 統合ジョブサーチでエラーが発生しました:', error instanceof Error ? error.message : String(error));
        process.exit(1);
    }
}

/**
 * 結果の保存
 */
async function saveResults(
    report: IntegratedJobReport,
    format: 'json' | 'markdown' | 'both'
): Promise<void> {
    const timestamp = new Date().toISOString().split('T')[0];
    const baseFilename = `integrated-job-report-${timestamp}`;

    if (format === 'json' || format === 'both') {
        const jsonPath = path.join(outputDir, `${baseFilename}.json`);
        writeFileSync(jsonPath, JSON.stringify(report, null, 2), 'utf8');
        console.log(`💾 JSON レポートを保存: ${jsonPath}`);
    }

    if (format === 'markdown' || format === 'both') {
        const markdownPath = path.join(outputDir, `${baseFilename}.md`);
        const markdownContent = generateMarkdownReport(report);
        writeFileSync(markdownPath, markdownContent, 'utf8');
        console.log(`📄 Markdown レポートを保存: ${markdownPath}`);
    }

    // 高時給案件の詳細レポート
    if (report.highValueJobs.upwork.length > 0 || report.highValueJobs.crowdworks.length > 0) {
        const highValuePath = path.join(outputDir, `high-value-jobs-${timestamp}.md`);
        const highValueContent = generateHighValueJobsReport(report);
        writeFileSync(highValuePath, highValueContent, 'utf8');
        console.log(`💰 高時給案件詳細レポートを保存: ${highValuePath}`);
    }
}

/**
 * Markdownレポート生成
 */
function generateMarkdownReport(report: IntegratedJobReport): string {
    const date = report.generatedAt.toLocaleDateString('ja-JP');
    const time = report.generatedAt.toLocaleTimeString('ja-JP');

    return `# 統合ジョブサーチレポート

> **生成日時**: ${date} ${time}  
> **レポートID**: ${report.id}  

## 📊 検索サマリー

| 項目 | CrowdWorks | Upwork | 合計 |
|------|------------|--------|------|
| 取得案件数 | ${report.results.crowdworks.total} | ${report.results.upwork.total} | ${report.results.summary.totalJobs} |
| 高時給案件数 | - | ${report.highValueJobs.upwork.length} | ${report.results.summary.highHourlyJobs} |
| 検索成功 | ${report.results.crowdworks.success ? '✅' : '❌'} | ${report.results.upwork.success ? '✅' : '❌'} | - |
| 実行時間 | ${report.results.crowdworks.executionTime}ms | ${report.results.upwork.executionTime}ms | ${report.results.summary.executionTime}ms |

## 🎯 検索条件

- **最低時給**: ${report.criteria.minHourlyRate.toLocaleString()}円
- **最大取得件数**: ${report.criteria.maxJobsPerSource}件/サイト
- **対象カテゴリ**: ${report.criteria.categories.length > 0 ? report.criteria.categories.join(', ') : '全カテゴリ'}

## 📈 市場分析

${report.analysis.marketTrends}

## 🎯 おすすめ

${report.analysis.recommendations.map(rec => `- ${rec}`).join('\n')}

## ⚠️ 注意事項

${report.analysis.alerts.length > 0
            ? report.analysis.alerts.map(alert => `- ${alert}`).join('\n')
            : '特になし'}

## 💰 高時給案件 (Upwork)

${report.highValueJobs.upwork.length > 0
            ? report.highValueJobs.upwork.map(job => {
                const hourlyRate = CurrencyService.calculateUpworkHourlyRateJPY(job, 150);
                return `### ${job.title}
- **時給**: ${hourlyRate ? `${hourlyRate.toLocaleString()}円` : '固定価格'}
- **スキル**: ${job.skills.slice(0, 5).join(', ')}
- **提案数**: ${job.proposals}件
- **クライアント**: ${job.client.country || '不明'} (評価率: ${job.client.hireRate || 'N/A'}%)
- **URL**: [案件詳細](${job.url})

`;
            }).join('\n')
            : '条件に合う高時給案件が見つかりませんでした。'}

---

*このレポートは自動生成されました (${new Date().toISOString()})*
`;
}

/**
 * 高時給案件詳細レポート生成
 */
function generateHighValueJobsReport(report: IntegratedJobReport): string {
    return `# 高時給案件詳細レポート

> **最低時給条件**: ${report.criteria.minHourlyRate.toLocaleString()}円以上  
> **生成日時**: ${report.generatedAt.toLocaleString('ja-JP')}  

## 📊 サマリー

- **CrowdWorks高時給案件**: ${report.highValueJobs.crowdworks.length}件
- **Upwork高時給案件**: ${report.highValueJobs.upwork.length}件
- **総合計**: ${report.highValueJobs.crowdworks.length + report.highValueJobs.upwork.length}件

## 💰 Upwork 高時給案件詳細

${report.highValueJobs.upwork.map((job, index) => {
        const hourlyRate = CurrencyService.calculateUpworkHourlyRateJPY(job, 150);

        return `### ${index + 1}. ${job.title}

**基本情報**
- **時給**: ${hourlyRate ? `${hourlyRate.toLocaleString()}円 (USD $${job.budget.min || 'N/A'}-$${job.budget.max || 'N/A'})` : `固定価格 $${job.budget.amount}`}
- **案件タイプ**: ${job.jobType === 'hourly' ? '時間単価' : '固定価格'}
- **期間**: ${job.duration}
- **経験レベル**: ${job.experienceLevel}
- **提案数**: ${job.proposals}件

**クライアント情報**
- **国**: ${job.client.country || '不明'}
- **登録日**: ${job.client.memberSince || '不明'}
- **総支出**: $${job.client.totalSpent?.toLocaleString() || 'N/A'}
- **採用率**: ${job.client.hireRate || 'N/A'}%
- **支払い認証**: ${job.client.paymentVerified ? '✅' : '❌'}

**必要スキル**
${job.skills.map(skill => `- ${skill}`).join('\n')}

**案件説明**
${job.description.substring(0, 200)}...

**詳細URL**: [${job.url}](${job.url})

---

`;
    }).join('')}

## 🎯 CrowdWorks 高時給案件詳細

${report.highValueJobs.crowdworks.length > 0
            ? 'CrowdWorks案件の詳細はこちらに表示されます（実装予定）'
            : '条件に合うCrowdWorks案件が見つかりませんでした。'}

---

*詳細レポート生成完了*
`;
}

/**
 * 実行サマリーの表示
 */
function displaySummary(report: IntegratedJobReport, executionTime: number): void {
    console.log('\n🎉 統合ジョブサーチ完了！');
    console.log('='.repeat(50));
    console.log(`📊 総案件数: ${report.results.summary.totalJobs}件`);
    console.log(`💰 高時給案件: ${report.results.summary.highHourlyJobs}件`);
    console.log(`📈 平均時給: ${report.results.summary.averageHourlyRate.toLocaleString()}円`);
    console.log(`⏱️ 実行時間: ${Math.round(executionTime / 1000)}秒`);
    console.log('='.repeat(50));

    if (report.analysis.alerts.length > 0) {
        console.log('\n⚠️ 注意事項:');
        report.analysis.alerts.forEach(alert => console.log(`  - ${alert}`));
    }

    if (report.analysis.recommendations.length > 0) {
        console.log('\n🎯 おすすめ:');
        report.analysis.recommendations.forEach(rec => console.log(`  - ${rec}`));
    }
}

/**
 * CLIインターフェース
 */
async function main(): Promise<void> {
    const args = process.argv.slice(2);

    // ヘルプ表示
    if (args.includes('--help') || args.includes('-h')) {
        console.log(`
🔍 統合ジョブサーチツール - CrowdWorks & Upwork

使用方法:
  npm run integrated-search [オプション]

オプション:
  --min-rate <数値>     最低時給（円）[デフォルト: 3000]
  --max-jobs <数値>     最大取得件数/サイト [デフォルト: 50]
  --categories <文字列> 対象カテゴリ（カンマ区切り）
  --keywords <文字列>   検索キーワード（カンマ区切り）
  --format <形式>       出力形式 [json|markdown|both] [デフォルト: both]
  --help, -h           このヘルプを表示

環境変数:
  UPWORK_CONSUMER_KEY     Upwork Consumer Key（必須）
  UPWORK_CONSUMER_SECRET  Upwork Consumer Secret（必須）
  UPWORK_ACCESS_TOKEN     Upwork Access Token（オプション）
  UPWORK_ACCESS_TOKEN_SECRET Upwork Access Token Secret（オプション）

例:
  npm run integrated-search
  npm run integrated-search -- --min-rate 4000 --max-jobs 30
  npm run integrated-search -- --categories "web,mobile" --keywords "react,typescript"
    `);
        return;
    }

    // 引数の解析
    const options: Parameters<typeof executeIntegratedJobSearch>[0] = {};

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        const nextArg = args[i + 1];

        switch (arg) {
            case '--min-rate':
                if (nextArg !== undefined) {
                    options.minHourlyRate = parseInt(nextArg);
                    i++; // 次の引数をスキップ
                }
                break;
            case '--max-jobs':
                if (nextArg !== undefined) {
                    options.maxJobsPerSource = parseInt(nextArg);
                    i++; // 次の引数をスキップ
                }
                break;
            case '--categories':
                if (nextArg !== undefined) {
                    options.categories = nextArg.split(',').map(s => s.trim());
                    i++; // 次の引数をスキップ
                }
                break;
            case '--keywords':
                if (nextArg !== undefined) {
                    options.keywords = nextArg.split(',').map(s => s.trim());
                    i++; // 次の引数をスキップ
                }
                break;
            case '--format':
                if (nextArg !== undefined) {
                    options.outputFormat = nextArg as 'json' | 'markdown' | 'both';
                    i++; // 次の引数をスキップ
                }
                break;
        }
    }

    await executeIntegratedJobSearch(options);
}

// スクリプト実行
if (require.main === module) {
    main().catch(error => {
        console.error('❌ 実行エラー:', error instanceof Error ? error.message : String(error));
        process.exit(1);
    });
}

export { executeIntegratedJobSearch };
</file>

<file path="scripts/scrape-crowdworks-50jobs.ts">
import puppeteer from 'puppeteer';
import * as fs from 'fs';

interface CrowdWorksJob {
    jobId: string;
    title: string;
    category: string;
    url: string;
    budget: string;
    description: string;
    client: string;
    tags: string[];
    postedAt: string;
    scrapedAt: string;
}

async function scrapeCrowdWorksWebJobs(): Promise<void> {
    console.log('🚀 CrowdWorks Webエンジニアカテゴリスクレイピング開始（30件取得）');

    const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    const page = await browser.newPage();
    page.setDefaultTimeout(60000); // 60秒に延長
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');

    const allJobs: CrowdWorksJob[] = [];

    // Webエンジニアカテゴリから30件取得
    const categoryUrl = 'https://crowdworks.jp/public/jobs/category/241';
    console.log(`📄 カテゴリページにアクセス: ${categoryUrl}`);

    try {
        await page.goto(categoryUrl, { waitUntil: 'domcontentloaded', timeout: 60000 });
        await new Promise(resolve => setTimeout(resolve, 3000)); // 3秒待機

        // 案件リンクを30件取得
        const jobLinks = await page.evaluate(() => {
            const links: string[] = [];
            const linkElements = document.querySelectorAll('a[href*="/public/jobs/"]');

            for (let i = 0; i < linkElements.length; i++) {
                const link = linkElements[i] as HTMLAnchorElement;
                if (link) {
                    const href = link.getAttribute('href');
                    if (href && href.match(/\/public\/jobs\/\d+$/)) { // 数字のIDで終わるもののみ
                        const fullUrl = href.startsWith('http') ? href : `https://crowdworks.jp${href}`;
                        if (!links.includes(fullUrl)) {
                            links.push(fullUrl);
                        }
                    }
                }
            }

            return links.slice(0, 30); // 30件に制限
        });

        console.log(`📋 取得した案件URL数: ${jobLinks.length}件`);

        // 各案件の詳細を取得
        for (let i = 0; i < jobLinks.length; i++) {
            const jobUrl = jobLinks[i];
            if (!jobUrl) continue;

            console.log(`🔍 案件 ${i + 1}/${jobLinks.length} を処理中: ${jobUrl}`);

            try {
                const jobId = jobUrl.split('/').pop() || '';

                await page.goto(jobUrl, { waitUntil: 'domcontentloaded', timeout: 30000 });
                await new Promise(resolve => setTimeout(resolve, 2000)); // 2秒待機

                const jobDetails = await page.evaluate((currentUrl, currentJobId) => {
                    // タイトルの取得（成功したロジック）
                    let title = '';
                    const h1Elements = document.querySelectorAll('h1');
                    if (h1Elements.length >= 2) {
                        const secondH1 = h1Elements[1];
                        if (secondH1) {
                            const text = secondH1.textContent?.trim() || '';
                            const cleanText = text.replace(/\\n/g, ' ').replace(/\\s+/g, ' ');
                            const match = cleanText.match(/^(.+?)\\s+.*の仕事の依頼$/);
                            if (match && match[1]) {
                                title = match[1].trim();
                            } else {
                                const splitResult = cleanText.split('の仕事の依頼');
                                if (splitResult && splitResult[0]) {
                                    title = splitResult[0].trim();
                                }
                            }
                        }
                    }

                    // 予算の取得（テーブルから）
                    let budget = '';
                    const table = document.querySelector('table');
                    if (table) {
                        const rows = Array.from(table.querySelectorAll('tr'));
                        for (const row of rows) {
                            const cells = Array.from(row.querySelectorAll('td'));
                            if (cells.length >= 2) {
                                const secondCell = cells[1];
                                const text = secondCell?.textContent?.trim() || '';
                                if (text.includes('円') && (text.includes('〜') || text.includes('-') || text.includes('以上'))) {
                                    budget = text;
                                    break;
                                }
                            }
                        }
                    }

                    // フォールバック予算取得
                    if (!budget) {
                        const walker = document.createTreeWalker(
                            document.body,
                            NodeFilter.SHOW_TEXT
                        );
                        let node;
                        while (node = walker.nextNode()) {
                            const text = node.textContent?.trim() || '';
                            if (text.includes('円') && text.match(/[\\d,]+円/)) {
                                budget = text;
                                break;
                            }
                        }
                    }

                    // 説明文の取得（改善版）
                    let description = '';
                    const headings = Array.from(document.querySelectorAll('h2'));
                    const detailHeading = headings.find(h => h.textContent?.includes('仕事の詳細'));

                    if (detailHeading) {
                        let nextElement = detailHeading.nextElementSibling;
                        while (nextElement) {
                            if (nextElement.tagName === 'TABLE') {
                                const rows = Array.from(nextElement.querySelectorAll('tr'));
                                for (const row of rows) {
                                    const cells = Array.from(row.querySelectorAll('td'));
                                    if (cells.length >= 1) {
                                        const cellText = cells[0]?.textContent?.trim() || '';
                                        if (cellText.length > 50) {
                                            description = cellText.substring(0, 500);
                                            break;
                                        }
                                    }
                                }
                                break;
                            }
                            nextElement = nextElement.nextElementSibling;
                        }
                    }

                    // クライアント情報の取得
                    let client = '';
                    const clientElement = document.querySelector('a[href*="/public/employees/"] span, .client-name');
                    if (clientElement) {
                        client = clientElement.textContent?.trim() || '';
                    }

                    return {
                        jobId: currentJobId,
                        title: title || 'タイトル不明',
                        category: 'webエンジニア',
                        url: currentUrl || '',
                        budget: budget || '未取得',
                        description: description || 'ページアクセス制限またはデータ取得エラー',
                        client: client || '未取得',
                        tags: [],
                        postedAt: '',
                        scrapedAt: new Date().toISOString()
                    };
                }, jobUrl, jobId);

                allJobs.push(jobDetails);

                if (jobDetails.title !== 'タイトル不明' && jobDetails.budget !== '未取得') {
                    console.log(`✅ 成功: ${jobDetails.title}`);
                } else {
                    console.log(`⚠️ 部分取得: ${jobDetails.title} (${jobDetails.budget})`);
                }

            } catch (error) {
                console.error(`❌ 案件詳細取得エラー: ${error}`);
                allJobs.push({
                    jobId: jobUrl.split('/').pop() || '',
                    title: 'スクレイピングエラー',
                    category: 'webエンジニア',
                    url: jobUrl,
                    budget: 'エラー',
                    description: 'スクレイピング中にエラーが発生しました',
                    client: 'エラー',
                    tags: [],
                    postedAt: '',
                    scrapedAt: new Date().toISOString()
                });
            }
        }

        // ファイル出力
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `output/crowdworks-web-jobs-${timestamp}.json`;

        fs.writeFileSync(filename, JSON.stringify(allJobs, null, 2), 'utf8');

        console.log(`\\n🎉 CrowdWorks Webエンジニアスクレイピング完了！`);
        console.log(`📊 総取得件数: ${allJobs.length}件 (目標: 30件)`);
        console.log(`✅ タイトル取得成功: ${allJobs.filter(j => j.title !== 'タイトル不明').length}件`);
        console.log(`💰 予算取得成功: ${allJobs.filter(j => j.budget !== '未取得' && j.budget !== 'エラー').length}件`);
        console.log(`💾 保存先: ${filename}`);

    } catch (error) {
        console.error('💥 カテゴリページアクセスエラー:', error);
        process.exit(1);
    }

    await browser.close();
}

// メイン実行
if (require.main === module) {
    scrapeCrowdWorksWebJobs().catch(error => {
        console.error('💥 スクレイピングエラー:', error);
        process.exit(1);
    });
}

export default scrapeCrowdWorksWebJobs;
</file>

<file path="scripts/scrape-crowdworks.ts">
import puppeteer from 'puppeteer';
import { writeFileSync } from 'fs';

interface CrowdWorksJob {
    jobId: string;
    title: string;
    category: string;
    url: string;
    budget: string;
    description: string;
    client: string;
    tags: string[];
    postedAt: string;
    scrapedAt: string;
}

async function scrapeCrowdWorksJobs(): Promise<void> {
    console.log('🚀 CrowdWorksスクレイピング開始（各カテゴリ10件ずつ）');

    const browser = await puppeteer.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    const page = await browser.newPage();
    await page.setUserAgent('Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36');

    // カテゴリ設定（10件ずつ）
    const categories = [
        { name: 'development', url: 'https://crowdworks.jp/public/jobs/category/1', maxJobs: 10 },
        { name: 'web_products', url: 'https://crowdworks.jp/public/jobs/category/9', maxJobs: 10 },
        { name: 'ec', url: 'https://crowdworks.jp/public/jobs/category/10', maxJobs: 10 },
        { name: 'software_development', url: 'https://crowdworks.jp/public/jobs/category/236', maxJobs: 10 }
    ];

    const allJobs: CrowdWorksJob[] = [];

    for (const category of categories) {
        console.log(`\n📁 カテゴリ「${category.name}」をスクレイピング中...`);

        try {
            await page.goto(category.url, { waitUntil: 'networkidle2' });
            await new Promise(resolve => setTimeout(resolve, 2000));

            // 案件リンクを取得
            const jobLinks = await page.$$eval('a[href*="/public/jobs/"]', links =>
                links.map(link => (link as HTMLAnchorElement).href)
                    .filter(href => href.match(/\/public\/jobs\/\d+$/))
                    .slice(0, 10) // 10件に制限
            );

            console.log(`🔍 ${category.name}カテゴリ: ${jobLinks.length}件の案件を発見`);

            // 各案件の詳細を取得
            for (const [index, jobUrl] of jobLinks.entries()) {
                try {
                    console.log(`📋 ${index + 1}/${jobLinks.length}: ${jobUrl.split('/').pop()}`);

                    await page.goto(jobUrl, { waitUntil: 'networkidle2' });
                    await new Promise(resolve => setTimeout(resolve, 1000));

                    const jobData = await page.evaluate((url, categoryName) => {
                        const title = document.querySelector('h1')?.textContent?.trim() || '';
                        const jobId = url.split('/').pop() || '';

                        // 予算を取得（複数のセレクタを試行）
                        let budget = '';
                        const budgetSelectors = [
                            'table tr:has(th:contains("予算")) td',
                            'table tr:has(th:contains("固定報酬")) td',
                            'table tr:has(th:contains("時間単価")) td',
                            '.job-detail-table tr:has(th:contains("予算")) td'
                        ];

                        for (const selector of budgetSelectors) {
                            const element = document.querySelector(selector);
                            if (element && element.textContent?.trim()) {
                                budget = element.textContent.trim();
                                break;
                            }
                        }

                        // 詳細説明を取得
                        let description = '';
                        const descSelectors = [
                            '.job_description',
                            '.job-detail-description',
                            'div:has(h2:contains("依頼詳細")) + div',
                            '.description'
                        ];

                        for (const selector of descSelectors) {
                            const element = document.querySelector(selector);
                            if (element && element.textContent?.trim()) {
                                description = element.textContent.trim().substring(0, 500);
                                break;
                            }
                        }

                        // クライアント情報
                        let client = '';
                        const clientElement = document.querySelector('a[href*="/public/employees/"] span, .client-name');
                        if (clientElement) {
                            client = clientElement.textContent?.trim() || '';
                        }

                        return {
                            jobId,
                            title,
                            category: categoryName,
                            url,
                            budget,
                            description,
                            client,
                            tags: [],
                            postedAt: '',
                            scrapedAt: new Date().toISOString()
                        };
                    }, jobUrl, category.name);

                    allJobs.push(jobData);
                    console.log(`✅ ${jobData.title || 'タイトル不明'}`);

                } catch (error) {
                    console.log(`❌ 案件取得エラー: ${jobUrl}`);
                }
            }

        } catch (error) {
            console.error(`❌ カテゴリ「${category.name}」でエラー:`, error);
        }
    }

    // ファイル出力
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `output/crowdworks-jobs-${timestamp}.json`;

    writeFileSync(filename, JSON.stringify(allJobs, null, 2), 'utf8');

    console.log(`\n🎉 CrowdWorksスクレイピング完了！`);
    console.log(`📊 総取得件数: ${allJobs.length}件`);
    console.log(`💾 保存先: ${filename}`);

    await browser.close();
}

// メイン実行
if (require.main === module) {
    scrapeCrowdWorksJobs().catch(error => {
        console.error('💥 スクレイピングエラー:', error);
        process.exit(1);
    });
}

export default scrapeCrowdWorksJobs;
</file>

<file path="scripts/setup-github-oidc.sh">
#!/bin/bash

# GitHub Actions OIDC用のIAMロール作成スクリプト
# 使用方法: ./scripts/setup-github-oidc.sh <YOUR_GITHUB_USERNAME> <REPOSITORY_NAME>

set -e

# パラメータチェック
if [ $# -ne 2 ]; then
    echo "使用方法: $0 <GITHUB_USERNAME> <REPOSITORY_NAME>"
    echo "例: $0 myusername crowdworks-search"
    exit 1
fi

GITHUB_USERNAME=$1
REPOSITORY_NAME=$2
AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
AWS_REGION=$(aws configure get region || echo "ap-northeast-1")

echo "🚀 GitHub Actions OIDC認証セットアップを開始します..."
echo "GitHub: ${GITHUB_USERNAME}/${REPOSITORY_NAME}"
echo "AWS Account: ${AWS_ACCOUNT_ID}"
echo "AWS Region: ${AWS_REGION}"

# OIDC Identity Providerの作成（存在しない場合のみ）
echo "📋 OIDC Identity Providerをチェック中..."
if ! aws iam get-open-id-connect-provider --open-id-connect-provider-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com" 2>/dev/null; then
    echo "📝 OIDC Identity Providerを作成中..."
    aws iam create-open-id-connect-provider \
        --url "https://token.actions.githubusercontent.com" \
        --thumbprint-list "6938fd4d98bab03faadb97b34396831e3780aea1" \
        --client-id-list "sts.amazonaws.com"
    echo "✅ OIDC Identity Providerを作成しました"
else
    echo "✅ OIDC Identity Providerは既に存在します"
fi

# Staging環境用IAMロール作成
echo "📝 Staging環境用IAMロールを作成中..."
STAGING_ROLE_NAME="GitHubActions-CrowdWorksSearch-Staging"

# 信頼ポリシー
cat > /tmp/staging-trust-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
                },
                "StringLike": {
                    "token.actions.githubusercontent.com:sub": [
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:ref:refs/heads/develop",
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:environment:staging"
                    ]
                }
            }
        }
    ]
}
EOF

# Production環境用IAMロール作成
echo "📝 Production環境用IAMロールを作成中..."
PRODUCTION_ROLE_NAME="GitHubActions-CrowdWorksSearch-Production"

# 信頼ポリシー
cat > /tmp/production-trust-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
                },
                "StringLike": {
                    "token.actions.githubusercontent.com:sub": [
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:ref:refs/heads/main",
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:environment:production"
                    ]
                }
            }
        }
    ]
}
EOF

# 権限ポリシー
cat > /tmp/deploy-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "cloudformation:*",
                "s3:*",
                "lambda:*",
                "iam:*",
                "logs:*",
                "events:*",
                "ecr:*",
                "ssm:GetParameter",
                "ssm:GetParameters",
                "sts:AssumeRole"
            ],
            "Resource": "*"
        }
    ]
}
EOF

# Stagingロール作成
if aws iam get-role --role-name "${STAGING_ROLE_NAME}" 2>/dev/null; then
    echo "⚠️  Stagingロールは既に存在します。削除して再作成しますか？ (y/N)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        aws iam delete-role --role-name "${STAGING_ROLE_NAME}" || true
    else
        echo "Stagingロールの作成をスキップします"
    fi
fi

if ! aws iam get-role --role-name "${STAGING_ROLE_NAME}" 2>/dev/null; then
    aws iam create-role \
        --role-name "${STAGING_ROLE_NAME}" \
        --assume-role-policy-document file:///tmp/staging-trust-policy.json \
        --description "GitHub Actions deployment role for staging environment"
    
    aws iam put-role-policy \
        --role-name "${STAGING_ROLE_NAME}" \
        --policy-name "DeploymentPolicy" \
        --policy-document file:///tmp/deploy-policy.json
    
    echo "✅ Stagingロールを作成しました"
fi

# Productionロール作成
if aws iam get-role --role-name "${PRODUCTION_ROLE_NAME}" 2>/dev/null; then
    echo "⚠️  Productionロールは既に存在します。削除して再作成しますか？ (y/N)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        aws iam delete-role --role-name "${PRODUCTION_ROLE_NAME}" || true
    else
        echo "Productionロールの作成をスキップします"
    fi
fi

if ! aws iam get-role --role-name "${PRODUCTION_ROLE_NAME}" 2>/dev/null; then
    aws iam create-role \
        --role-name "${PRODUCTION_ROLE_NAME}" \
        --assume-role-policy-document file:///tmp/production-trust-policy.json \
        --description "GitHub Actions deployment role for production environment"
    
    aws iam put-role-policy \
        --role-name "${PRODUCTION_ROLE_NAME}" \
        --policy-name "DeploymentPolicy" \
        --policy-document file:///tmp/deploy-policy.json
    
    echo "✅ Productionロールを作成しました"
fi

# クリーンアップ
rm -f /tmp/staging-trust-policy.json /tmp/production-trust-policy.json /tmp/deploy-policy.json

echo ""
echo "🎉 セットアップが完了しました！"
echo ""
echo "次の手順:"
echo "1. GitHubリポジトリの Settings > Secrets and variables > Actions で以下のシークレットを設定してください："
echo ""
echo "   STAGING_AWS_ROLE_ARN=arn:aws:iam::${AWS_ACCOUNT_ID}:role/${STAGING_ROLE_NAME}"
echo "   PRODUCTION_AWS_ROLE_ARN=arn:aws:iam::${AWS_ACCOUNT_ID}:role/${PRODUCTION_ROLE_NAME}"
echo ""
echo "2. (オプション) Slack通知用："
echo "   SLACK_WEBHOOK_URL=<your-slack-webhook-url>"
echo ""
echo "3. GitHubでEnvironmentsを設定："
echo "   - Settings > Environments"
echo "   - 'staging' 環境を作成"
echo "   - 'production' 環境を作成（保護ルール設定推奨）"
echo ""
echo "これでCI/CDパイプラインでAWSデプロイが可能になります！"
</file>

<file path="scripts/test-lancers-5jobs.ts">
import puppeteer, { Browser, Page } from 'puppeteer';

interface LancersJob {
    id: string;
    title: string;
    description: string;
    budget: {
        type: 'fixed' | 'hourly' | 'unknown';
        amount: number;
        currency: string;
    };
    hourlyRate?: number;
    category: string;
    client: {
        name: string;
        rating: number;
        reviewCount: number;
        completionRate: string;
        orders: number;
    };
    skills: string[];
    applicationCount: number;
    isUrgent: boolean;
    postDate: string;
    deadline: string;
    url: string;
}

async function testLancersJobDetail(browser: Browser, jobId: string): Promise<LancersJob | null> {
    const page: Page = await browser.newPage();

    try {
        const url = `https://www.lancers.jp/work/detail/${jobId}`;
        console.log(`🔍 ランサーズ詳細ページ: ${url}`);

        await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
        await new Promise(resolve => setTimeout(resolve, 2000));

        // 削除やアクセス制限されたページかチェック
        const errorCheck = await page.evaluate(() => {
            const banner = document.querySelector('banner h1[level="1"]');
            if (banner) {
                const text = banner.textContent || '';
                if (text.includes('閲覧制限') || text.includes('削除')) {
                    return { error: true, message: text };
                }
            }
            return { error: false };
        });

        if (errorCheck.error) {
            console.log(`⚠️ ページアクセスエラー: ${jobId}`);
            return null;
        }

        const job: LancersJob = {
            id: jobId,
            title: '',
            description: '',
            budget: {
                type: 'unknown',
                amount: 0,
                currency: '円'
            },
            category: 'test',
            client: {
                name: '',
                rating: 0,
                reviewCount: 0,
                completionRate: '',
                orders: 0
            },
            skills: [],
            applicationCount: 0,
            isUrgent: false,
            postDate: '',
            deadline: '',
            url
        };

        // タイトルの取得（実際のランサーズ構造に基づく）
        try {
            const title = await page.evaluate(() => {
                const h1 = document.querySelector('h1');
                if (!h1) return '';

                // "【急募】オンライン子供向けプログラミングレッスン講師を募集！の仕事 [IT・通信・インターネット]"
                // から "【急募】オンライン子供向けプログラミングレッスン講師を募集！" を抽出
                const fullText = h1.textContent || '';
                const match = fullText.match(/^(.+?)の仕事/);
                return match ? match[1]!.trim() : fullText.replace(/\s*\[.*?\]\s*$/, '').trim();
            });

            if (title && title.length > 5) {
                job.title = title;
                console.log(`✅ タイトル: ${job.title}`);
            } else {
                console.log('⚠️ タイトルが見つかりません');
            }
        } catch (error) {
            console.error('タイトル取得エラー:', error);
        }

        // 予算の取得（定義リストからの抽出）
        try {
            const budget = await page.evaluate(() => {
                const terms = Array.from(document.querySelectorAll('dt'));
                for (const term of terms) {
                    if (term.textContent?.includes('提示した予算') || term.textContent?.includes('予算')) {
                        const dd = term.nextElementSibling;
                        if (dd && dd.tagName === 'DD') {
                            return dd.textContent?.trim() || '';
                        }
                    }
                }
                return '';
            });

            if (budget) {
                const amountMatch = budget.match(/(\d{1,3}(?:,\d{3})*)/);
                if (amountMatch && amountMatch[1]) {
                    job.budget.amount = parseInt(amountMatch[1].replace(/,/g, ''));
                    job.budget.type = budget.includes('時間') ? 'hourly' : 'fixed';
                    console.log(`✅ 予算: ${budget} (${job.budget.amount}円)`);
                }
            } else {
                console.log('⚠️ 予算情報が見つかりません');
            }
        } catch (error) {
            console.error('予算取得エラー:', error);
        }

        // 詳細説明の取得（定義リストからの抽出）
        try {
            const description = await page.evaluate(() => {
                const terms = Array.from(document.querySelectorAll('dt'));
                for (const term of terms) {
                    if (term.textContent?.includes('依頼概要')) {
                        const dd = term.nextElementSibling;
                        if (dd && dd.tagName === 'DD') {
                            const text = dd.textContent?.trim() || '';
                            // 最初の200文字に制限
                            return text.length > 200 ? text.substring(0, 200) + '...' : text;
                        }
                    }
                }
                return '';
            });

            if (description && description.length > 20) {
                job.description = description;
                console.log(`✅ 詳細説明: ${job.description.substring(0, 100)}...`);
            } else {
                console.log('⚠️ 詳細説明が見つかりません');
            }
        } catch (error) {
            console.error('詳細説明取得エラー:', error);
        }

        return job;

    } catch (error) {
        console.error(`❌ エラー (jobId: ${jobId}):`, error);
        return null;
    } finally {
        await page.close();
    }
}

async function main() {
    console.log('🚀 ランサーズ詳細スクレイピングテスト（5件）を開始します...');

    // 新しい有効なジョブID（実際のランサーズサイトから確認済み）
    const testJobIds: string[] = [
        '5323878', // 新しく取得されたID
        '5323864', // 新しく取得されたID
        '5323784', // 新しく取得されたID
        '5323287', // 新しく取得されたID
        '5323680'  // 新しく取得されたID
    ];

    const browser = await puppeteer.launch({
        headless: true,    // 高速実行のためheadlessモード
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-web-security',
            '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        ]
    });

    const results: LancersJob[] = [];

    for (let i = 0; i < testJobIds.length; i++) {
        const jobId = testJobIds[i]!;
        console.log(`\n📋 ${i + 1}/${testJobIds.length}: ${jobId} をスクレイピング中...`);

        const job = await testLancersJobDetail(browser, jobId);
        if (job) {
            results.push(job);
            console.log(`✅ 成功: ${job.title || 'タイトル不明'}`);
        } else {
            console.log(`❌ 失敗: ${jobId}`);
        }

        // リクエスト間隔を空ける
        if (i < testJobIds.length - 1) {
            await new Promise(resolve => setTimeout(resolve, 3000));
        }
    }

    await browser.close();

    // 結果の集計
    console.log('\n📊 結果サマリー:');
    console.log(`成功: ${results.length}/${testJobIds.length} (${Math.round(results.length / testJobIds.length * 100)}%)`);

    let titlesFound = 0;
    let budgetsFound = 0;
    let descriptionsFound = 0;

    results.forEach(job => {
        if (job.title) titlesFound++;
        if (job.budget.amount > 0) budgetsFound++;
        if (job.description) descriptionsFound++;
    });

    console.log(`タイトル取得: ${titlesFound}/${results.length}`);
    console.log(`予算取得: ${budgetsFound}/${results.length}`);
    console.log(`詳細説明取得: ${descriptionsFound}/${results.length}`);

    // 取得できたデータのサンプル表示
    if (results.length > 0) {
        console.log('\n📝 取得データサンプル:');
        for (let i = 0; i < Math.min(3, results.length); i++) {
            const job = results[i]!;
            console.log(`\n[${job.id}]`);
            console.log(`タイトル: ${job.title || '取得失敗'}`);
            console.log(`予算: ${job.budget.amount > 0 ? job.budget.amount + '円' : '取得失敗'}`);
            console.log(`説明: ${job.description ? job.description.substring(0, 50) + '...' : '取得失敗'}`);
        }
    }
}

main().catch(console.error);
</file>

<file path="scripts/test-scraping-5jobs.ts">
import puppeteer, { Browser, Page } from 'puppeteer';
import * as fs from 'fs';
import * as path from 'path';

interface JobDetail {
    jobId: string;
    category: string;
    url: string;
    title: string;
    paymentType: string;
    budget: string;
    deliveryDate: string;
    postDate: string;
    applicationDeadline: string;
    applicantCount: number;
    contractCount: number;
    recruitmentCount: number;
    favoriteCount: number;
    detailedDescription: string;
    client: {
        name: string;
        url: string;
        overallRating: string;
        orderHistory: string;
        completionRate: string;
        thankCount: string;
        identityVerified: boolean;
        orderRuleCheck: boolean;
        description: string;
    };
    desiredImages: string[];
    recentApplicants: any[];
    scrapedAt: string;
}

async function scrapeJobDetails(browser: Browser, jobId: string, category: string): Promise<JobDetail | null> {
    const page: Page = await browser.newPage();

    try {
        const url = `https://crowdworks.jp/public/jobs/${jobId}`;
        console.log(`🔍 スクレイピング中: ${url}`);

        await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
        await new Promise(resolve => setTimeout(resolve, 2000));

        const jobDetail: JobDetail = {
            jobId,
            category,
            url,
            title: '',
            paymentType: '',
            budget: '',
            deliveryDate: '',
            postDate: '',
            applicationDeadline: '',
            applicantCount: 0,
            contractCount: 0,
            recruitmentCount: 0,
            favoriteCount: 0,
            detailedDescription: '',
            client: {
                name: '',
                url: '',
                overallRating: '',
                orderHistory: '',
                completionRate: '',
                thankCount: '',
                identityVerified: false,
                orderRuleCheck: false,
                description: ''
            },
            desiredImages: [],
            recentApplicants: [],
            scrapedAt: new Date().toISOString()
        };

        // タイトルの取得
        try {
            // メインコンテンツエリアから案件タイトルを取得
            let titleFound = false;

            // デバッグ出力で確認した2番目のh1要素から案件名を抽出
            const mainH1 = await page.$$eval('h1', (elements) => {
                if (elements.length >= 2) {
                    const secondH1 = elements[1];
                    if (secondH1) {
                        const text = secondH1.textContent?.trim() || '';
                        // 改行と余分な空白を除去し、"の仕事の依頼"の前の部分を抽出
                        const cleanText = text.replace(/\n/g, ' ').replace(/\s+/g, ' ');
                        const match = cleanText.match(/^(.+?)\s+.*の仕事の依頼$/);
                        if (match && match[1]) {
                            return match[1].trim();
                        }
                        const splitResult = cleanText.split('の仕事の依頼');
                        if (splitResult && splitResult[0]) {
                            return splitResult[0].trim();
                        }
                    }
                }
                return '';
            }).catch(() => '');

            if (mainH1 && mainH1.length > 5 && !mainH1.includes('クラウドソーシング')) {
                jobDetail.title = mainH1;
                console.log(`✅ タイトル: ${jobDetail.title}`);
                titleFound = true;
            }

            if (!titleFound) {
                // パンくずリストの最後の要素から取得を試行
                const breadcrumbTitle = await page.$eval('li:last-child generic', (el: Element) => {
                    return el.textContent?.trim() || '';
                }).catch(() => '');

                if (breadcrumbTitle && breadcrumbTitle.length > 10 && !breadcrumbTitle.includes('クラウドソーシング')) {
                    jobDetail.title = breadcrumbTitle;
                    console.log(`✅ タイトル (パンくず): ${jobDetail.title}`);
                    titleFound = true;
                }
            }

            if (!titleFound) {
                console.log('⚠️ タイトルが見つかりません');
                // デバッグ用
                const allHeadings = await page.$$eval('h1, h2', (elements) =>
                    elements.map(el => el.textContent?.trim()).filter(t => t && t.length > 10)
                );
                console.log('見つかったheading要素:', allHeadings.slice(0, 3));
            }
        } catch (error) {
            console.error('タイトル取得エラー:', error);
        }

        // 予算の取得
        try {
            // テーブルから予算情報を抽出
            const budgetFromTable = await page.$eval('table', (table: Element) => {
                const rows = Array.from(table.querySelectorAll('tr'));
                for (const row of rows) {
                    const cells = Array.from(row.querySelectorAll('td'));
                    if (cells.length >= 2) {
                        const secondCell = cells[1];
                        const text = secondCell?.textContent?.trim() || '';
                        if (text.includes('円') && (text.includes('〜') || text.includes('-') || text.includes('以上'))) {
                            return text;
                        }
                    }
                }
                return '';
            });

            if (budgetFromTable) {
                jobDetail.budget = budgetFromTable;
                console.log(`✅ 予算: ${jobDetail.budget}`);
            } else {
                // フォールバック: 円を含むテキストを探す
                const budgetText = await page.evaluate(() => {
                    const walker = document.createTreeWalker(
                        document.body,
                        NodeFilter.SHOW_TEXT
                    );

                    let node;
                    while (node = walker.nextNode()) {
                        const text = node.textContent?.trim() || '';
                        if (text.includes('円') && text.match(/[\d,]+円/)) {
                            return text;
                        }
                    }
                    return '';
                });

                if (budgetText) {
                    jobDetail.budget = budgetText;
                    console.log(`✅ 予算 (フォールバック): ${jobDetail.budget}`);
                } else {
                    console.log('⚠️ 予算情報が見つかりません');
                }
            }
        } catch (error) {
            console.error('予算取得エラー:', error);
        }

        // 詳細説明の取得
        try {
            // "仕事の詳細"セクションから詳細説明を抽出
            const detailFromTable = await page.evaluate(() => {
                // "仕事の詳細"というヘッダーの後のテーブルを探す
                const headings = Array.from(document.querySelectorAll('h2'));
                const detailHeading = headings.find(h => h.textContent?.includes('仕事の詳細'));

                if (detailHeading) {
                    // 次のテーブル要素を探す
                    let nextElement = detailHeading.nextElementSibling;
                    while (nextElement) {
                        if (nextElement.tagName === 'TABLE') {
                            const rows = Array.from(nextElement.querySelectorAll('tr'));
                            for (const row of rows) {
                                const cells = Array.from(row.querySelectorAll('td'));
                                if (cells.length >= 1) {
                                    const cellText = cells[0]?.textContent?.trim() || '';
                                    if (cellText.length > 100 && (cellText.includes('概要') || cellText.includes('業務') || cellText.includes('必要'))) {
                                        return cellText;
                                    }
                                }
                            }
                        }
                        nextElement = nextElement.nextElementSibling;
                    }
                }
                return '';
            });

            if (detailFromTable) {
                jobDetail.detailedDescription = detailFromTable;
                console.log(`✅ 詳細説明: ${jobDetail.detailedDescription.substring(0, 100)}...`);
            } else {
                console.log('⚠️ 詳細説明が見つかりません');
            }
        } catch (error) {
            console.error('詳細説明取得エラー:', error);
        }

        return jobDetail;

    } catch (error) {
        console.error(`❌ エラー (jobId: ${jobId}):`, error);
        return null;
    } finally {
        await page.close();
    }
}

async function main() {
    console.log('🚀 クラウドワークス詳細スクレイピングテスト（5件）を開始します...');

    // テスト用のジョブID（最近のものから5件）
    const testJobIds: string[] = [
        '12130347',
        '12132217',
        '12135465',
        '12041204',
        '12056088'
    ];

    const browser = await puppeteer.launch({
        headless: false, // デバッグのため表示
        slowMo: 1000,    // 動作を遅くしてデバッグ
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-web-security',
            '--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        ]
    });

    const results: JobDetail[] = [];

    for (let i = 0; i < testJobIds.length; i++) {
        const jobId = testJobIds[i]!;
        console.log(`\n📋 ${i + 1}/${testJobIds.length}: ${jobId} をスクレイピング中...`);

        const jobDetail = await scrapeJobDetails(browser, jobId, 'development');
        if (jobDetail) {
            results.push(jobDetail);
            console.log(`✅ 成功: ${jobDetail.title || 'タイトル不明'}`);
        } else {
            console.log(`❌ 失敗: ${jobId}`);
        }

        // 間隔を開ける
        await new Promise(resolve => setTimeout(resolve, 3000));
    }

    await browser.close();

    // 結果を保存
    const outputDir = path.join(process.cwd(), 'output');
    if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
    }

    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const filename = `test-scraping-results-${timestamp}.json`;
    const filepath = path.join(outputDir, filename);

    fs.writeFileSync(filepath, JSON.stringify(results, null, 2), 'utf8');

    console.log(`\n📊 テスト完了！`);
    console.log(`📁 結果保存先: ${filepath}`);
    console.log(`📈 成功: ${results.length}/${testJobIds.length}件`);

    // 結果のサマリー表示
    results.forEach((job, i) => {
        console.log(`\n[${i + 1}] ID: ${job.jobId}`);
        console.log(`    タイトル: ${job.title || '未取得'}`);
        console.log(`    予算: ${job.budget || '未取得'}`);
        console.log(`    説明: ${job.detailedDescription ? job.detailedDescription.substring(0, 50) + '...' : '未取得'}`);
    });
}

if (require.main === module) {
    main().catch(console.error);
}
</file>

<file path="src/analysis/unified-analysis.ts">
import * as fs from 'fs';
import * as path from 'path';

// 統合分析実行
async function main() {
  console.log('🚀 クラウドワークス＆ランサーズ統合分析開始');
  
  const outputDir = path.join(process.cwd(), 'output');
  const analysis: any = {
    timestamp: new Date().toISOString(),
    summary: {},
    platformComparison: {},
    insights: []
  };
  
  // クラウドワークスデータ読み込み
  const cwFiles = ['details-ec.json', 'details-web_products.json', 'details-software_development.json'];
  let cwJobs = 0;
  
  for (const file of cwFiles) {
    const filepath = path.join(outputDir, file);
    if (fs.existsSync(filepath)) {
      const data = JSON.parse(fs.readFileSync(filepath, 'utf-8'));
      if (Array.isArray(data)) {
        cwJobs += data.length;
        console.log(`📊 ${file}: ${data.length}件`);
      }
    }
  }
  
  // ランサーズデータ読み込み
  const lancersFile = path.join(outputDir, 'lancers-all-jobs.json');
  let lancersJobs = 0;
  if (fs.existsSync(lancersFile)) {
    const data = JSON.parse(fs.readFileSync(lancersFile, 'utf-8'));
    if (Array.isArray(data)) {
      lancersJobs = data.length;
      console.log(`📊 ランサーズ: ${data.length}件`);
    }
  }
  
  // 分析結果
  analysis.summary = {
    crowdworksJobs: cwJobs,
    lancersJobs: lancersJobs,
    totalJobs: cwJobs + lancersJobs,
    analyzedAt: new Date().toLocaleString('ja-JP')
  };
  
  analysis.insights = [
    `総案件数: ${cwJobs + lancersJobs}件`,
    `クラウドワークス: ${cwJobs}件`,
    `ランサーズ: ${lancersJobs}件`,
    'ランサーズのログイン機能が正常に動作',
    '両プラットフォームからの案件取得に成功'
  ];
  
  // レポート生成
  const report = `# 統合案件分析レポート

## 📊 概要
- **総案件数**: ${cwJobs + lancersJobs}件
- **クラウドワークス**: ${cwJobs}件
- **ランサーズ**: ${lancersJobs}件
- **分析日時**: ${new Date().toLocaleString('ja-JP')}

## ✅ 実装完了事項
- クラウドワークスのスクレイピング修正完了
- ランサーズログイン機能実装完了
- 両プラットフォームからの統合データ取得成功

## 🔧 技術的成果
- MCP経由でのDOM要素確認と修正
- 型安全なTypeScript実装
- エラーハンドリングの改善
- 新しいDOM構造への対応

---
*${new Date().toLocaleString('ja-JP')} 生成*`;
  
  // レポート保存
  const reportPath = path.join(outputDir, `unified-analysis-${new Date().toISOString().split('T')[0]}.md`);
  fs.writeFileSync(reportPath, report, 'utf-8');
  
  console.log(`✅ 統合分析完了! レポート: ${reportPath}`);
  console.log('📊 分析結果:', analysis.summary);
}

if (require.main === module) {
  main();
}
</file>

<file path="src/services/AppliedJobsService.ts">
import { Page } from 'playwright';
import { CrowdWorksCredentials, CrowdWorksLoginResult } from '../types';

/**
 * 応募済み案件情報
 */
export interface AppliedJob {
    jobId: string;
    title: string;
    url: string;
    applicationDate: string;
    status: string;
}

/**
 * 応募済み案件取得サービス
 */
export class AppliedJobsService {
    private page: Page;
    private credentials: CrowdWorksCredentials;

    constructor(page: Page, credentials: CrowdWorksCredentials) {
        this.page = page;
        this.credentials = credentials;
    }

    /**
     * CrowdWorksにログインする
     */
    async login(): Promise<CrowdWorksLoginResult> {
        const startTime = Date.now();

        try {
            console.log('🔑 CrowdWorksにログイン中...');

            // ログインページに移動
            await this.page.goto('https://crowdworks.jp/login', {
                waitUntil: 'networkidle',
                timeout: 30000
            });

            // すでにログイン済みかチェック
            const isAlreadyLoggedIn = await this.page.evaluate(() => {
                return !document.querySelector('textbox[name="メールアドレス"]') &&
                    !document.querySelector('input[type="email"]') &&
                    !document.title.includes('ログイン');
            });

            if (isAlreadyLoggedIn) {
                console.log('✅ 既にログイン済みです');
                return {
                    success: true,
                    isLoggedIn: true,
                    executionTime: Date.now() - startTime
                };
            }

            // メールアドレスとパスワードを入力（ブラウザで確認したセレクターを使用）
            await this.page.getByRole('textbox', { name: 'メールアドレス' }).fill(this.credentials.email);
            await this.page.getByRole('textbox', { name: 'パスワード' }).fill(this.credentials.password);

            // ログインボタンをクリック
            await this.page.getByRole('button', { name: 'ログイン', exact: true }).click();

            // ログイン完了を待機
            await this.page.waitForURL(url => !url.toString().includes('/login'), { timeout: 15000 });

            console.log('✅ ログインに成功しました');

            return {
                success: true,
                isLoggedIn: true,
                executionTime: Date.now() - startTime
            };

        } catch (error) {
            console.error('❌ ログインに失敗しました:', error);
            return {
                success: false,
                isLoggedIn: false,
                error: error instanceof Error ? error.message : 'ログインに失敗しました',
                executionTime: Date.now() - startTime
            };
        }
    }

    /**
     * 応募済み案件一覧を取得する
     */
    async getAppliedJobs(): Promise<AppliedJob[]> {
        try {
            console.log('📋 応募済み案件を取得中...');

            // 応募済み案件ページに移動
            await this.page.goto('https://crowdworks.jp/e/proposals?ref=mypage_joboffers_all', {
                waitUntil: 'networkidle',
                timeout: 30000
            });

            // 応募済み案件を取得
            const appliedJobs = await this.page.evaluate(() => {
                const jobs: AppliedJob[] = [];

                // 応募済み案件のセレクタを特定する（実際のHTMLに基づいて調整）
                const jobElements = document.querySelectorAll('.proposal-item, .job-item, [data-job-id]');

                jobElements.forEach(element => {
                    try {
                        // jobIdをURLから抽出
                        const linkElement = element.querySelector('a[href*="/public/jobs/"]') as HTMLAnchorElement;
                        if (!linkElement) return;

                        const url = linkElement.href;
                        const jobIdMatch = url.match(/\/jobs\/(\d+)/);
                        if (!jobIdMatch) return;

                        const jobId = jobIdMatch[1];

                        // タイトルを取得
                        const titleElement = element.querySelector('.job-title, .proposal-title, h3, h4');
                        const title = titleElement?.textContent?.trim() || '';

                        // 応募日を取得（可能であれば）
                        const dateElement = element.querySelector('.application-date, .proposal-date, .date');
                        const applicationDate = dateElement?.textContent?.trim() || '';

                        // ステータスを取得（可能であれば）
                        const statusElement = element.querySelector('.status, .proposal-status');
                        const status = statusElement?.textContent?.trim() || '';

                        if (jobId && title) {
                            jobs.push({
                                jobId,
                                title,
                                url,
                                applicationDate,
                                status
                            });
                        }
                    } catch (error) {
                        console.warn('案件の解析でエラー:', error);
                    }
                });

                return jobs;
            });

            console.log(`✅ 応募済み案件を${appliedJobs.length}件取得しました`);

            // ログ出力
            if (appliedJobs.length > 0) {
                console.log('📋 応募済み案件一覧:');
                appliedJobs.slice(0, 5).forEach((job, index) => {
                    console.log(`  ${index + 1}. ${job.title} (ID: ${job.jobId})`);
                });
                if (appliedJobs.length > 5) {
                    console.log(`  ... 他${appliedJobs.length - 5}件`);
                }
            }

            return appliedJobs;

        } catch (error) {
            console.error('❌ 応募済み案件の取得に失敗しました:', error);
            return [];
        }
    }

    /**
     * 応募済み案件のJobIDセットを取得する
     */
    async getAppliedJobIds(): Promise<Set<string>> {
        const appliedJobs = await this.getAppliedJobs();
        return new Set(appliedJobs.map(job => job.jobId));
    }
}
</file>

<file path="app.ts">
#!/usr/bin/env node
import 'source-map-support/register';
import * as cdk from 'aws-cdk-lib';
import { CrowdWorksSearcherStack } from './src/infrastructure/crowdworks-searcher-stack';

const app = new cdk.App();

// 環境設定
const account = process.env['CDK_DEFAULT_ACCOUNT'];
const region = process.env['CDK_DEFAULT_REGION'] || process.env['AWS_REGION'] || 'ap-northeast-1';
const stage = app.node.tryGetContext('stage') || process.env['STAGE'] || 'dev';

const env: cdk.Environment = account ? { account, region } : { region };

// ステージ別のスタック設定
const getStackConfig = (stage: string) => {
    const baseConfig = {
        env,
        description: `CrowdWorks Auto Job Searcher System - ${stage.toUpperCase()}`,
        stage,
    };

    switch (stage) {
        case 'production':
            return {
                ...baseConfig,
                terminationProtection: true, // 本番環境では削除保護を有効
            };
        case 'staging':
            return {
                ...baseConfig,
                terminationProtection: false,
            };
        default: // dev, test, etc.
            return {
                ...baseConfig,
                terminationProtection: false,
            };
    }
};

// スタック作成
const stackConfig = getStackConfig(stage);
new CrowdWorksSearcherStack(app, `CrowdWorksSearcherStack-${stage}`, stackConfig);

// タグを全リソースに適用
cdk.Tags.of(app).add('Application', 'CrowdWorksSearcher');
cdk.Tags.of(app).add('Stage', stage);
cdk.Tags.of(app).add('ManagedBy', 'CDK');

console.log(`🚀 Deploying CrowdWorks Searcher to ${stage.toUpperCase()} environment`);
console.log(`   Region: ${region}`);
console.log(`   Account: ${account || 'default'}`);
</file>

<file path="scripts/analyze-details.ts">
require('dotenv').config();

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { OpenAI } from 'openai';
import * as path from 'path';

// 型定義
interface CrowdWorksJobDetail {
    jobId: string;
    title: string;
    detailedDescription: string;
    [key: string]: any;
}

interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    難易度: string;
    簡易設計: string;
    gpt_summary: string;
}

// .envからAPIキー取得
const apiKey = process.env['OPENAI_API_KEY'];
if (!apiKey) {
    console.error('❌ OPENAI_API_KEYが設定されていません');
    process.exit(1);
}

const openai = new OpenAI({ apiKey });

// 引数: 入力ファイル, 出力ファイル
const [, , inputFile, outputFile] = process.argv;
if (!inputFile || !outputFile) {
    console.error('Usage: ts-node scripts/analyze-details.ts <input.json> <output.json>');
    process.exit(1);
}

const inputPath = path.resolve(inputFile);
const outputPath = path.resolve(outputFile);

const details: CrowdWorksJobDetail[] = JSON.parse(readFileSync(inputPath, 'utf8'));

// 既存の分析済みデータをキャッシュとして読み込み
let existingAnalysis: AnalysisResult[] = [];
if (existsSync(outputPath)) {
    try {
        existingAnalysis = JSON.parse(readFileSync(outputPath, 'utf8'));
        console.log(`📋 既存の分析済みデータを読み込み: ${existingAnalysis.length}件`);
    } catch (error) {
        console.log(`⚠️ 既存データの読み込みに失敗: ${error}`);
        existingAnalysis = [];
    }
} else {
    console.log(`📝 新規分析ファイルを作成: ${outputPath}`);
}

// 既存の分析済みjobIdのセットを作成
const existingJobIds = new Set(existingAnalysis.map(analysis => analysis.jobId));

// 新規分析が必要な案件のみを抽出
const newDetails = details.filter(detail => !existingJobIds.has(detail.jobId));
const cacheHitCount = details.length - newDetails.length;

console.log(`📊 キャッシュ状況:`);
console.log(`   全案件数: ${details.length}件`);
console.log(`   キャッシュヒット: ${cacheHitCount}件`);
console.log(`   新規分析対象: ${newDetails.length}件`);

if (newDetails.length === 0) {
    console.log(`🎉 全案件が既に分析済みです。処理をスキップします。`);
    process.exit(0);
}

// 並列実行制御クラス
class ConcurrencyLimiter {
    private runningCount = 0;
    private queue: (() => Promise<void>)[] = [];

    constructor(private maxConcurrency: number) { }

    async execute<T>(task: () => Promise<T>): Promise<T> {
        return new Promise<T>((resolve, reject) => {
            const wrappedTask = async () => {
                try {
                    this.runningCount++;
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.runningCount--;
                    this.processQueue();
                }
            };

            if (this.runningCount < this.maxConcurrency) {
                wrappedTask();
            } else {
                this.queue.push(wrappedTask);
            }
        });
    }

    private processQueue() {
        if (this.queue.length > 0 && this.runningCount < this.maxConcurrency) {
            const nextTask = this.queue.shift();
            if (nextTask) {
                nextTask();
            }
        }
    }
}

const limiter = new ConcurrencyLimiter(5); // 最大5件並列

async function analyzeDetail(detail: CrowdWorksJobDetail): Promise<AnalysisResult> {
    const prompt = `以下はクラウドワークスの案件詳細です。内容を読んで、
1. この仕事にかかるおおよその工数（何時間くらいか）
2. 想定される時給（日本円・固定値で1つの数値のみ）
3. 案件の難易度（簡単/普通/難しい のいずれか）
4. 簡易的な設計・アプローチ（どのような手順・技術で進めるか）
5. その根拠や注意点
を日本語で簡潔にまとめてください。

【重要な工数見積もりのポイント】
- 記載された作業内容だけでなく、以下の前作業・付帯作業も必ず含めて計算してください：
  * 要件定義・要件整理（クライアントとの認識合わせ）
  * 初回打ち合わせ・ヒアリング（1-3回程度）
  * 提案書・企画書・仕様書の作成
  * 作業中の進捗報告・中間確認
  * 修正・調整作業（通常2-3回は発生）
  * テスト・検証・品質チェック
  * 納品作業・説明・引き継ぎ
  * 納品後の軽微なサポート・質問対応

【重要な難易度判定のポイント】
- **簡単**: 初心者・未経験者でも対応可能、基本的なスキルで十分、テンプレート作業中心
- **普通**: 一般的なスキルレベルが必要、多少の学習や調査が必要、標準的な業務
- **難しい**: 高度な専門知識・技術が必要、豊富な経験が前提、複雑な要件や新技術

【重要な注意点】
- クラウドワークスの案件は玉石混交で、タイトルで指定した価格が案件詳細では嘘だと書かれていたりします
- 詳細説明を注意深く読み、実際の作業内容と報酬を正確に把握してください
- タイトルの金額に惑わされず、詳細に書かれた実際の条件から確からしい想定時給を算出してください
- "〇〇円スタート"「能力に応じて」などの曖昧な表現にも注意してください
- 初回は低価格で「継続で単価アップ」という案件は、初回価格を基準に計算してください
- **時給は必ず1つの具体的な数値で回答してください（例：2500円）。範囲や曖昧な表現は禁止です**
- **難易度は必ず「簡単」「普通」「難しい」のいずれか1つで回答してください**
- **実際のフリーランス作業の現実を反映した、十分な工数を見積もってください**

---
タイトル: ${detail.title}

詳細説明: ${detail.detailedDescription}
---

【出力フォーマット】
工数: <例: 8時間>
時給: <例: 2500円>
難易度: <例: 普通>
設計: <例: React+TypeScriptでSPA構築、API連携、レスポンシブ対応>
要約: <根拠や注意点を1-2文で>`;

    return limiter.execute(async () => {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは日本のフリーランス市場の専門家で、クラウドワークス案件の現実的な工数見積もりと時給推定の専門家です。実際のフリーランス作業では要件定義や打ち合わせ、修正作業なども必要で、記載された作業以外にも多くの付帯作業が発生することを理解しています。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 512,
            temperature: 0.2,
        });

        const text = res.choices[0]?.message?.content || '';
        // シンプルなパース
        const 工数 = text.match(/工数[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 時給 = text.match(/時給[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 難易度 = text.match(/難易度[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 設計 = text.match(/設計[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 要約 = text.match(/要約[:：]\s*([\s\S]*)/)?.[1]?.trim() || text;

        return {
            jobId: detail.jobId,
            title: detail.title,
            工数_見積もり: 工数,
            想定時給: 時給,
            難易度: 難易度,
            簡易設計: 設計,
            gpt_summary: 要約,
        };
    });
}

(async () => {
    console.log(`🚀 並列分析開始: ${newDetails.length}件（最大5件並列）`);
    const results: AnalysisResult[] = [];
    let completed = 0;

    // 全ての案件を並列で処理開始
    const promises = newDetails.map(async (detail, index) => {
        try {
            const result = await analyzeDetail(detail);
            results.push(result);
            completed++;
            console.log(`✅ [${completed}/${newDetails.length}] ${detail.title.substring(0, 50)}...`);

            // 定期的に中間結果を保存
            if (completed % 5 === 0 || completed === newDetails.length) {
                // 既存データと新規データをマージ
                const allResults = [...existingAnalysis, ...results];
                const sortedResults = allResults.sort((a, b) => a.jobId.localeCompare(b.jobId));
                writeFileSync(outputPath, JSON.stringify(sortedResults, null, 2), 'utf8');
                console.log(`💾 中間保存: 新規${completed}件 + 既存${existingAnalysis.length}件 = 計${sortedResults.length}件`);
            }

            return { success: true, result, index };
        } catch (e) {
            console.error(`❌ [${index + 1}/${newDetails.length}] ${detail.title.substring(0, 50)}... - エラー:`, e);
            return { success: false, error: e, index };
        }
    });

    // 全ての処理が完了するまで待機
    const settledResults = await Promise.allSettled(promises);

    // 最終結果の統計
    const successful = settledResults.filter(r => r.status === 'fulfilled' && r.value.success).length;
    const failed = settledResults.length - successful;

    console.log(`\n🎯 並列分析完了:`)
    console.log(`✅ 新規分析成功: ${successful}件`);
    console.log(`❌ 新規分析失敗: ${failed}件`);
    console.log(`💾 キャッシュから再利用: ${cacheHitCount}件`);
    console.log(`📁 出力ファイル: ${outputPath}`);

    // 既存データと新規データをマージして最終保存
    const allResults = [...existingAnalysis, ...results];
    const finalResults = allResults.sort((a, b) => a.jobId.localeCompare(b.jobId));
    writeFileSync(outputPath, JSON.stringify(finalResults, null, 2), 'utf8');
    console.log(`💾 最終保存完了: 新規${results.length}件 + 既存${existingAnalysis.length}件 = 計${finalResults.length}件`);
})();
</file>

<file path="src/utils/index.ts">
// Utility functions exports
// TODO: ユーティリティ関数を実装後、ここからエクスポート

export {};
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
yarn.lock

# Build outputs
dist/
build/
*.tsbuildinfo

# TypeScript
*.d.ts
*.d.ts.map
*.js.map

# AWS CDK
cdk.out/
cdk.context.json

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log

# Coverage
coverage/
.nyc_output/

# Jest
jest_0/

# Temporary files
tmp/
temp/

# Docker
.dockerignore

# Husky
.husky/_/

# Output files (scraped data, analysis results, reports)
output/
*.json
*.md
!README.md
!package.json
!tsconfig.json
</file>

<file path="env.example">
# ローカル開発用環境変数
# このファイルを .env にコピーして実際の値を設定してください

# CrowdWorks認証情報（ローカル開発用）
CROWDWORKS_EMAIL=your-crowdworks-email@example.com
CROWDWORKS_PASSWORD=your-crowdworks-password

# Upwork API認証情報（統合ジョブサーチ用）
UPWORK_CONSUMER_KEY=your-upwork-consumer-key
UPWORK_CONSUMER_SECRET=your-upwork-consumer-secret
UPWORK_ACCESS_TOKEN=your-upwork-access-token
UPWORK_ACCESS_TOKEN_SECRET=your-upwork-access-token-secret

# OpenAI API設定
OPENAI_API_KEY=your-openai-api-key

# AWS設定（必要に応じて）
AWS_REGION=ap-northeast-1
AWS_PROFILE=default

# デバッグ設定
NODE_ENV=development
LOG_LEVEL=debug
DEBUG=1

# Playwright設定（ローカル開発用）
# ローカル環境では通常は空または未設定でOK（Playwrightが自動で見つける）
# カスタムパスを使いたい場合のみ設定
PLAYWRIGHT_BROWSERS_PATH=
# 例：カスタムインストール場所を使用する場合
# PLAYWRIGHT_BROWSERS_PATH=C:\Users\n\AppData\Local\ms-playwright

# ローカル環境ではブラウザダウンロードをスキップしない（0 = ダウンロードする）
PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=0
</file>

<file path="jest.config.js">
module.exports = {
    // テスト環境
    preset: 'ts-jest',
    testEnvironment: 'node',

    // TypeScript設定
    transform: {
        '^.+\\.tsx?$': ['ts-jest', {
            tsconfig: './tsconfig.json'
        }]
    },

    // ファイル拡張子の設定
    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],

    // パスマッピング（tsconfig.jsonと同期）
    moduleNameMapper: {
        '^@/(.*)$': '<rootDir>/src/$1',
        '^@/types/(.*)$': '<rootDir>/src/types/$1',
        '^@/services/(.*)$': '<rootDir>/src/services/$1',
        '^@/utils/(.*)$': '<rootDir>/src/utils/$1',
        '^@/infrastructure/(.*)$': '<rootDir>/src/infrastructure/$1'
    },

    // テストファイルのパターン
    testMatch: [
        '<rootDir>/src/**/*.test.(ts|tsx)',
        '<rootDir>/src/**/*.spec.(ts|tsx)',
        '<rootDir>/test/**/*.test.(ts|tsx)',
        '<rootDir>/test/**/*.spec.(ts|tsx)'
    ],

    // カバレッジ設定
    collectCoverage: false, // デフォルトでは無効（npm run test:coverageで有効）
    collectCoverageFrom: [
        'src/**/*.{ts,tsx}',
        '!src/**/*.d.ts',
        '!src/**/*.test.{ts,tsx}',
        '!src/**/*.spec.{ts,tsx}',
        '!src/test/**/*',
        '!src/types/**/*', // 型定義はカバレッジから除外
    ],
    coverageDirectory: 'coverage',
    coverageReporters: ['text', 'lcov', 'html'],
    // TODO: アプリケーション実装後にカバレッジ要件を復活
    // coverageThreshold: {
    //     global: {
    //         branches: 20,   // 75% → 20% に一時的に緩和
    //         functions: 20,  // 80% → 20% に一時的に緩和
    //         lines: 20,      // 80% → 20% に一時的に緩和
    //         statements: 20  // 80% → 20% に一時的に緩和
    //     }
    // },

    // セットアップファイル
    setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],

    // モック設定
    clearMocks: true,
    resetMocks: true,
    restoreMocks: true,

    // タイムアウト設定
    testTimeout: 30000, // 30秒（AWS SDK呼び出しなど時間がかかる場合に対応）

    // 並列実行設定
    maxWorkers: '50%', // CPUコア数の50%で並列実行

    // エラー表示設定
    verbose: true,
    errorOnDeprecated: true,

    // 不要なログを抑制
    silent: false,

    // テスト実行前後のフック
    globalSetup: undefined,
    globalTeardown: undefined
};
</file>

<file path="scripts/create-unified-report.ts">
import * as fs from 'fs';
import * as path from 'path';

// Job型定義
interface Job {
    id: string;
    title: string;
    platform: string;
    url: string;
    budget: {
        amount: number;
        currency: string;
        type: string;
    };
    hourlyRate: number;
    category: string;
    subcategory?: string;
    description: string;
    client?: string;
    clientRating?: number;
    clientOrderCount?: number;
    postedAt?: Date | string;
    deadline?: string;
    tags?: string[];
    workType?: string;
    isUrgent?: boolean;
    isPremium?: boolean;
    industry?: string;
    workRank?: string;
    appliedCount?: number;
    recruitCount?: number;
    scrapedAt: string;
}

// interface AnalyzedJob {
//     jobId: string;
//     title: string;
//     工数_見積もり: string;
//     想定時給: string;
//     難易度: string;
//     gpt_summary: string;
// }

interface ProcessedAnalyzedJob {
    hourlyRate: number;
    workHours: number;
    title: string;
    description: string;
    url: string;
    category: string;
    difficulty: string;
    analysis: string;
}

class UnifiedReportGenerator {
    private outputDir: string;

    constructor() {
        this.outputDir = path.join(process.cwd(), 'output');
        if (!fs.existsSync(this.outputDir)) {
            fs.mkdirSync(this.outputDir, { recursive: true });
        }
    }

    // 最新のランサーズファイルを取得


    // 最新のクラウドワークス分析ファイルを取得
    // private getLatestCrowdWorksFiles(): string[] {
    //     const files = fs.readdirSync(this.outputDir)
    //         .filter(file => file.startsWith('analyzed-') && file.endsWith('.json'))
    //         .map(file => path.join(this.outputDir, file));

    //     return files;
    // }

    /**
     * データファイル読み込み
     */
    private loadJobData(): { lancers: any[], crowdworks: any[] } {
        console.log('📚 データ読み込み中...');

        // ランサーズデータ読み込み（最新のファイルを使用）
        const lancersData: any[] = [];

        // 既存のランサーズファイル
        const existingLancersFile = 'output/lancers-details-2025-06-09T17-38-02-401Z.json';
        if (fs.existsSync(existingLancersFile)) {
            const data = JSON.parse(fs.readFileSync(existingLancersFile, 'utf8'));
            lancersData.push(...data);
            console.log(`📁 既存ランサーズデータ読み込み: ${data.length}件`);
        }

        // GPT分析結果読み込み
        const gptAnalysisData: any[] = [];
        const analysisFiles = [
            'output/analysis-ec.json',
            'output/analysis-web_products.json',
            'output/analysis-software_development.json',
            'output/analysis-development.json'  // 新しい分析結果のみ
        ];

        // GPT分析結果のマップを作成
        const gptAnalysisMap = new Map();
        for (const file of analysisFiles) {
            if (fs.existsSync(file)) {
                const data = JSON.parse(fs.readFileSync(file, 'utf8'));
                gptAnalysisData.push(...data);
                data.forEach((analysis: any) => {
                    // jobIdまたはurlをキーとして使用
                    if (analysis.jobId) {
                        gptAnalysisMap.set(analysis.jobId, analysis);
                    }
                    if (analysis.url) {
                        gptAnalysisMap.set(analysis.url, analysis);
                    }
                });
                console.log(`🤖 GPT分析結果読み込み (${file}): ${data.length}件`);
            }
        }

        // ランサーズデータにGPT分析結果を統合
        const processedLancersData = lancersData.map((job: any) => {
            const gptAnalysis = gptAnalysisMap.get(job.jobId) || gptAnalysisMap.get(job.url);
            return {
                ...job,
                想定時給: this.extractHourlyRateFromGptAnalysis(gptAnalysis),
                工数_見積もり: gptAnalysis?.工数_見積もり || '未算出',
                難易度: gptAnalysis?.難易度 || 'unknown',
                簡易設計: gptAnalysis?.簡易設計 || '設計情報なし',
                gpt_summary: gptAnalysis?.gpt_summary || ''
            };
        });

        // CrowdWorksデータ読み込み（新しい詳細データファイルを使用）
        const crowdworksData: any[] = [];
        const detailsFiles = [
            'output/details-ec.json',
            'output/details-web_products.json',
            'output/details-software_development.json',
            'output/details-development.json'
        ];

        for (const file of detailsFiles) {
            if (fs.existsSync(file)) {
                const data = JSON.parse(fs.readFileSync(file, 'utf8'));
                // 有効なデータのみをフィルタリング（詳細説明があり、GPT分析結果があるもの）
                const validData = data.filter((job: any) => {
                    const hasDetailedDescription = job.detailedDescription && job.detailedDescription.trim() !== '';
                    const hasGptAnalysis = gptAnalysisMap.has(job.jobId) || gptAnalysisMap.has(job.url);
                    return hasDetailedDescription && hasGptAnalysis;
                });
                
                // 新しい詳細データにGPT分析結果を統合
                const processedData = validData.map((job: any) => {
                    const gptAnalysis = gptAnalysisMap.get(job.jobId) || gptAnalysisMap.get(job.url);
                    return {
                        ...job,
                        想定時給: this.extractHourlyRateFromGptAnalysis(gptAnalysis),
                        工数_見積もり: gptAnalysis?.工数_見積もり || '未算出',
                        難易度: gptAnalysis?.難易度 || 'unknown',
                        簡易設計: gptAnalysis?.簡易設計 || '設計情報なし',
                        gpt_summary: gptAnalysis?.gpt_summary || ''
                    };
                });
                crowdworksData.push(...processedData);
                console.log(`📁 CrowdWorks詳細データ読み込み (${file}): ${processedData.length}件（有効データのみ）`);
            }
        }

        // 古いテストデータは読み込まない（新しいデータのみ使用）

        console.log(`🤖 GPT分析済み案件: ${gptAnalysisData.length}件`);
        console.log(`📊 総データ: ランサーズ${processedLancersData.length}件, クラウドワークス${crowdworksData.length}件`);
        return { lancers: processedLancersData, crowdworks: crowdworksData };
    }

    /**
     * GPT分析結果のみから時給を取得（推定アルゴリズムは削除）
     */
    private extractHourlyRateFromGptAnalysis(gptAnalysis?: any): number {
        if (!gptAnalysis) {
            console.log(`❌ GPT分析結果なし - 時給情報取得不可`);
            return 0;
        }

        // GPT分析結果から時給を抽出
        if (gptAnalysis.想定時給) {
            const gptRate = this.extractRateFromGptAnalysis(gptAnalysis.想定時給);
            if (gptRate > 0) {
                console.log(`🤖 GPT分析から時給取得: ${gptRate}円/時`);
                return gptRate;
            }
        }

        // GPT分析結果があっても時給が抽出できない場合
        console.log(`❌ GPT分析結果から時給抽出失敗`);
        return 0;
    }

    /**
     * GPT分析結果から時給を抽出
     */
    private extractRateFromGptAnalysis(gptRate: string): number {
        if (!gptRate) return 0;
        
        // 「2500円」「1500円/時」などの形式から数値を抽出
        const rateMatch = gptRate.match(/([0-9,]+)\s*円/);
        if (rateMatch && rateMatch[1]) {
            const rate = parseInt(rateMatch[1].replace(/,/g, ''));
            // 妥当な時給範囲でバリデーション
            if (rate >= 500 && rate <= 50000) {
                return rate;
            }
        }
        
        return 0;
    }









    /**
     * 予算額を数値で抽出
     */
    private extractBudgetAmount(budget: string): number {
        if (!budget) return 0;
        
        // 「～」や「-」で区切られた範囲の場合は上限値を取得
        const rangeMatch = budget.match(/([0-9,]+)\s*円\s*[~～-]\s*([0-9,]+)\s*円/);
        if (rangeMatch && rangeMatch[1] && rangeMatch[2]) {
            const min = parseInt(rangeMatch[1].replace(/,/g, '')) || 0;
            const max = parseInt(rangeMatch[2].replace(/,/g, '')) || 0;
            return Math.max(min, max); // 上限値を返す
        }
        
        // 単一の金額
        const singleMatch = budget.match(/([0-9,]+)\s*円/);
        if (singleMatch && singleMatch[1]) {
            return parseInt(singleMatch[1].replace(/,/g, '')) || 0;
        }
        
        return 0;
    }

    // 分析済みジョブの処理
    // private processAnalyzedJob(job: AnalyzedJob): ProcessedAnalyzedJob {
    //     // 時給の抽出（例："2500円" → 2500）
    //     let hourlyRate = 0;
    //     if (job.想定時給) {
    //         const rateMatch = job.想定時給.match(/(\d+)/);
    //         if (rateMatch && rateMatch[1]) {
    //             hourlyRate = parseInt(rateMatch[1]);
    //         }
    //     }

    //     // 工数の抽出（例："20時間" → 20）
    //     let workHours = 0;
    //     if (job.工数_見積もり) {
    //         const hoursMatch = job.工数_見積もり.match(/(\d+)/);
    //         if (hoursMatch && hoursMatch[1]) {
    //             workHours = parseInt(hoursMatch[1]);
    //         }
    //     }

    //     return {
    //         hourlyRate,
    //         workHours,
    //         title: job.title || '',
    //         description: job.gpt_summary || '',
    //         url: `https://crowdworks.jp/public/jobs/${job.jobId}`,
    //         category: 'プログラミング',
    //         difficulty: job.難易度 || '',
    //         analysis: job.gpt_summary || ''
    //     };
    // }

    /**
     * おすすめスコアを計算
     */
    private calculateRecommendationScore(job: any): number {
        let score = 0;
        
        // 基本スコア（時給）
        const hourlyRate = job.hourlyRate || 0;
        score += hourlyRate;
        
        // 技術スキル重み付け
        const techKeywords = ['React', 'Vue', 'Angular', 'TypeScript', 'Node.js', 'Python', 'AI', 'Machine Learning', 'Bubble', 'Figma'];
        let techScore = 0;
        const description = (job.description || '').toLowerCase();
        techKeywords.forEach(keyword => {
            if (description.includes(keyword.toLowerCase())) {
                techScore += 1000; // 技術スキルボーナス
            }
        });
        score += techScore;
        
        // 継続性ボーナス
        if (description.includes('継続') || description.includes('長期') || description.includes('パートナー')) {
            score += 2000;
        }
        
        // 急募ボーナス
        if (description.includes('急募') || description.includes('即戦力')) {
            score += 1500;
        }
        
        // 経験者優遇ボーナス
        if (description.includes('経験者') || description.includes('エキスパート') || description.includes('スペシャリスト')) {
            score += 1000;
        }
        
        // フルリモートボーナス
        if (description.includes('フルリモート') || description.includes('完全在宅') || description.includes('在宅')) {
            score += 500;
        }
        
        // 高額案件ボーナス（時給10000円以上）
        if (hourlyRate >= 10000) {
            score += 3000;
        }
        
        return score;
    }

    /**
     * 重複除去
     */
    private removeDuplicates(jobs: any[]): any[] {
        const uniqueJobs = new Map<string, any>();
        
        jobs.forEach(job => {
            const key = `${job.title}-${job.platform}-${job.url}`;
            if (!uniqueJobs.has(key)) {
                uniqueJobs.set(key, job);
            }
        });
        
        return Array.from(uniqueJobs.values());
    }

    /**
     * 技術キーワード分析
     */
    private getTechKeywords(jobs: any[]): Array<{keyword: string, count: number}> {
        const techKeywords = ['React', 'Vue', 'Angular', 'TypeScript', 'Node.js', 'Python', 'AI', 'Machine Learning', 'Bubble', 'Figma', 'WordPress', 'Laravel', 'Next.js', 'Flutter', 'Swift', 'Kotlin'];
        const keywordCounts = new Map<string, number>();
        
        techKeywords.forEach(keyword => {
            const count = jobs.filter(job => {
                const description = (job.description || '').toLowerCase();
                return description.includes(keyword.toLowerCase());
            }).length;
            if (count > 0) {
                keywordCounts.set(keyword, count);
            }
        });
        
        return Array.from(keywordCounts.entries())
            .map(([keyword, count]) => ({keyword, count}))
            .sort((a, b) => b.count - a.count);
    }

    /**
     * 高時給案件フィルタリング
     */
    private filterHighPayingJobs(
        lancersJobs: any[],
        crowdWorksJobs: ProcessedAnalyzedJob[],
        minHourlyRate: number
    ): { lancers: Job[], crowdworks: ProcessedAnalyzedJob[] } {

        // ランサーズデータを処理（GPT分析結果を活用）
        const processedLancers: Job[] = lancersJobs
            .map(job => {
                // GPT分析結果から時給を取得
                const gptHourlyRate = job.想定時給 || 0;
                const budgetAmount = this.extractBudgetAmount(job.budget || '');

                console.log(`🔍 ランサーズ案件: ${job.title}`);
                console.log(`🤖 GPT想定時給: ${gptHourlyRate}円/時`);

                return {
                    id: job.jobId || '',
                    title: job.title || '',
                    description: job.detailedDescription || job.gpt_summary || '',
                    url: job.url || '',
                    budget: {
                        amount: budgetAmount,
                        currency: 'JPY',
                        type: 'fixed' as const
                    },
                    hourlyRate: gptHourlyRate,
                    platform: 'lancers' as const,
                    category: job.category || 'unknown',
                    tags: [],
                    postedAt: job.scrapedAt || new Date().toISOString(),
                    scrapedAt: job.scrapedAt || new Date().toISOString()
                };
            })
            .filter(job => job.hourlyRate >= minHourlyRate);

        // クラウドワークスデータもGPT分析結果を活用
        const filteredCrowdWorks = crowdWorksJobs.filter(job => {
            const hourlyRate = (job as any).想定時給 || 0;
            console.log(`🔍 CrowdWorks案件: ${(job as any).title}`);
            console.log(`🤖 GPT想定時給: ${hourlyRate}円/時`);
            return hourlyRate >= minHourlyRate;
        });

        return {
            lancers: processedLancers,
            crowdworks: filteredCrowdWorks
        };
    }

    // 統合レポートの生成
    private generateUnifiedReport(
        highPayingJobs: { lancers: any[], crowdworks: ProcessedAnalyzedJob[] },
        minHourlyRate: number
    ): string {
        const now = new Date();
        const dateStr = now.toLocaleDateString('ja-JP');
        const timeStr = now.toLocaleTimeString('ja-JP');

        const allJobs = [
            ...highPayingJobs.lancers.map(job => ({
                ...job,
                platform: 'ランサーズ',
                hourlyRate: job.hourlyRate || 0
            })),
            ...highPayingJobs.crowdworks.map(job => ({
                ...job,
                platform: 'クラウドワークス',
                hourlyRate: (job as any).想定時給 || 0,
                工数_見積もり: (job as any).工数_見積もり || '未算出',
                簡易設計: (job as any).簡易設計 || '設計情報なし'
            }))
        ];

        // 重複を除去
        const uniqueJobs = this.removeDuplicates(allJobs);

        // おすすめスコアで並び替え
        const sortedJobs = uniqueJobs
            .map(job => ({
                ...job,
                recommendationScore: this.calculateRecommendationScore(job)
            }))
            .sort((a, b) => b.recommendationScore - a.recommendationScore);

        const totalJobs = sortedJobs.length;
        const hourlyRates = sortedJobs.map(job => job.hourlyRate || 0).filter(rate => rate > 0);
        const maxHourlyRate = hourlyRates.length > 0 ? Math.max(...hourlyRates) : 0;
        const minHourlyRateActual = hourlyRates.length > 0 ? Math.min(...hourlyRates) : 0;
        const avgHourlyRate = hourlyRates.length > 0 ? Math.round(hourlyRates.reduce((sum, rate) => sum + rate, 0) / hourlyRates.length) : 0;

        let report = `# 統合フリーランス案件分析レポート（時給${minHourlyRate}円以上）

> **生成日時**: ${dateStr} ${timeStr}  
> **対象**: Webエンジニア向け高時給案件  
> **最低時給**: ${minHourlyRate.toLocaleString()}円以上  
> **おすすめ順**: 時給 + 技術要件 + 継続性 + 急募度などを総合評価

## 📊 統合サマリー

| 項目 | ランサーズ | クラウドワークス | 合計 |
|------|------------|------------------|------|
| 高時給案件数 | ${highPayingJobs.lancers.length}件 | ${highPayingJobs.crowdworks.length}件 | ${totalJobs}件（重複除去後） |
| 最高時給 | ${highPayingJobs.lancers.length > 0 ? Math.max(...highPayingJobs.lancers.map(j => j.hourlyRate || 0)).toLocaleString() : '0'}円 | ${highPayingJobs.crowdworks.length > 0 ? Math.max(...highPayingJobs.crowdworks.map(j => (j as any).想定時給 || 0)).toLocaleString() : '0'}円 | ${maxHourlyRate.toLocaleString()}円 |
| 平均時給 | ${highPayingJobs.lancers.length > 0 ? Math.round(highPayingJobs.lancers.reduce((sum, j) => sum + (j.hourlyRate || 0), 0) / highPayingJobs.lancers.length).toLocaleString() : '0'}円 | ${highPayingJobs.crowdworks.length > 0 ? Math.round(highPayingJobs.crowdworks.reduce((sum, j) => sum + ((j as any).想定時給 || 0), 0) / highPayingJobs.crowdworks.length).toLocaleString() : '0'}円 | ${avgHourlyRate.toLocaleString()}円 |

## 🎯 市場分析

### 💡 **主要な発見**

- **高時給案件の総数**: ${totalJobs}件（重複除去後）
- **最高時給**: ${maxHourlyRate.toLocaleString()}円
- **時給分布**: ${minHourlyRateActual.toLocaleString()}円 〜 ${maxHourlyRate.toLocaleString()}円
- **平均時給**: ${avgHourlyRate.toLocaleString()}円

### 📈 **プラットフォーム比較**

${highPayingJobs.lancers.length > 0 ? '- **ランサーズ**: ' + highPayingJobs.lancers.length + '件の高時給案件（競争が少なく穴場の可能性）' : '- **ランサーズ**: 高時給案件なし'}
${highPayingJobs.crowdworks.length > 0 ? '- **クラウドワークス**: ' + highPayingJobs.crowdworks.length + '件の高時給案件（案件数豊富）' : '- **クラウドワークス**: 高時給案件なし'}

## 💼 おすすめ案件ランキング（総合評価順）

`;

        // おすすめ順でソート表示
        sortedJobs.forEach((job, index) => {
            const platform = job.platform === 'ランサーズ' ? '🟦' : '🟨';
            const urgent = job.isUrgent ? '🔥 **急募** ' : '';



            report += `### ${index + 1}位: ${platform} ${urgent}${job.title || 'タイトル不明'}

**💰 想定時給:** ${(job.hourlyRate || 0).toLocaleString()}円  
**⏱️ 見込み時間:** ${job.工数_見積もり || '未算出'}  
**🏗️ 簡易設計:** ${job.簡易設計 || '設計情報なし'}  
**📊 おすすめスコア:** ${job.recommendationScore.toLocaleString()}pt  
**🏷️ カテゴリ:** ${job.category || 'カテゴリ不明'}  
**📱 プラットフォーム:** ${job.platform}  
**🔗 案件URL:** ${job.url || '#'}

**📝 概要:**  
${job.detailedDescription ? job.detailedDescription.substring(0, 300) + '...' : job.gpt_summary || '詳細情報なし'}

---

`;
        });

        // 技術キーワード分析
        const techKeywords = this.getTechKeywords(sortedJobs);

        report += `
## 🎯 戦略的提案

### 📋 **おすすめアクション**

1. **即座に応募すべき案件**: 上位5件（おすすめスコア${sortedJobs.length > 4 ? sortedJobs[4].recommendationScore.toLocaleString() : '10,000'}pt以上）
2. **ポートフォリオ強化**: ${highPayingJobs.lancers.length > 0 && highPayingJobs.crowdworks.length > 0 ? '両プラットフォームでの実績作り' : '主要プラットフォームでの実績作り'}
3. **スキルアップ領域**: システム開発、API連携、高度なフロントエンド技術

### 💡 **市場戦略**

- **ランサーズ**: ${highPayingJobs.lancers.length > 0 ? '競争が少なく高時給を狙いやすい' : '高時給案件が少ないため要注意'}
- **クラウドワークス**: ${highPayingJobs.crowdworks.length > 0 ? '案件数が豊富で安定収入を期待できる' : '高時給案件獲得に向けた戦略的アプローチが必要'}

### 🔥 **注目技術キーワード**

${techKeywords.map(tech => `- **${tech.keyword}**: ${tech.count}件`).join('\n')}

---

*このレポートは${now.toLocaleString('ja-JP')}に自動生成されました。*
`;

        return report;
    }

    // メイン実行
    async execute(minHourlyRate: number): Promise<void> {
        console.log('🚀 統合レポート生成を開始します...');
        console.log(`💰 最低時給: ${minHourlyRate}円`);

        // データ読み込み
        console.log('\n📚 データ読み込み中...');
        const { lancers, crowdworks } = this.loadJobData();

        if (lancers.length === 0 && crowdworks.length === 0) {
            console.error('❌ データが見つかりません。先にスクレイピングを実行してください。');
            return;
        }

        // 高時給案件の抽出
        console.log('\n🔍 高時給案件を抽出中...');
        const highPayingJobs = this.filterHighPayingJobs(lancers, crowdworks, minHourlyRate);

        console.log(`🔥 高時給案件 (${minHourlyRate}円以上):`);
        console.log(`   ランサーズ: ${highPayingJobs.lancers.length}件`);
        console.log(`   クラウドワークス: ${highPayingJobs.crowdworks.length}件`);

        if (highPayingJobs.lancers.length === 0 && highPayingJobs.crowdworks.length === 0) {
            console.log(`⚠️ 時給${minHourlyRate}円以上の案件が見つかりませんでした。`);
            return;
        }

        // レポート生成
        console.log('\n📄 統合レポートを生成中...');
        const report = this.generateUnifiedReport(highPayingJobs, minHourlyRate);

        // ファイル保存
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
        const filename = `unified-high-paying-jobs-${timestamp}.md`;
        const filepath = path.join(this.outputDir, filename);

        fs.writeFileSync(filepath, report, 'utf8');

        console.log('\n✅ 統合レポート生成完了！');
        console.log(`📁 保存先: ${filepath}`);
        console.log(`📊 総案件数: ${highPayingJobs.lancers.length + highPayingJobs.crowdworks.length}件`);
    }
}

// メイン実行
async function main() {
    try {
        const args = process.argv.slice(2);
        const minHourlyRate = args.length > 0 && args[0] ? parseInt(args[0]) : 2000; // デフォルトを2000円に変更
        
        const generator = new UnifiedReportGenerator();
        await generator.execute(minHourlyRate);
    } catch (error) {
        console.error('❌ レポート生成中にエラーが発生しました:', error);
        process.exit(1);
    }
}

if (require.main === module) {
    main().catch(console.error);
}

export { UnifiedReportGenerator };
</file>

<file path="scripts/extract-high-hourly-jobs.ts">
require('dotenv').config();

import { readFileSync, writeFileSync } from 'fs';

// 型定義
interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    gpt_summary: string;
    category?: string;
}

interface HighHourlyJob extends AnalysisResult {
    hourly_rate_numeric: number;
    link: string;
    original_title?: string;
}

// 時給文字列を数値に変換する関数
function parseHourlyRate(hourlyRateString: string): number {
    if (!hourlyRateString || hourlyRateString.trim() === '' || hourlyRateString === '0円') {
        return 0;
    }

    const match = hourlyRateString.match(/([0-9,]+)/);
    if (match && match[1]) {
        const numericString = match[1].replace(/,/g, '');
        return parseInt(numericString, 10);
    }

    return 0;
}

// 詳細データから元のタイトルを取得する関数
function getOriginalJobData(jobId: string, detailsData: any[]): any {
    return detailsData.find(job => job.jobId === jobId);
}

// メイン処理
function extractHighHourlyJobs(): void {
    console.log('🔄 時給3000円以上の案件抽出を開始...');

    const highHourlyJobs: HighHourlyJob[] = [];
    const minHourlyRate = 3000;

    // 詳細データも読み込む（元のタイトル取得用）
    let ecDetailsData: any[] = [];
    let webDetailsData: any[] = [];

    // EC詳細データの読み込み
    try {
        ecDetailsData = JSON.parse(readFileSync('output/details-ec.json', 'utf8'));
        console.log(`📂 EC詳細データ: ${ecDetailsData.length}件読み込み`);
    } catch (error) {
        console.log(`⚠️ EC詳細データの読み込みに失敗: ${error}`);
    }

    // Web製品詳細データの読み込み
    try {
        webDetailsData = JSON.parse(readFileSync('output/details-web_products.json', 'utf8'));
        console.log(`📂 Web製品詳細データ: ${webDetailsData.length}件読み込み`);
    } catch (error) {
        console.log(`⚠️ Web製品詳細データの読み込みに失敗: ${error}`);
    }

    // AI分析済みデータの読み込み（オプション）
    let ecAnalyzedData: any[] = [];
    let webAnalyzedData: any[] = [];

    try {
        ecAnalyzedData = JSON.parse(readFileSync('output/analyzed-ec.json', 'utf8'));
        console.log(`🧠 EC AI分析データ: ${ecAnalyzedData.length}件読み込み`);
    } catch (error) {
        console.log(`⚠️ ECカテゴリファイルが見つかりません: analyzed-ec.json`);
    }

    try {
        webAnalyzedData = JSON.parse(readFileSync('output/analyzed-web_products.json', 'utf8'));
        console.log(`🧠 Web製品 AI分析データ: ${webAnalyzedData.length}件読み込み`);
    } catch (error) {
        console.log(`⚠️ Web製品カテゴリファイルが見つかりません: analyzed-web_products.json`);
    }

    // ECカテゴリの分析データ読み込み
    try {
        ecAnalyzedData.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            if (hourlyRate >= minHourlyRate) {
                const originalJob = getOriginalJobData(item.jobId, ecDetailsData);
                highHourlyJobs.push({
                    ...item,
                    category: 'EC',
                    hourly_rate_numeric: hourlyRate,
                    link: `https://crowdworks.jp/public/jobs/${item.jobId}`,
                    original_title: originalJob?.title || item.title
                });
            }
        });
        console.log(`✅ ECカテゴリ: ${ecAnalyzedData.length}件中 ${ecAnalyzedData.filter(item => parseHourlyRate(item.想定時給) >= minHourlyRate).length}件が対象`);
    } catch (e) {
        console.log('⚠️ ECカテゴリファイルが見つかりません: analyzed-ec.json');
    }

    // Web製品カテゴリの分析データ読み込み
    try {
        webAnalyzedData.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            if (hourlyRate >= minHourlyRate) {
                const originalJob = getOriginalJobData(item.jobId, webDetailsData);
                highHourlyJobs.push({
                    ...item,
                    category: 'Web製品',
                    hourly_rate_numeric: hourlyRate,
                    link: `https://crowdworks.jp/public/jobs/${item.jobId}`,
                    original_title: originalJob?.title || item.title
                });
            }
        });
        console.log(`✅ Web製品カテゴリ: ${webAnalyzedData.length}件中 ${webAnalyzedData.filter(item => parseHourlyRate(item.想定時給) >= minHourlyRate).length}件が対象`);
    } catch (e) {
        console.log('⚠️ Web製品カテゴリファイルが見つかりません: analyzed-web_products.json');
    }

    if (highHourlyJobs.length === 0) {
        console.error('❌ 対象案件が見つかりませんでした');
        return;
    }

    // 時給順でソート（高額順）
    const sortedJobs = highHourlyJobs.sort((a, b) => b.hourly_rate_numeric - a.hourly_rate_numeric);

    // Markdownファイル生成
    const markdown = generateMarkdown(sortedJobs, minHourlyRate);
    const outputFileName = `output/high-hourly-jobs-3000+.md`;

    writeFileSync(outputFileName, markdown, 'utf8');
    console.log(`💾 Markdownファイルを保存: ${outputFileName}`);
    console.log(`📊 抽出件数: ${sortedJobs.length}件`);
    console.log(`💰 最高時給: ${Math.max(...sortedJobs.map(j => j.hourly_rate_numeric)).toLocaleString()}円`);
}

// Markdown生成関数
function generateMarkdown(jobs: HighHourlyJob[], minRate: number): string {
    const currentDate = new Date().toISOString().split('T')[0];

    let markdown = `# 高時給案件一覧（${minRate}円以上）\n\n`;
    markdown += `> 生成日: ${currentDate}  \n`;
    markdown += `> 対象: 時給${minRate.toLocaleString()}円以上の案件  \n`;
    markdown += `> 総件数: ${jobs.length}件  \n`;
    markdown += `> 注意: 工数見積もりには要件定義、打ち合わせ、修正作業などの前作業も含まれています\n\n`;

    markdown += `## 📊 概要\n\n`;
    markdown += `| 統計項目 | 値 |\n`;
    markdown += `|----------|----|\n`;
    markdown += `| 最高時給 | ${Math.max(...jobs.map(j => j.hourly_rate_numeric)).toLocaleString()}円 |\n`;
    markdown += `| 最低時給 | ${Math.min(...jobs.map(j => j.hourly_rate_numeric)).toLocaleString()}円 |\n`;
    markdown += `| 平均時給 | ${Math.round(jobs.reduce((sum, j) => sum + j.hourly_rate_numeric, 0) / jobs.length).toLocaleString()}円 |\n`;
    markdown += `| EC案件数 | ${jobs.filter(j => j.category === 'EC').length}件 |\n`;
    markdown += `| Web製品案件数 | ${jobs.filter(j => j.category === 'Web製品').length}件 |\n\n`;

    markdown += `## 💼 案件一覧\n\n`;

    jobs.forEach((job, index) => {
        markdown += `### ${index + 1}. [${job.original_title}](${job.link})\n\n`;
        markdown += `**💰 想定時給:** ${job.hourly_rate_numeric.toLocaleString()}円  \n`;
        markdown += `**⏰ 見積工数:** ${job.工数_見積もり}  \n`;
        markdown += `**🏷️ カテゴリ:** ${job.category}  \n`;
        markdown += `**🔗 案件URL:** ${job.link}\n\n`;
        markdown += `**📝 分析概要:**  \n`;
        markdown += `${job.gpt_summary}\n\n`;
        markdown += `---\n\n`;
    });

    markdown += `## 📋 注記\n\n`;
    markdown += `- 時給は「要件定義」「打ち合わせ」「修正作業」「テスト」「納品後サポート」などの付帯作業も含めた現実的な工数見積もりに基づいています\n`;
    markdown += `- 案件の詳細は各リンクをクリックしてクラウドワークスのページでご確認ください\n`;
    markdown += `- 時給計算はGPT-4oによる分析結果であり、実際の作業時間や報酬は異なる場合があります\n`;
    markdown += `- 案件の募集状況は変動するため、リンク先で最新情報をご確認ください\n`;

    return markdown;
}

// 実行
extractHighHourlyJobs();
</file>

<file path="scripts/scrape-lancers.ts">
import { chromium } from 'playwright';
import { writeFileSync } from 'fs';
import { LancersJob, LancersJobDetail } from '../src/services/LancersService';
import * as dotenv from 'dotenv';

// 環境変数を読み込み
dotenv.config();

/**
 * ランサーズ案件スクレイピングメイン処理
 */
async function main(): Promise<void> {
    console.log('🚀 ランサーズ案件のスクレイピングを開始します...');
    console.log('⚠️ 注意: 公開案件のみを対象とします');

    const browser = await chromium.launch({
        headless: false,
        slowMo: 1000,
        args: ['--no-sandbox', '--disable-setuid-sandbox']
    });

    try {
        const page = await browser.newPage();

        // User-Agentを設定
        await page.setExtraHTTPHeaders({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        });

        // const lancersService = new LancersService(page);

        // 取得するカテゴリとそれぞれの最大件数（10件ずつに変更）
        const categories = [
            { name: 'system', url: 'https://www.lancers.jp/work/search/system' },
            { name: 'web', url: 'https://www.lancers.jp/work/search/web' },
            { name: 'app', url: 'https://www.lancers.jp/work/search/app' },
            { name: 'design', url: 'https://www.lancers.jp/work/search/design' },
            { name: 'writing', url: 'https://www.lancers.jp/work/search/writing' },
            { name: 'translation', url: 'https://www.lancers.jp/work/search/translation' }
        ];

        const itemsPerCategory = 5; // 各カテゴリから5件取得（合計30件）
        const detailsLimit = 5; // 詳細取得も5件に制限

        const allJobs: LancersJob[] = [];
        const allDetails: LancersJobDetail[] = [];
        const startTime = Date.now();

        console.log('🔍 各カテゴリから案件を取得します...');

        for (const category of categories) {
            console.log(`\n📁 カテゴリ「${category.name}」の処理を開始（最大${itemsPerCategory}件）`);

            try {
                // カテゴリURLマッピング（新着順パラメータ付き）
                const categoryUrls: { [key: string]: string } = {
                    'system': 'https://www.lancers.jp/work/search/system?open=1&show_description=1&sort=started&work_rank%5B%5D=0&work_rank%5B%5D=2&work_rank%5B%5D=3',
                    'web': 'https://www.lancers.jp/work/search/web?open=1&show_description=1&sort=started&work_rank%5B%5D=0&work_rank%5B%5D=2&work_rank%5B%5D=3',
                    'app': 'https://www.lancers.jp/work/search/system/smartphoneapp?open=1&show_description=1&sort=started&work_rank%5B%5D=0&work_rank%5B%5D=2&work_rank%5B%5D=3',
                    'design': 'https://www.lancers.jp/work/search/design?open=1&show_description=1&sort=started&work_rank%5B%5D=0&work_rank%5B%5D=2&work_rank%5B%5D=3',
                    'writing': 'https://www.lancers.jp/work/search/writing?open=1&show_description=1&sort=started&work_rank%5B%5D=0&work_rank%5B%5D=2&work_rank%5B%5D=3',
                    'translation': 'https://www.lancers.jp/work/search/writing/translation?open=1&show_description=1&sort=started&work_rank%5B%5D=0&work_rank%5B%5D=2&work_rank%5B%5D=3'
                };

                const categoryUrl = categoryUrls[category.name];
                if (!categoryUrl) {
                    console.log(`❌ カテゴリ「${category.name}」のURLが見つかりません`);
                    continue;
                }

                console.log(`🌐 アクセス: ${categoryUrl}`);
                await page.goto(categoryUrl, { waitUntil: 'networkidle', timeout: 30000 });
                await page.waitForTimeout(3000);

                // 新着順が既に選択されているか確認
                const sortSelect = await page.$('select[name="sort"], combobox[aria-label="並び順"]');
                if (sortSelect) {
                    const selectedValue = await sortSelect.evaluate(el => (el as HTMLSelectElement).value);
                    console.log(`📊 現在のソート: ${selectedValue}`);

                    if (selectedValue !== 'started') {
                        await page.selectOption('select[name="sort"]', 'started');
                        console.log('✅ 新着順に変更しました');
                        await page.waitForTimeout(2000);
                    } else {
                        console.log('✅ 既に新着順でソートされています');
                    }
                }

                // 案件一覧を取得
                const jobs = await getJobsFromPage(page, itemsPerCategory, category.name);
                console.log(`📊 ${category.name}カテゴリ: ${jobs.length}件の案件を取得`);

                allJobs.push(...jobs);

                // 詳細情報を取得（最大10件まで）
                const detailsToFetch = jobs.slice(0, detailsLimit);
                for (const job of detailsToFetch) {
                    try {
                        console.log(`🔍 詳細取得: ${job.title}`);
                        const detail = await getJobDetail(page, job.url);
                        if (detail) {
                            allDetails.push(detail);
                        }
                        await page.waitForTimeout(1000); // レート制限
                    } catch (detailError) {
                        console.log(`⚠️ 詳細取得エラー: ${job.title}`);
                    }
                }

            } catch (categoryError) {
                console.error(`❌ カテゴリ「${category.name}」でエラー:`, categoryError);
            }
        }

        // ファイル出力
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const jobsFilename = `output/lancers-jobs-${timestamp}.json`;
        const detailsFilename = `output/lancers-details-${timestamp}.json`;

        writeFileSync(jobsFilename, JSON.stringify(allJobs, null, 2), 'utf8');
        writeFileSync(detailsFilename, JSON.stringify(allDetails, null, 2), 'utf8');

        const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(1);

        console.log('\n🎉 スクレイピング完了！');
        console.log(`📊 合計取得件数: ${allJobs.length}件`);
        console.log(`📝 詳細取得件数: ${allDetails.length}件`);
        console.log(`⏱️ 実行時間: ${elapsedTime}秒`);
        console.log(`💾 保存先: ${jobsFilename}`);
        console.log(`💾 詳細保存先: ${detailsFilename}`);

    } catch (error) {
        console.error('❌ スクレイピング中にエラーが発生:', error);
    } finally {
        await browser.close();
    }
}

/**
 * ページから案件一覧を取得
 */
async function getJobsFromPage(page: any, maxJobs: number, category: string): Promise<LancersJob[]> {
    const jobs: LancersJob[] = [];
    let pageNum = 1;

    while (jobs.length < maxJobs) {
        console.log(`📄 ページ ${pageNum} を処理中...`);

        // 案件一覧要素を取得（更新されたセレクター）
        const jobElements = await page.$$('article[data-testid="job-card"], .job-item, div[data-job-id]');

        if (jobElements.length === 0) {
            // フォールバックセレクター
            const fallbackElements = await page.$$('div:has(> a[href*="/work/detail/"])');
            console.log(`🔍 フォールバック: ${fallbackElements.length}件の要素を発見`);

            if (fallbackElements.length === 0) {
                console.log('❌ 案件要素が見つかりません');
                break;
            }
        }

        const currentPageJobs = jobElements.length > 0 ? jobElements : await page.$$('div:has(> a[href*="/work/detail/"])');

        for (let i = 0; i < currentPageJobs.length && jobs.length < maxJobs; i++) {
            try {
                const job = await extractJobFromElement(currentPageJobs[i], category);
                if (job) {
                    jobs.push(job);
                }
            } catch (jobError) {
                console.log(`⚠️ 案件抽出エラー: ${jobError}`);
            }
        }

        // 次ページがあるかチェック
        const nextButton = await page.$('a:has-text("次へ"), a[aria-label="次のページ"]');
        if (!nextButton || jobs.length >= maxJobs) {
            break;
        }

        await nextButton.click();
        await page.waitForTimeout(3000);
        pageNum++;
    }

    return jobs;
}

/**
 * 案件要素から情報を抽出
 */
async function extractJobFromElement(element: any, category: string): Promise<LancersJob | null> {
    try {
        // タイトルとURL（更新されたセレクター）
        const titleLink = await element.$('a[href*="/work/detail/"]');
        if (!titleLink) return null;

        const title = await titleLink.textContent();
        const url = await titleLink.getAttribute('href');

        if (!title || !url) return null;

        const fullUrl = url.startsWith('http') ? url : `https://www.lancers.jp${url}`;
        const jobId = url.match(/\/work\/detail\/(\d+)/)?.[1] || '';

        // 価格情報
        // const priceElement = await element.$('span:has-text("円"), .price, .budget');
        // const budgetText = priceElement ? await priceElement.textContent() : '';

        // カテゴリ情報
        // const categoryElement = await element.$('a[href*="/work/search/"], .category');
        // const subcategory = categoryElement ? await categoryElement.textContent() : '';

        // 説明文
        const descriptionElement = await element.$('.description, .job-summary, p');
        const description = descriptionElement ? await descriptionElement.textContent() : '';

        // 投稿日
        const dateElement = await element.$('.date, .posted-date, time');
        const postedDate = dateElement ? await dateElement.textContent() : '';

        // NEW フラグ
        // const newElement = await element.$(':has-text("NEW"), .new-badge');
        // const isNew = !!newElement;

        // クライアント情報
        const clientElement = await element.$('a[href*="/client/"], .client-name');
        const client = clientElement ? await clientElement.textContent() : '';

        const job: LancersJob = {
            id: jobId,
            title: title.trim(),
            description: description?.trim() || '',
            url: fullUrl,
            budget: {
                type: 'unknown' as const,
                amount: 0,
                currency: 'JPY'
            },
            category: category,
            tags: [],
            client: {
                name: client?.trim() || '',
                rating: 0,
                reviewCount: 0
            },
            postedAt: postedDate?.trim() || '',
            applicants: 0,
            scrapedAt: new Date().toISOString()
        };

        return job;

    } catch (error) {
        console.log(`⚠️ 案件抽出エラー:`, error);
        return null;
    }
}

/**
 * 案件詳細情報を取得（修正されたスクレイピングロジック使用）
 */
async function getJobDetail(page: any, jobUrl: string): Promise<LancersJobDetail | null> {
    try {
        await page.goto(jobUrl, { waitUntil: 'networkidle', timeout: 30000 });
        await page.waitForTimeout(2000);

        const jobId = jobUrl.match(/\/work\/detail\/(\d+)/)?.[1] || '';

        // ページが削除されているかチェック
        const errorCheck = await page.evaluate(() => {
            const banner = document.querySelector('banner h1[level="1"]');
            if (banner) {
                const text = banner.textContent || '';
                if (text.includes('閲覧制限') || text.includes('削除')) {
                    return { error: true, message: text };
                }
            }
            return { error: false };
        });

        if (errorCheck.error) {
            console.log(`⚠️ ページアクセスエラー: ${jobId}`);
            return null;
        }

        // 修正されたスクレイピングロジックを使用して詳細情報を抽出
        const detailInfo = await page.evaluate(() => {
            // タイトルの取得（テストで成功した手法を使用）
            const title = (() => {
                const h1 = document.querySelector('h1');
                if (!h1) return '';

                // "【急募】オンライン子供向けプログラミングレッスン講師を募集！の仕事 [IT・通信・インターネット]"
                // から "【急募】オンライン子供向けプログラミングレッスン講師を募集！" を抽出
                const fullText = h1.textContent || '';
                const match = fullText.match(/^(.+?)の仕事/);
                return match ? match[1]!.trim() : fullText.replace(/\s*\[.*?\]\s*$/, '').trim();
            })();

            // 予算の取得（定義リストからの抽出）
            const budget = (() => {
                const terms = Array.from(document.querySelectorAll('dt'));
                for (const term of terms) {
                    if (term.textContent?.includes('提示した予算') || term.textContent?.includes('予算')) {
                        const dd = term.nextElementSibling;
                        if (dd && dd.tagName === 'DD') {
                            return dd.textContent?.trim() || '';
                        }
                    }
                }
                return '';
            })();

            // 詳細説明の取得（定義リストからの抽出）
            const detailedDescription = (() => {
                const terms = Array.from(document.querySelectorAll('dt'));
                for (const term of terms) {
                    if (term.textContent?.includes('依頼概要')) {
                        const dd = term.nextElementSibling;
                        if (dd && dd.tagName === 'DD') {
                            const text = dd.textContent?.trim() || '';
                            // 最初の500文字に制限（詳細版なので少し長めに）
                            return text.length > 500 ? text.substring(0, 500) + '...' : text;
                        }
                    }
                }
                return '';
            })();

            return { title, budget, detailedDescription };
        });

        // 詳細情報を構築
        const detail: LancersJobDetail = {
            jobId: jobId,
            title: detailInfo.title,
            category: '',
            url: jobUrl,
            paymentType: '',
            budget: detailInfo.budget,
            deliveryDate: '',
            postDate: '',
            applicationDeadline: '',
            applicantCount: 0,
            contractCount: 0,
            recruitmentCount: 0,
            favoriteCount: 0,
            detailedDescription: detailInfo.detailedDescription,
            client: {
                name: '',
                url: '',
                overallRating: '',
                orderHistory: '',
                completionRate: '',
                identityVerified: false,
                description: ''
            },
            recentApplicants: [],
            scrapedAt: new Date().toISOString()
        };

        return detail;

    } catch (error) {
        console.log(`⚠️ 詳細取得エラー:`, error);
        return null;
    }
}

// スクリプト実行
if (require.main === module) {
    main().catch(error => {
        console.error('💥 スクリプト実行エラー:', error);
        process.exit(1);
    });
}

export default main;
</file>

<file path="src/index.ts">
/**
 * CrowdWorks Search System - Main Entry Point
 * Docker環境での開発用エントリーポイント
 */

import { ExecutionLog } from '@/types';

// 環境変数の検証
function validateEnvironment(): void {
  const required = ['NODE_ENV', 'AWS_REGION'];
  const missing = required.filter(key => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
}

// メイン実行関数
async function main(): Promise<void> {
  try {
    validateEnvironment();

    const log: ExecutionLog = {
      executionId: Date.now().toString(),
      timestamp: new Date().toISOString(),
      status: 'success',
      duration: 0,
      jobsScraped: 0,
      newJobs: 0,
      aiEvaluated: 0,
      highScoreJobs: 0,
      costEstimate: 0,
    };

    console.log('🚀 CrowdWorks Search System - Development Mode');
    console.log(`Environment: ${process.env['NODE_ENV']}`);
    console.log(`AWS Region: ${process.env['AWS_REGION']}`);
    console.log(`Execution ID: ${log.executionId}`);

    // TODO: 実際の処理を実装
    console.log('✅ Development setup completed');
  } catch (error) {
    console.error('❌ Failed to start application:', error);
    process.exit(1);
  }
}

// 開発環境でのみ実行
if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export { main };
</file>

<file path="src/infrastructure/crowdworks-searcher-stack.ts">
import * as cdk from 'aws-cdk-lib';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as events from 'aws-cdk-lib/aws-events';
import * as targets from 'aws-cdk-lib/aws-events-targets';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as logs from 'aws-cdk-lib/aws-logs';
import { Construct } from 'constructs';

export interface CrowdWorksSearcherStackProps extends cdk.StackProps {
  readonly stage?: string;
  readonly useContainerImage?: boolean; // Container Image使用フラグ
}

export class CrowdWorksSearcherStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: CrowdWorksSearcherStackProps) {
    super(scope, id, props);

    const stage = props?.stage || this.node.tryGetContext('stage') || 'dev';
    const isProd = stage === 'production';
    const useContainerImage = props?.useContainerImage ?? true; // デフォルトでContainer使用

    // リソース名のプレフィックス
    const resourcePrefix = `crowdworks-searcher-${stage}`;

    // S3バケット（データ保存用）
    const dataBucket = new s3.Bucket(this, 'CrowdWorksDataBucket', {
      bucketName: `${resourcePrefix}-data-${this.account}`,
      encryption: s3.BucketEncryption.S3_MANAGED,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
      versioned: isProd, // 本番環境のみバージョニング有効
      lifecycleRules: [
        {
          id: 'DeleteOldData',
          enabled: true,
          expiration: isProd ? cdk.Duration.days(30) : cdk.Duration.days(7),
          // 本番環境では古いバージョンも管理
          ...(isProd && {
            noncurrentVersionExpiration: cdk.Duration.days(7),
          }),
        },
      ],
      removalPolicy: isProd ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: !isProd, // 本番環境では手動削除が必要
    });

    // CloudWatch Logs グループ
    const logGroup = new logs.LogGroup(this, 'LambdaLogGroup', {
      logGroupName: `/aws/lambda/${resourcePrefix}-main`,
      retention: isProd ? logs.RetentionDays.ONE_MONTH : logs.RetentionDays.ONE_WEEK,
      removalPolicy: isProd ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY,
    });

    // Lambda実行ロール（Container Image用権限追加）
    const lambdaRole = new iam.Role(this, 'LambdaExecutionRole', {
      roleName: `${resourcePrefix}-lambda-role`,
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'),
      ],
      inlinePolicies: {
        S3Access: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: ['s3:GetObject', 's3:PutObject', 's3:ListBucket', 's3:DeleteObject'],
              resources: [dataBucket.bucketArn, `${dataBucket.bucketArn}/*`],
            }),
          ],
        }),
        LogsAccess: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: ['logs:CreateLogStream', 'logs:PutLogEvents'],
              resources: [logGroup.logGroupArn],
            }),
          ],
        }),
        // Parameter Store (シークレット管理用)
        ParameterStoreAccess: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: ['ssm:GetParameter', 'ssm:GetParameters'],
              resources: [`arn:aws:ssm:${this.region}:${this.account}:parameter/crowdworks-search/*`],
            }),
          ],
        }),
      },
    });

    // Lambda関数（Container Image対応）
    const mainFunction = useContainerImage
      ? new lambda.DockerImageFunction(this, 'CrowdWorksMainFunction', {
        functionName: `${resourcePrefix}-main`,
        code: lambda.DockerImageCode.fromImageAsset('./', {
          // Lambda Container用のDockerfileを指定
          file: 'Dockerfile.lambda',
          // ビルド引数でステージを渡す
          buildArgs: {
            STAGE: stage,
            NODE_ENV: isProd ? 'production' : 'development',
          },
        }),
        timeout: cdk.Duration.minutes(15), // Playwright用に15分
        memorySize: isProd ? 3008 : 2048,  // Playwright用メモリ
        role: lambdaRole,
        logGroup: logGroup,
        architecture: lambda.Architecture.X86_64, // Playwrightはx86_64のみサポート
        environment: {
          NODE_ENV: stage,
          STAGE: stage,
          DATA_BUCKET_NAME: dataBucket.bucketName,
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1',
          // Playwright環境変数
          PLAYWRIGHT_BROWSERS_PATH: '/usr/bin',
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: '1',
          LOG_LEVEL: isProd ? 'info' : 'debug',
        },
        // 本番環境では予約済み同時実行数を設定
        ...(isProd && {
          reservedConcurrentExecutions: 5,
        }),
      })
      : new lambda.Function(this, 'CrowdWorksMainFunction', {
        functionName: `${resourcePrefix}-main`,
        runtime: lambda.Runtime.NODEJS_18_X,
        handler: 'lambda/handler.lambdaHandler',
        code: lambda.Code.fromAsset('./dist'),
        timeout: cdk.Duration.minutes(isProd ? 15 : 10),
        memorySize: isProd ? 1536 : 1024,
        role: lambdaRole,
        logGroup: logGroup,
        environment: {
          NODE_ENV: stage,
          STAGE: stage,
          DATA_BUCKET_NAME: dataBucket.bucketName,
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1',
        },
        // 本番環境では予約済み同時実行数を設定
        ...(isProd && {
          reservedConcurrentExecutions: 5,
        }),
      });

    // EventBridge（スケジューラー）
    const scheduleRule = new events.Rule(this, 'ScheduleRule', {
      ruleName: `${resourcePrefix}-schedule`,
      // 本番環境では15分間隔、その他は30分間隔
      schedule: events.Schedule.rate(isProd ? cdk.Duration.minutes(15) : cdk.Duration.minutes(30)),
      description: `CrowdWorks案件検索の定期実行 (${stage}環境)`,
      enabled: stage !== 'test', // テスト環境では無効
    });

    scheduleRule.addTarget(new targets.LambdaFunction(mainFunction));

    // タグ付け
    cdk.Tags.of(this).add('Project', 'CrowdWorksSearcher');
    cdk.Tags.of(this).add('Stage', stage);
    cdk.Tags.of(this).add('Environment', isProd ? 'production' : 'development');

    // 出力
    new cdk.CfnOutput(this, 'DataBucketName', {
      value: dataBucket.bucketName,
      description: 'S3データバケット名',
      exportName: `${resourcePrefix}-data-bucket-name`,
    });

    new cdk.CfnOutput(this, 'LambdaFunctionName', {
      value: mainFunction.functionName,
      description: 'Lambda関数名',
      exportName: `${resourcePrefix}-lambda-function-name`,
    });

    new cdk.CfnOutput(this, 'LambdaFunctionArn', {
      value: mainFunction.functionArn,
      description: 'Lambda関数ARN',
      exportName: `${resourcePrefix}-lambda-function-arn`,
    });

    new cdk.CfnOutput(this, 'Stage', {
      value: stage,
      description: 'デプロイメントステージ',
      exportName: `${resourcePrefix}-stage`,
    });

    // 出力（Container Image情報追加）
    new cdk.CfnOutput(this, 'DeploymentMethod', {
      value: useContainerImage ? 'Container Image' : 'ZIP Package',
      description: 'Lambda関数のデプロイ方式',
      exportName: `${resourcePrefix}-deployment-method`,
    });
  }
}
</file>

<file path="src/services/index.ts">
// Services module exports
// TODO: 実際のサービスクラスを実装後、ここからエクスポート

import {
    UpworkJobData,
    UpworkCredentials,
    UpworkLoginResult,
    IntegratedJobSearchResult,
    IntegratedJobReport,
    IntegratedSearchConfig,
    JobData
} from '../types/index';

/**
 * Upwork API サービスクラス
 */
class UpworkService {
    private credentials: UpworkCredentials;
    private isAuthenticated = false;
    private accessToken?: string;

    constructor(credentials: UpworkCredentials) {
        this.credentials = credentials;
    }

    /**
     * OAuth認証を実行
     */
    async authenticate(): Promise<UpworkLoginResult> {
        const startTime = Date.now();

        try {
            // 簡易実装: 認証情報の検証
            if (!this.credentials.consumerKey || !this.credentials.consumerSecret) {
                return {
                    success: false,
                    isAuthenticated: false,
                    error: 'Consumer key and secret are required',
                    executionTime: Date.now() - startTime
                };
            }

            // TODO: 実際のOAuth認証フローの実装
            // 現在は基本的な認証情報チェックのみ
            this.isAuthenticated = true;
            this.accessToken = this.credentials.accessToken || 'mock-token';

            return {
                success: true,
                isAuthenticated: true,
                accessToken: this.accessToken,
                executionTime: Date.now() - startTime
            };

        } catch (error) {
            return {
                success: false,
                isAuthenticated: false,
                error: error instanceof Error ? error.message : 'Authentication failed',
                executionTime: Date.now() - startTime
            };
        }
    }

    /**
     * 案件を検索
     */
    async searchJobs(params: {
        query?: string;
        category?: string;
        minBudget?: number;
        maxBudget?: number;
        jobType?: 'hourly' | 'fixed-price';
        experienceLevel?: 'entry' | 'intermediate' | 'expert';
        limit?: number;
    }): Promise<UpworkJobData[]> {
        if (!this.isAuthenticated) {
            throw new Error('Not authenticated. Call authenticate() first.');
        }

        // TODO: 実際のUpwork API呼び出し実装
        // 現在はモックデータを返す
        const mockJobs: UpworkJobData[] = [
            {
                id: 'upwork-job-1',
                title: 'Full Stack Web Developer for E-commerce Platform',
                description: 'We need an experienced full stack developer to build a modern e-commerce platform using React and Node.js...',
                url: 'https://www.upwork.com/jobs/~01234567890123456789',
                budget: {
                    type: 'hourly',
                    min: 30,
                    max: 60
                },
                duration: 'More than 6 months',
                experienceLevel: 'expert',
                jobType: 'hourly',
                category: {
                    name: 'Web Development',
                    subcategory: 'Full Stack Development'
                },
                client: {
                    country: 'United States',
                    memberSince: '2020-01-15',
                    totalSpent: 50000,
                    hireRate: 85,
                    totalJobs: 25,
                    avgHourlyPaid: 45,
                    paymentVerified: true
                },
                skills: ['React', 'Node.js', 'MongoDB', 'AWS', 'TypeScript'],
                proposals: 5,
                postedTime: '2024-01-15T10:30:00Z',
                scrapedAt: new Date()
            },
            {
                id: 'upwork-job-2',
                title: 'Mobile App Development - React Native',
                description: 'Looking for a React Native developer to create a cross-platform mobile application...',
                url: 'https://www.upwork.com/jobs/~01234567890123456790',
                budget: {
                    type: 'fixed',
                    amount: 8000
                },
                duration: '3 to 6 months',
                experienceLevel: 'intermediate',
                jobType: 'fixed-price',
                category: {
                    name: 'Mobile Development',
                    subcategory: 'React Native'
                },
                client: {
                    country: 'Canada',
                    memberSince: '2019-05-20',
                    totalSpent: 25000,
                    hireRate: 92,
                    totalJobs: 12,
                    paymentVerified: true
                },
                skills: ['React Native', 'JavaScript', 'iOS', 'Android', 'Redux'],
                proposals: 12,
                postedTime: '2024-01-14T14:20:00Z',
                scrapedAt: new Date()
            }
        ];

        // フィルタリング適用
        let filteredJobs = mockJobs;

        if (params.query) {
            const query = params.query.toLowerCase();
            filteredJobs = filteredJobs.filter(job =>
                job.title.toLowerCase().includes(query) ||
                job.description.toLowerCase().includes(query)
            );
        }

        if (params.jobType) {
            filteredJobs = filteredJobs.filter(job => job.jobType === params.jobType);
        }

        if (params.experienceLevel) {
            filteredJobs = filteredJobs.filter(job => job.experienceLevel === params.experienceLevel);
        }

        if (params.limit) {
            filteredJobs = filteredJobs.slice(0, params.limit);
        }

        return filteredJobs;
    }

    /**
     * 案件詳細を取得
     */
    async getJobDetails(jobId: string): Promise<UpworkJobData | null> {
        if (!this.isAuthenticated) {
            throw new Error('Not authenticated. Call authenticate() first.');
        }

        // TODO: 実際のAPI実装
        // 現在はsearchJobsで取得したデータから検索
        const jobs = await this.searchJobs({ limit: 100 });
        return jobs.find(job => job.id === jobId) || null;
    }
}

/**
 * 通貨変換サービス
 */
class CurrencyService {
    private static readonly DEFAULT_USD_TO_JPY = 150; // デフォルト換算レート

    /**
     * USD から JPY への変換
     */
    static convertUSDToJPY(usdAmount: number, exchangeRate?: number): number {
        const rate = exchangeRate || this.DEFAULT_USD_TO_JPY;
        return Math.round(usdAmount * rate);
    }

    /**
     * JPY から USD への変換
     */
    static convertJPYToUSD(jpyAmount: number, exchangeRate?: number): number {
        const rate = exchangeRate || this.DEFAULT_USD_TO_JPY;
        return Math.round((jpyAmount / rate) * 100) / 100; // 小数点2桁まで
    }

    /**
     * Upwork案件の時給をJPY換算
     */
    static calculateUpworkHourlyRateJPY(upworkJob: UpworkJobData, exchangeRate?: number): number | null {
        if (upworkJob.budget.type === 'hourly') {
            if (upworkJob.budget.min && upworkJob.budget.max) {
                const avgUSD = (upworkJob.budget.min + upworkJob.budget.max) / 2;
                return this.convertUSDToJPY(avgUSD, exchangeRate);
            } else if (upworkJob.budget.min) {
                return this.convertUSDToJPY(upworkJob.budget.min, exchangeRate);
            }
        }
        return null;
    }
}

/**
 * 統合ジョブサーチサービス
 */
class IntegratedJobSearchService {
    private crowdworksService?: any; // TODO: CrowdWorksServiceの型定義後に更新
    private upworkService: UpworkService;
    private config: IntegratedSearchConfig;

    constructor(
        upworkCredentials: UpworkCredentials,
        config: IntegratedSearchConfig,
        crowdworksService?: any
    ) {
        this.upworkService = new UpworkService(upworkCredentials);
        this.config = config;
        this.crowdworksService = crowdworksService;
    }

    /**
     * 統合案件検索を実行
     */
    async searchJobs(params: {
        categories?: string[];
        minHourlyRateJPY?: number;
        maxJobsPerSource?: number;
        keywords?: string[];
    }): Promise<IntegratedJobSearchResult> {
        const startTime = Date.now();

        const result: IntegratedJobSearchResult = {
            crowdworks: {
                jobs: [],
                total: 0,
                success: false,
                executionTime: 0
            },
            upwork: {
                jobs: [],
                total: 0,
                success: false,
                executionTime: 0
            },
            summary: {
                totalJobs: 0,
                highHourlyJobs: 0,
                averageHourlyRate: 0,
                executionTime: 0,
                timestamp: new Date()
            }
        };

        // Upwork検索実行
        if (this.config.enabled.upwork) {
            const upworkStartTime = Date.now();
            try {
                await this.upworkService.authenticate();

                const searchParams: Parameters<typeof this.upworkService.searchJobs>[0] = {
                    limit: params.maxJobsPerSource || this.config.limits.maxJobsPerSource
                };

                if (params.keywords && params.keywords.length > 0) {
                    searchParams.query = params.keywords.join(' ');
                }

                const upworkJobs = await this.upworkService.searchJobs(searchParams);

                result.upwork = {
                    jobs: upworkJobs,
                    total: upworkJobs.length,
                    success: true,
                    executionTime: Date.now() - upworkStartTime
                };

            } catch (error) {
                result.upwork = {
                    jobs: [],
                    total: 0,
                    success: false,
                    error: error instanceof Error ? error.message : 'Upwork search failed',
                    executionTime: Date.now() - upworkStartTime
                };
            }
        }

        // CrowdWorks検索実行（将来実装）
        if (this.config.enabled.crowdworks && this.crowdworksService) {
            const crowdworksStartTime = Date.now();
            try {
                // TODO: CrowdWorksServiceとの統合
                result.crowdworks = {
                    jobs: [],
                    total: 0,
                    success: true,
                    executionTime: Date.now() - crowdworksStartTime
                };
            } catch (error) {
                result.crowdworks = {
                    jobs: [],
                    total: 0,
                    success: false,
                    error: error instanceof Error ? error.message : 'CrowdWorks search failed',
                    executionTime: Date.now() - crowdworksStartTime
                };
            }
        }

        // サマリー計算
        const allUpworkJobs = result.upwork.jobs;
        const minHourlyRate = params.minHourlyRateJPY || this.config.filtering.minHourlyRateJPY;

        let highHourlyCount = 0;
        let totalHourlyRates: number[] = [];

        // Upwork案件の高時給判定
        allUpworkJobs.forEach(job => {
            const hourlyRateJPY = CurrencyService.calculateUpworkHourlyRateJPY(
                job,
                this.config.currency.exchangeRateUSDToJPY
            );

            if (hourlyRateJPY) {
                totalHourlyRates.push(hourlyRateJPY);
                if (hourlyRateJPY >= minHourlyRate) {
                    highHourlyCount++;
                }
            }
        });

        result.summary = {
            totalJobs: result.crowdworks.total + result.upwork.total,
            highHourlyJobs: highHourlyCount,
            averageHourlyRate: totalHourlyRates.length > 0
                ? Math.round(totalHourlyRates.reduce((a, b) => a + b, 0) / totalHourlyRates.length)
                : 0,
            executionTime: Date.now() - startTime,
            timestamp: new Date()
        };

        return result;
    }

    /**
     * 高時給案件のフィルタリング
     */
    filterHighValueJobs(
        result: IntegratedJobSearchResult,
        minHourlyRateJPY: number
    ): { crowdworks: JobData[]; upwork: UpworkJobData[] } {

        const highValueUpworkJobs = result.upwork.jobs.filter(job => {
            const hourlyRateJPY = CurrencyService.calculateUpworkHourlyRateJPY(
                job,
                this.config.currency.exchangeRateUSDToJPY
            );
            return hourlyRateJPY && hourlyRateJPY >= minHourlyRateJPY;
        });

        // TODO: CrowdWorks案件のフィルタリング実装

        return {
            crowdworks: [], // TODO: 実装後に更新
            upwork: highValueUpworkJobs
        };
    }

    /**
     * 統合レポート生成
     */
    async generateReport(params: {
        minHourlyRate: number;
        categories: string[];
        maxJobsPerSource: number;
    }): Promise<IntegratedJobReport> {

        const searchResult = await this.searchJobs({
            categories: params.categories,
            minHourlyRateJPY: params.minHourlyRate,
            maxJobsPerSource: params.maxJobsPerSource
        });

        const highValueJobs = this.filterHighValueJobs(searchResult, params.minHourlyRate);

        return {
            id: `report-${Date.now()}`,
            generatedAt: new Date(),
            criteria: {
                minHourlyRate: params.minHourlyRate,
                categories: params.categories,
                maxJobsPerSource: params.maxJobsPerSource
            },
            results: searchResult,
            highValueJobs,
            analysis: {
                marketTrends: this.generateMarketAnalysis(searchResult),
                recommendations: this.generateRecommendations(highValueJobs),
                alerts: this.generateAlerts(searchResult)
            }
        };
    }

    private generateMarketAnalysis(result: IntegratedJobSearchResult): string {
        const { summary } = result;

        if (summary.totalJobs === 0) {
            return '案件データが取得できませんでした。';
        }

        const highValueRatio = (summary.highHourlyJobs / summary.totalJobs * 100).toFixed(1);

        return `総案件数: ${summary.totalJobs}件、高時給案件率: ${highValueRatio}%、平均時給: ${summary.averageHourlyRate.toLocaleString()}円`;
    }

    private generateRecommendations(highValueJobs: { crowdworks: JobData[]; upwork: UpworkJobData[] }): string[] {
        const recommendations: string[] = [];

        if (highValueJobs.upwork.length > 0) {
            recommendations.push(`Upworkで${highValueJobs.upwork.length}件の高時給案件を発見`);

            // スキル分析
            const skillCounts: { [skill: string]: number } = {};
            highValueJobs.upwork.forEach(job => {
                job.skills.forEach(skill => {
                    skillCounts[skill] = (skillCounts[skill] || 0) + 1;
                });
            });

            const topSkills = Object.entries(skillCounts)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 3)
                .map(([skill]) => skill);

            if (topSkills.length > 0) {
                recommendations.push(`需要の高いスキル: ${topSkills.join(', ')}`);
            }
        }

        if (recommendations.length === 0) {
            recommendations.push('現在、条件に合う高時給案件が見つかりませんでした。');
        }

        return recommendations;
    }

    private generateAlerts(result: IntegratedJobSearchResult): string[] {
        const alerts: string[] = [];

        if (!result.upwork.success) {
            alerts.push(`Upwork検索でエラーが発生: ${result.upwork.error || '不明なエラー'}`);
        }

        if (!result.crowdworks.success) {
            alerts.push(`CrowdWorks検索でエラーが発生: ${result.crowdworks.error || '不明なエラー'}`);
        }

        if (result.summary.totalJobs === 0) {
            alerts.push('案件が見つかりませんでした。検索条件を確認してください。');
        }

        return alerts;
    }
}

// Services module exports
export { UpworkService, CurrencyService, IntegratedJobSearchService };
export { AppliedJobsService } from './AppliedJobsService';
export { LancersService } from './LancersService';
</file>

<file path="src/services/LancersService.ts">
import { Page } from 'playwright';

export interface LancersJob {
    title: string;
    url: string;
    category: string;
    budget: string;
    description: string;
    applicantCount: string;
    clientName: string;
    contractCount: string;
    postedDate: string;
}

export interface LancersJobDetail extends LancersJob {
    detailedDescription: string;
    paymentType: string;
    deliveryDate: string;
    applicationDeadline: string;
    client: {
        name: string;
        overallRating: string;
        orderHistory: string;
        completionRate: string;
    };
}

export interface LancersScrapingResult {
    jobs: LancersJob[];
    jobDetails: LancersJobDetail[];
}

/**
 * ランサーズ案件取得サービス
 */
export class LancersService {
    private page: Page;
    private _isLoggedIn: boolean = false;

    constructor(page: Page) {
        this.page = page;
    }

    get isLoggedIn(): boolean {
        return this._isLoggedIn;
    }

    /**
     * ランサーズにログイン
     */
    async login(email: string, password: string): Promise<boolean> {
        try {
            console.log('🔐 ランサーズにログイン中...');
            
            // ログインページに移動
            await this.page.goto('https://www.lancers.jp/user/login', { 
                waitUntil: 'networkidle', 
                timeout: 30000 
            });

            // メールアドレス入力
            const emailSelector = 'input[name="login_name"], input[type="email"], #loginUserName';
            await this.page.waitForSelector(emailSelector, { timeout: 10000 });
            await this.page.fill(emailSelector, email);

            // パスワード入力
            const passwordSelector = 'input[name="password"], input[type="password"], #loginPassword';
            await this.page.fill(passwordSelector, password);

            // ログインボタンをクリック
            const loginButtonSelector = 'button[type="submit"], input[type="submit"], .login-button';
            await this.page.click(loginButtonSelector);

            // ログイン完了を待機
            await this.page.waitForURL(url => !url.toString().includes('/user/login'), { timeout: 15000 });
            
            this._isLoggedIn = true;
            console.log('✅ ランサーズログイン成功');
            return true;
            
        } catch (error) {
            console.error('❌ ランサーズログインエラー:', error);
            this._isLoggedIn = false;
            return false;
        }
    }

    /**
     * 案件リストを取得
     */
    async scrapeJobs(category: string, maxJobs: number): Promise<LancersJob[]> {
        try {
            console.log(`🔍 ランサーズ「${category}」カテゴリで案件取得中...`);
            
            // カテゴリURLの構築
            const categoryUrls: { [key: string]: string } = {
                'system': 'https://www.lancers.jp/work/search/system?open=1',
                'web': 'https://www.lancers.jp/work/search/web?open=1', 
                'app': 'https://www.lancers.jp/work/search/system/mobile?open=1',
                'design': 'https://www.lancers.jp/work/search/design?open=1'
            };
            
            const url = categoryUrls[category] || categoryUrls['system'];
            if (!url) {
                throw new Error(`未対応のカテゴリ: ${category}`);
            }
            
            await this.page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
            
            // 案件リストを取得
            const jobs = await this.page.evaluate(({ maxJobs, category }) => {
                const jobs: any[] = [];
                
                // 案件詳細リンクを持つ要素を取得
                const jobLinks = document.querySelectorAll('a[href*="/work/detail/"]');
                console.log(`案件リンク数: ${jobLinks.length}`);
                
                let count = 0;
                jobLinks.forEach((link: Element, index: number) => {
                    if (count >= maxJobs) return;
                    
                    try {
                        const href = link.getAttribute('href');
                        if (!href || !href.includes('/work/detail/')) return;
                        
                        // タイトルを取得
                        let title = link.textContent?.trim() || '';
                        
                        // NEW, 初回, 2回目などのラベルを除去
                        title = title.replace(/^(NEW|初回|\d+回目)\s*/, '').trim();
                        
                        if (!title || title.length < 5) return;
                        
                        // 完全なURLを構築
                        const fullUrl = href.startsWith('http') ? href : `https://www.lancers.jp${href}`;
                        
                        // 親要素から価格情報を取得
                        let budget = '';
                        let parentElement = link.parentElement;
                        while (parentElement && !budget) {
                            const text = parentElement.textContent || '';
                            const priceMatch = text.match(/([\d,]+)\s*円/);
                            if (priceMatch) {
                                budget = priceMatch[0];
                                break;
                            }
                            parentElement = parentElement.parentElement;
                            if (!parentElement || parentElement === document.body) break;
                        }
                        
                        // 説明文を取得
                        let description = '';
                        parentElement = link.parentElement;
                        while (parentElement && !description) {
                            const textNodes = Array.from(parentElement.childNodes)
                                .filter(node => node.nodeType === Node.TEXT_NODE)
                                .map(node => node.textContent?.trim())
                                .filter(text => text && text.length > 30);
                            
                            if (textNodes.length > 0 && textNodes[0]) {
                                const firstText = textNodes[0];
                                description = firstText.length > 200 
                                    ? firstText.substring(0, 200) + '...' 
                                    : firstText;
                                break;
                            }
                            parentElement = parentElement.parentElement;
                            if (!parentElement || parentElement === document.body) break;
                        }
                        
                        const job = {
                            title: title,
                            url: fullUrl,
                            category: category,
                            budget: budget,
                            description: description,
                            applicantCount: '0',
                            clientName: '',
                            contractCount: '0',
                            postedDate: ''
                        };
                        
                        console.log(`案件${count + 1}: ${title}`);
                        jobs.push(job);
                        count++;
                        
                    } catch (error) {
                        console.log(`案件解析エラー (${index}):`, error);
                    }
                });
                
                console.log(`最終的に取得された案件数: ${jobs.length}`);
                return jobs;
                
            }, { maxJobs, category });
            
            console.log(`✅ ランサーズから${jobs.length}件の案件を取得しました`);
            return jobs;
            
        } catch (error) {
            console.error('案件取得エラー:', error);
            throw error;
        }
    }

    /**
     * 案件詳細を取得
     */
    async scrapeJobDetail(url: string): Promise<LancersJobDetail | null> {
        try {
            console.log(`📋 詳細取得中: ${url}`);
            
            await this.page.goto(url, { waitUntil: 'networkidle', timeout: 30000 });
            
            const detail = await this.page.evaluate(() => {
                const getTextContent = (selector: string): string => {
                    const element = document.querySelector(selector);
                    return element?.textContent?.trim() || '';
                };
                
                // タイトル取得
                const title = getTextContent('h1') || document.title;
                
                // 詳細説明取得
                const detailedDescription = getTextContent('.work-detail-description, .description, .content') ||
                                          document.body.textContent?.substring(0, 1000) || '';
                
                return {
                    title: title,
                    url: window.location.href,
                    category: '',
                    budget: '',
                    description: '',
                    applicantCount: '0',
                    clientName: '',
                    contractCount: '0',
                    postedDate: '',
                    detailedDescription: detailedDescription,
                    paymentType: '',
                    deliveryDate: '',
                    applicationDeadline: '',
                    client: {
                        name: '',
                        overallRating: '',
                        orderHistory: '',
                        completionRate: ''
                    }
                };
            });
            
            return detail;
            
        } catch (error) {
            console.error(`詳細取得エラー: ${url}`, error);
            return null;
        }
    }

      /**
   * 予算額を数値で抽出
   */
  // private extractBudgetAmount(budget: string): number {
  //   if (!budget) return 0;
  //   
  //   // 「～」や「-」で区切られた範囲の場合は上限値を取得
  //   const rangeMatch = budget.match(/([0-9,]+)\s*円\s*[~～-]\s*([0-9,]+)\s*円/);
  //   if (rangeMatch && rangeMatch[1] && rangeMatch[2]) {
  //     const min = parseInt(rangeMatch[1].replace(/,/g, '')) || 0;
  //     const max = parseInt(rangeMatch[2].replace(/,/g, '')) || 0;
  //     return Math.max(min, max); // 上限値を返す
  //   }
  //   
  //   // 単一の金額
  //   const singleMatch = budget.match(/([0-9,]+)\s*円/);
  //   if (singleMatch && singleMatch[1]) {
  //     return parseInt(singleMatch[1].replace(/,/g, '')) || 0;
  //   }
  //   
  //   return 0;
  // }
}
</file>

<file path=".eslintrc.js">
module.exports = {
    parser: '@typescript-eslint/parser',
    parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
    },
    env: {
        node: true,
        es2022: true
    },
    plugins: [
        '@typescript-eslint'
    ],
    extends: [
        'eslint:recommended'
    ],
    rules: {
        // any型を厳格に禁止
        '@typescript-eslint/no-explicit-any': 'error',
        '@typescript-eslint/no-unused-vars': ['error', {
            argsIgnorePattern: '^_',
            varsIgnorePattern: '^_'
        }],

        // General rules
        'no-console': 'off', // 開発中は許可
        'no-debugger': 'error',
        'prefer-const': 'error',
        'no-var': 'error'
    },
    ignorePatterns: [
        'dist/',
        'node_modules/',
        'cdk.out/',
        '*.js',
        '*.d.ts'
    ]
};
</file>

<file path="Dockerfile">
# ベースイメージ
FROM node:18-alpine as base

# 必要なシステムパッケージのインストール
RUN apk add --no-cache \
    git \
    python3 \
    make \
    g++ \
    chromium \
    && rm -rf /var/cache/apk/*

# 作業ディレクトリの設定
WORKDIR /app

# package.jsonとpackage-lock.jsonをコピー（依存関係キャッシュ用）
COPY package*.json ./

# === 依存関係インストールステージ ===
FROM base as dependencies

# 全ての依存関係をインストール
RUN npm ci

# === ビルドステージ ===
FROM dependencies as build

# ソースコードをコピー
COPY . .

# TypeScriptのビルド
RUN npm run build

# 不要なdevDependenciesを削除
RUN npm prune --production

# === テスト用ステージ ===
FROM dependencies as test

# ソースコードをコピー
COPY . .

# TypeScriptのビルド（テスト用）
RUN npm run build

# Playwrightの設定
ENV PLAYWRIGHT_BROWSERS_PATH=/usr/bin/chromium-browser
ENV PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1

# テスト実行
CMD ["npm", "run", "test:coverage"]

# === 開発用ステージ ===
FROM dependencies as development

# ソースコードをコピー
COPY . .

# 開発用のポート公開
EXPOSE 3000 9229

# 開発用のデフォルトコマンド
CMD ["npm", "run", "dev"]

# === 本番用ステージ ===
FROM node:18-alpine as production

# 作業ディレクトリの設定
WORKDIR /app

# 本番用の最小限のパッケージのみインストール
RUN apk add --no-cache dumb-init

# 非rootユーザーの作成
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

# ビルド成果物と本番用依存関係をコピー
COPY --from=build --chown=nextjs:nodejs /app/dist ./dist
COPY --from=build --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=build --chown=nextjs:nodejs /app/package.json ./package.json

# 非rootユーザーに切り替え
USER nextjs

# ヘルスチェック追加
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node --version || exit 1

# 本番用のデフォルトコマンド
CMD ["dumb-init", "node", "dist/index.js"]
</file>

<file path="src/types/index.ts">
// 案件データ型（軽量版）
export interface JobData {
  id: string; // 案件ID（ユニーク）
  title: string; // 案件タイトル
  description: string; // 案件詳細（最大500文字）
  url: string; // 案件URL
  budget: number; // 予算（円）
  deadline: Date; // 納期
  workType: 'fixed' | 'hourly'; // 固定報酬 or 時間単価
  category: string; // カテゴリ
  clientName: string; // クライアント名
  clientRating: number; // クライアント評価（1-5）
  clientReviews: number; // レビュー数
  skills: string[]; // 必要スキル（最大5個）
  experience: 'beginner' | 'intermediate' | 'expert'; // 経験レベル
  scrapedAt: Date; // 取得日時
  source: 'crowdworks' | 'upwork'; // 取得元（拡張済み）
}

// 評価結果型（軽量版）
export interface JobEvaluation {
  jobId: string; // 対象案件ID
  evaluatedAt: Date; // 評価日時
  score: number; // おすすめ度（1-10）
  reason: string; // 評価理由（最大50文字）
  aiModel: 'gpt-3.5-turbo'; // 使用AIモデル
  tokenUsed: number; // 使用トークン数
  costEstimate: number; // 推定コスト（USD）
  strengths: string[]; // 強み（最大3個）
  concerns: string[]; // 懸念点（最大3個）
}

// 実行ログ型
export interface ExecutionLog {
  executionId: string; // 実行ID（タイムスタンプベース）
  timestamp: string; // 実行開始時刻（ISO形式）
  status: 'success' | 'error' | 'partial'; // 実行ステータス
  duration: number; // 実行時間（ミリ秒）
  jobsScraped: number; // スクレイピング件数
  newJobs: number; // 新規案件数
  aiEvaluated: number; // AI評価件数
  highScoreJobs: number; // 高評価案件数（閾値以上）
  costEstimate: number; // 推定コスト（USD）
  error?: {
    type: string; // エラータイプ
    message: string; // エラーメッセージ
    stack?: string; // スタックトレース
  };
}

// システム設定型
export interface SystemConfig {
  scraping: {
    maxJobsPerExecution: number;
    preFilterEnabled: boolean;
    minBudget: number;
    minClientRating: number;
    maxDescriptionLength: number;
  };
  ai: {
    enabled: boolean;
    model: 'gpt-3.5-turbo';
    maxJobsForEvaluation: number;
    monthlyBudgetLimit: number;
    maxTokensPerRequest: number;
    temperature: number;
  };
  notification: {
    enabled: boolean;
    scoreThreshold: number;
    errorNotificationEnabled: boolean;
    dailySummaryEnabled: boolean;
  };
  storage: {
    retentionDays: number;
    compressionEnabled: boolean;
    backupEnabled: boolean;
  };
  performance: {
    timeoutSeconds: number;
    retryCount: number;
    concurrentLimit: number;
  };
}

// 検索条件型
export interface SearchCondition {
  id: string;
  name: string;
  enabled: boolean;
  keywords: string[];
  budgetMin: number;
  budgetMax: number;
  category: string;
  workType: 'fixed' | 'hourly' | 'both';
  clientRatingMin: number;
  experienceLevel: 'beginner' | 'intermediate' | 'expert' | 'any';
  excludeKeywords: string[];
  excludeClients: string[];
}

// 検索条件設定型
export interface SearchConditions {
  version: string;
  lastUpdated: Date;
  conditions: SearchCondition[];
}

// ログイン認証情報型
export interface LoginCredentials {
  email: string;
  password: string;
}

// Lambda イベント型
export interface ScheduledExecutionEvent {
  source: string;
  'detail-type': string;
  detail: Record<string, any>;
  time?: string; // ISO形式（オプション）
}

// Lambda レスポンス型（新形式）
export interface ScheduledExecutionResponse {
  statusCode: number; // HTTP レスポンスコード
  body: string; // JSON文字列レスポンス
  executionTime: number; // 実行時間（ミリ秒）
  timestamp: string; // ISO形式タイムスタンプ
}

// Playwright動作確認結果型
export interface PlaywrightTestResult {
  success: boolean;
  chromiumVersion?: string;
  title?: string;
  screenshot?: boolean;
  error?: string;
  executionTime: number;
}

// Lambda実行結果型（新形式）
export interface LambdaExecutionResult {
  phases: {
    playwright: PlaywrightTestResult;
    crowdworksLogin: {
      success: boolean;
      loginResult?: CrowdWorksLoginResult;
      error?: string;
      executionTime: number;
    };
    crowdworksScraping: {
      success: boolean;
      scrapingResult?: any; // 実装時に詳細型を追加
      error?: string;
      executionTime: number;
    };
  };
  executionTime: number;
  timestamp: string;
}

// Lambda エラーレスポンス型
export interface LambdaErrorResponse {
  message: string;
  error: string;
  requestId: string;
  timestamp: string;
}

// 旧形式レスポンス型（後方互換性維持）
export interface LegacyScheduledExecutionResponse {
  status: 'success' | 'error' | 'partial';
  executionId: string;
  timestamp: string;
  results: {
    jobsScraped: number;
    newJobs: number;
    aiEvaluated: number;
    highScoreJobs: number;
    duration: number;
    costEstimate: number;
  };
  error?: {
    type: string;
    message: string;
  };
}

// エラー型
export enum ErrorType {
  AUTHENTICATION_ERROR = 'AUTH_ERROR',
  LAMBDA_TIMEOUT = 'LAMBDA_TIMEOUT',
  S3_ACCESS_ERROR = 'S3_ACCESS_ERROR',
  SCRAPING_ERROR = 'SCRAPING_ERROR',
  AI_API_ERROR = 'AI_API_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
}

export class AppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// CrowdWorks認証情報
export interface CrowdWorksCredentials {
  email: string;
  password: string;
}

// CrowdWorksログイン結果
export interface CrowdWorksLoginResult {
  success: boolean;
  isLoggedIn: boolean;
  error?: string;
  executionTime: number;
}

// クラウドワークスカテゴリ型
export type CrowdWorksCategory =
  | 'ec'
  | 'web_products'
  | 'software_development'
  | 'development'
  | 'writing'
  | 'translation'
  | 'marketing'
  | 'system_development'
  | 'app_development'
  | 'data_entry'
  | 'others';

// デフォルト設定定数
export const DEFAULT_CONFIG = {
  MAX_JOBS_PER_CATEGORY: 50,
  MAX_DETAILS_PER_CATEGORY: 50,
  ALL_CATEGORIES: [
    'ec',
    'web_products',
    'software_development',
    'development',
    'writing',
    'translation',
    'marketing',
    'system_development',
    'app_development'
  ] as const satisfies readonly CrowdWorksCategory[]
} as const;

// Upwork専用案件データ型
export interface UpworkJobData {
  id: string; // Upwork案件ID
  title: string; // 案件タイトル
  description: string; // 案件詳細
  url: string; // Upwork案件URL
  budget: {
    type: 'fixed' | 'hourly'; // 固定価格 or 時間単価
    amount?: number; // 固定価格の場合の金額（USD）
    min?: number; // 時間単価の場合の最小金額（USD）
    max?: number; // 時間単価の場合の最大金額（USD）
  };
  duration: string; // プロジェクト期間（"Less than 1 month"等）
  experienceLevel: 'entry' | 'intermediate' | 'expert'; // 経験レベル
  jobType: 'fixed-price' | 'hourly'; // 案件タイプ
  category: {
    name: string; // カテゴリ名
    subcategory?: string; // サブカテゴリ
  };
  client: {
    country?: string; // クライアントの国
    memberSince?: string; // 登録日
    totalSpent?: number; // 総支払額（USD）
    hireRate?: number; // 採用率（%）
    totalJobs?: number; // 総案件投稿数
    avgHourlyPaid?: number; // 平均時給支払額（USD）
    paymentVerified: boolean; // 支払い認証済み
  };
  skills: string[]; // 必要スキル
  proposals: number; // 提案数
  postedTime: string; // 投稿時間
  scrapedAt: Date; // 取得日時
}

// Upwork API認証情報型
export interface UpworkCredentials {
  consumerKey: string;
  consumerSecret: string;
  accessToken?: string;
  accessTokenSecret?: string;
  // OAuth2用（将来対応）
  clientId?: string;
  clientSecret?: string;
  refreshToken?: string;
}

// Upworkログイン結果型
export interface UpworkLoginResult {
  success: boolean;
  isAuthenticated: boolean;
  accessToken?: string;
  error?: string;
  executionTime: number;
}

// 統合案件検索結果型
export interface IntegratedJobSearchResult {
  crowdworks: {
    jobs: JobData[];
    total: number;
    success: boolean;
    error?: string;
    executionTime: number;
  };
  upwork: {
    jobs: UpworkJobData[];
    total: number;
    success: boolean;
    error?: string;
    executionTime: number;
  };
  summary: {
    totalJobs: number;
    highHourlyJobs: number; // 時給一定以上の案件数
    averageHourlyRate: number; // 平均時給（円換算）
    executionTime: number;
    timestamp: Date;
  };
}

// 統合案件レポート型
export interface IntegratedJobReport {
  id: string; // レポートID
  generatedAt: Date; // 生成日時
  criteria: {
    minHourlyRate: number; // 最低時給条件（円）
    categories: string[]; // 対象カテゴリ
    maxJobsPerSource: number; // ソース毎の最大取得件数
  };
  results: IntegratedJobSearchResult;
  highValueJobs: {
    crowdworks: JobData[];
    upwork: UpworkJobData[];
  };
  analysis: {
    marketTrends: string; // 市場動向分析
    recommendations: string[]; // おすすめ案件の理由
    alerts: string[]; // 注意事項
  };
}

// 統合検索設定型
export interface IntegratedSearchConfig {
  enabled: {
    crowdworks: boolean;
    upwork: boolean;
  };
  limits: {
    maxJobsPerSource: number;
    maxExecutionTime: number; // 秒
  };
  filtering: {
    minHourlyRateJPY: number; // 最低時給（円）
    minBudgetJPY: number; // 最低予算（円）
    excludeKeywords: string[]; // 除外キーワード
    requiredSkills: string[]; // 必須スキル
  };
  currency: {
    exchangeRateUSDToJPY: number; // USD→JPY換算レート
    lastUpdated: Date; // レート更新日
  };
}
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "commonjs",
        "lib": [
            "ES2022",
            "DOM"
        ],
        "types": [
            "node"
        ],
        "rootDir": "./src",
        "outDir": "./dist",
        "removeComments": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true,
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "strictFunctionTypes": true,
        "strictBindCallApply": true,
        "strictPropertyInitialization": true,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "noImplicitOverride": true,
        "exactOptionalPropertyTypes": true,
        "noPropertyAccessFromIndexSignature": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "allowUnreachableCode": false,
        "allowUnusedLabels": false,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "forceConsistentCasingInFileNames": true,
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "skipLibCheck": true,
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true,
        "baseUrl": "./",
        "paths": {
            "@/*": [
                "src/*"
            ],
            "@/types/*": [
                "src/types/*"
            ],
            "@/services/*": [
                "src/services/*"
            ],
            "@/utils/*": [
                "src/utils/*"
            ],
            "@/infrastructure/*": [
                "src/infrastructure/*"
            ]
        }
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "cdk.out",
        "test",
        "**/*.test.ts",
        "**/*.spec.ts",
        "*.js"
    ],
    "ts-node": {
        "require": [
            "tsconfig-paths/register"
        ],
        "compilerOptions": {
            "module": "commonjs"
        }
    }
}
</file>

<file path=".github/workflows/ci.yml">
name: CI/CD Pipeline

# GitHub Actionsの権限設定
permissions:
  contents: read
  security-events: write
  id-token: write # OIDC認証用

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch: # 手動実行を許可
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  NODE_VERSION: '18'
  AWS_REGION: 'ap-northeast-1'

jobs:
  # コード品質チェック（最速実行）
  code-quality:
    name: Code Quality Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint check
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: TypeScript type check
        run: npm run type-check

  # 単体テスト
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: code-quality
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:coverage

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          token: ${{ secrets.CODECOV_TOKEN }}

  # ビルドテスト
  build-test:
    name: Build Test
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: code-quality
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build TypeScript
        run: npm run build

      - name: Verify build output
        run: |
          echo "=== Checking build output ==="
          if [ ! -d "dist" ]; then
            echo "❌ Build failed: dist directory not found"
            exit 1
          fi
          
          # メインファイルの存在確認
          main_files=("dist/index.js" "dist/lambda/handler.js")
          for file in "${main_files[@]}"; do
            if [ -f "$file" ]; then
              echo "✅ Found: $file"
            else
              echo "⚠️  Not found: $file"
            fi
          done
          
          echo "Contents of dist directory:"
          find dist -name "*.js" -type f | head -10
          echo "✅ Build verification completed"

      - name: Archive build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: dist/
          retention-days: 7

  # CDK構文チェック
  cdk-synth:
    name: CDK Synth Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build-test
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: CDK Synth (dry-run)
        run: npm run cdk:synth
        env:
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}

  # セキュリティスキャン
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: code-quality
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: typescript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # Docker Build Test
  docker-build:
    name: Docker Build Test
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build-test
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          docker build -t crowdworks-searcher:test .
          echo "✅ Docker build completed successfully"

      - name: Test Docker container
        run: |
          docker run --rm crowdworks-searcher:test node --version
          echo "✅ Docker container test passed"

  # Staging デプロイ（developブランチ）
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [unit-tests, build-test, cdk-synth, docker-build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (Staging)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.STAGING_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Staging

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to Staging with CDK
        run: |
          npm run cdk:deploy:staging
        env:
          STAGE: staging
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

      - name: Post-deployment verification
        run: |
          echo "Verifying staging deployment..."
          # Lambda関数の存在確認
          aws lambda get-function --function-name crowdworks-searcher-staging-main
          echo "✅ Staging deployment verified"

      - name: Slack notification (Staging)
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Production デプロイ（mainブランチ）
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [unit-tests, build-test, cdk-synth, docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://production.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (Production)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PRODUCTION_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Production

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to Production with CDK
        run: |
          npm run cdk:deploy:production
        env:
          STAGE: production
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

      - name: Post-deployment verification
        run: |
          echo "Verifying production deployment..."
          # Lambda関数の存在確認
          aws lambda get-function --function-name crowdworks-searcher-production-main
          # CloudWatch Logs確認
          aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/crowdworks-searcher-production"
          echo "✅ Production deployment verified"

      - name: Create deployment tag
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git tag -a "v$(date +%Y%m%d_%H%M%S)" -m "Production deployment $(date)"
          git push origin --tags

      - name: Slack notification (Production)
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # 手動デプロイ（workflow_dispatch）
  deploy-manual:
    name: Manual Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ github.event.inputs.environment == 'production' && secrets.PRODUCTION_AWS_ROLE_ARN || secrets.STAGING_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Manual

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy with CDK
        run: |
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            npm run cdk:deploy:production
          else
            npm run cdk:deploy:staging
          fi
        env:
          STAGE: ${{ github.event.inputs.environment }}
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

  # 通知（失敗時のみ）
  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-test, cdk-synth, security-scan]
    if: failure()
    
    steps:
      - name: Notify failure
        run: |
          echo "❌ CI/CD Pipeline failed"
          echo "Workflow: ${{ github.workflow }}"
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"
          # TODO: Slack/Discord通知を実装
</file>

<file path="scripts/calculate-recommendation-score.ts">
require('dotenv').config();

import { readFileSync, writeFileSync, existsSync, unlinkSync } from 'fs';
import OpenAI from 'openai';
// import { chromium } from 'playwright';
// import { AppliedJobsService } from '../src/services/AppliedJobsService';
// import { CrowdWorksCredentials } from '../src/types';

// 型定義
interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    難易度: string;
    gpt_summary: string;
    category?: string;
}

interface ScoredJob extends AnalysisResult {
    hourly_rate_numeric: number;
    workload_hours: number;
    difficulty_score: number;
    skill_fit_score: number;
    recommendation_score: number;
    link: string;
    original_title?: string;
    proposal_greeting?: string;
    specification_questions?: string;
    skill_analysis?: string;
    proposal_amount?: number; // 提案金額
    estimated_finish_date?: string; // 完了予定日（ISO文字列）
    delivery_estimate?: string; // 納期見込み
}

// 処理済み案件のキャッシュインターface
interface ProcessedJobCache {
    jobId: string;
    skill_fit_score: number;
    skill_analysis: string;
    proposal_greeting: string;
    delivery_estimate: string;
    specification_questions: string;
    processed_at: string;
}

// .envからAPIキー取得
const apiKey = process.env['OPENAI_API_KEY'];
if (!apiKey) {
    console.error('❌ OPENAI_API_KEYが設定されていません');
    process.exit(1);
}

const openai = new OpenAI({ apiKey });

// 時給文字列を数値に変換する関数
function parseHourlyRate(hourlyRateString: string): number {
    if (!hourlyRateString || hourlyRateString.trim() === '' || hourlyRateString === '0円') {
        return 0;
    }

    const match = hourlyRateString.match(/([0-9,]+)/);
    if (match && match[1]) {
        const numericString = match[1].replace(/,/g, '');
        return parseInt(numericString, 10);
    }

    return 0;
}

// 工数文字列を数値（時間）に変換する関数
function parseWorkloadHours(workloadString: string): number {
    if (!workloadString || workloadString.trim() === '') {
        return 40; // デフォルト値
    }

    // 「120時間」「2週間」「1ヶ月」などを解析
    const hourMatch = workloadString.match(/([0-9,]+)\s*時間/);
    if (hourMatch && hourMatch[1]) {
        return parseInt(hourMatch[1].replace(/,/g, ''), 10);
    }

    const dayMatch = workloadString.match(/([0-9,]+)\s*日/);
    if (dayMatch && dayMatch[1]) {
        return parseInt(dayMatch[1].replace(/,/g, ''), 10) * 8; // 1日8時間想定
    }

    const weekMatch = workloadString.match(/([0-9,]+)\s*週間/);
    if (weekMatch && weekMatch[1]) {
        return parseInt(weekMatch[1].replace(/,/g, ''), 10) * 40; // 1週間40時間想定
    }

    const monthMatch = workloadString.match(/([0-9,]+)\s*ヶ?月/);
    if (monthMatch && monthMatch[1]) {
        return parseInt(monthMatch[1].replace(/,/g, ''), 10) * 160; // 1ヶ月160時間想定
    }

    return 40; // デフォルト値
}

// 難易度を点数に変換する関数（簡単ほど高得点）
function parseDifficultyScore(difficultyString: string): number {
    const difficulty = difficultyString.trim().toLowerCase();

    if (difficulty.includes('簡単') || difficulty.includes('かんたん')) {
        return 10; // 簡単 = 高得点
    } else if (difficulty.includes('普通') || difficulty.includes('ふつう') || difficulty.includes('標準')) {
        return 6; // 普通 = 中得点
    } else if (difficulty.includes('難しい') || difficulty.includes('むずかしい') || difficulty.includes('困難')) {
        return 3; // 難しい = 低得点
    }

    return 5; // 不明な場合はデフォルト
}

// 評価係数の定数
const EVALUATION_COEFFICIENTS = {
    HOURLY: 1.0,
    WORKLOAD: 0.5,
    SKILL_FIT: 2.0
};

// 提案文生成対象の最低時給基準
const PROPOSAL_GENERATION_MIN_HOURLY_RATE = 3000; // 円

// キャッシュファイルのパス
const PROCESSED_JOBS_CACHE_FILE = 'output/processed-jobs.json';

// 応募済み案件を取得する関数（現在は無効化）
// async function getAppliedJobIds(): Promise<Set<string>> {
//     // 応募済み案件の取得処理は現在無効化されています
//     return new Set<string>();
// }

// 処理済み案件キャッシュを読み込む
function loadProcessedJobsCache(): Map<string, ProcessedJobCache> {
    const cacheMap = new Map<string, ProcessedJobCache>();

    if (existsSync(PROCESSED_JOBS_CACHE_FILE)) {
        try {
            const cacheData: ProcessedJobCache[] = JSON.parse(readFileSync(PROCESSED_JOBS_CACHE_FILE, 'utf8'));
            cacheData.forEach(item => {
                cacheMap.set(item.jobId, item);
            });
            console.log(`📋 処理済み案件キャッシュを読み込み: ${cacheData.length}件`);
        } catch (error) {
            console.log(`⚠️ キャッシュファイルの読み込みに失敗: ${error}`);
        }
    } else {
        console.log(`📋 新規キャッシュファイルを作成します`);
    }

    return cacheMap;
}

// 処理済み案件キャッシュを保存する
function saveProcessedJobsCache(cacheMap: Map<string, ProcessedJobCache>): void {
    try {
        const cacheArray = Array.from(cacheMap.values());
        writeFileSync(PROCESSED_JOBS_CACHE_FILE, JSON.stringify(cacheArray, null, 2), 'utf8');
        console.log(`💾 処理済み案件キャッシュを保存: ${cacheArray.length}件`);
    } catch (error) {
        console.error(`❌ キャッシュファイルの保存に失敗: ${error}`);
    }
}

// クローズした案件を古い順から削除する
function cleanupClosedJobs(): void {
    console.log(`\n🧹 クローズした案件の削除開始...`);

    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

    // 各カテゴリのファイルを処理
    const categories = ['ec', 'web_products', 'software_development', 'development'];
    let totalRemovedDetails = 0;
    let totalRemovedAnalyzed = 0;
    let totalRemovedCache = 0;

    categories.forEach(category => {
        // 詳細データのクリーンアップ
        const detailsFile = `output/details-${category}.json`;
        if (existsSync(detailsFile)) {
            try {
                const detailsData = JSON.parse(readFileSync(detailsFile, 'utf8'));
                const originalCount = detailsData.length;

                // 応募締切が過ぎた案件を特定
                const closedJobs: any[] = [];
                const activeJobs = detailsData.filter((detail: any) => {
                    if (!detail.applicationDeadline) {
                        return true; // 締切が設定されていない場合は残す
                    }

                    try {
                        // 日本語の日付形式（YYYY年MM月DD日）をパース
                        const deadlineStr = detail.applicationDeadline;
                        const match = deadlineStr.match(/(\d{4})年(\d{1,2})月(\d{1,2})日/);
                        if (!match) {
                            return true; // パースできない場合は残す
                        }

                        const year = parseInt(match[1]);
                        const month = parseInt(match[2]) - 1; // Dateオブジェクトは0ベース
                        const day = parseInt(match[3]);
                        const deadline = new Date(year, month, day);

                        if (deadline < today) {
                            closedJobs.push({
                                jobId: detail.jobId,
                                title: detail.title,
                                deadline: deadline,
                                applicationDeadline: deadlineStr
                            });
                            return false; // 削除対象
                        }
                        return true; // 有効案件として残す
                    } catch (error) {
                        return true; // エラーの場合は残す
                    }
                });

                if (closedJobs.length > 0) {
                    // 古い順（締切日が早い順）にソート
                    closedJobs.sort((a, b) => a.deadline.getTime() - b.deadline.getTime());

                    // ファイルを更新
                    writeFileSync(detailsFile, JSON.stringify(activeJobs, null, 2), 'utf8');
                    totalRemovedDetails += closedJobs.length;

                    console.log(`🗑️ ${category} 詳細データ: ${closedJobs.length}件削除 (${originalCount}件 → ${activeJobs.length}件)`);
                    console.log(`   最古の削除案件: ${closedJobs[0].applicationDeadline} - ${closedJobs[0].title.substring(0, 30)}...`);
                }
            } catch (error) {
                console.log(`⚠️ ${category} 詳細データのクリーンアップに失敗: ${error}`);
            }
        }

        // 分析データのクリーンアップ
        const analyzedFile = `output/analyzed-${category}.json`;
        if (existsSync(analyzedFile)) {
            try {
                const analyzedData = JSON.parse(readFileSync(analyzedFile, 'utf8'));
                const originalCount = analyzedData.length;

                // 対応する詳細データが存在する分析データのみ残す
                const activeDetailsJobIds = new Set();
                const detailsFile = `output/details-${category}.json`;
                if (existsSync(detailsFile)) {
                    const detailsData = JSON.parse(readFileSync(detailsFile, 'utf8'));
                    detailsData.forEach((detail: any) => activeDetailsJobIds.add(detail.jobId));
                }

                const activeAnalyzedData = analyzedData.filter((analyzed: any) =>
                    activeDetailsJobIds.has(analyzed.jobId)
                );

                const removedCount = originalCount - activeAnalyzedData.length;
                if (removedCount > 0) {
                    writeFileSync(analyzedFile, JSON.stringify(activeAnalyzedData, null, 2), 'utf8');
                    totalRemovedAnalyzed += removedCount;
                    console.log(`🗑️ ${category} 分析データ: ${removedCount}件削除 (${originalCount}件 → ${activeAnalyzedData.length}件)`);
                }
            } catch (error) {
                console.log(`⚠️ ${category} 分析データのクリーンアップに失敗: ${error}`);
            }
        }
    });

    // 処理済みキャッシュのクリーンアップ
    if (existsSync(PROCESSED_JOBS_CACHE_FILE)) {
        try {
            const cacheData = JSON.parse(readFileSync(PROCESSED_JOBS_CACHE_FILE, 'utf8'));
            const originalCount = cacheData.length;

            // 有効な詳細データが存在するキャッシュのみ残す
            const allActiveJobIds = new Set();
            categories.forEach(category => {
                const detailsFile = `output/details-${category}.json`;
                if (existsSync(detailsFile)) {
                    const detailsData = JSON.parse(readFileSync(detailsFile, 'utf8'));
                    detailsData.forEach((detail: any) => allActiveJobIds.add(detail.jobId));
                }
            });

            const activeCacheData = cacheData.filter((cache: any) =>
                allActiveJobIds.has(cache.jobId)
            );

            const removedCount = originalCount - activeCacheData.length;
            if (removedCount > 0) {
                writeFileSync(PROCESSED_JOBS_CACHE_FILE, JSON.stringify(activeCacheData, null, 2), 'utf8');
                totalRemovedCache += removedCount;
                console.log(`🗑️ 処理済みキャッシュ: ${removedCount}件削除 (${originalCount}件 → ${activeCacheData.length}件)`);
            }
        } catch (error) {
            console.log(`⚠️ 処理済みキャッシュのクリーンアップに失敗: ${error}`);
        }
    }

    const totalRemoved = totalRemovedDetails + totalRemovedAnalyzed + totalRemovedCache;
    if (totalRemoved > 0) {
        console.log(`\n🎯 クリーンアップ完了:`);
        console.log(`   詳細データ: ${totalRemovedDetails}件削除`);
        console.log(`   分析データ: ${totalRemovedAnalyzed}件削除`);
        console.log(`   キャッシュ: ${totalRemovedCache}件削除`);
        console.log(`   合計: ${totalRemoved}件削除`);
    } else {
        console.log(`🎉 削除対象のクローズした案件はありませんでした`);
    }
}

// おすすめ点数を計算する関数（スキル適性考慮版）
function calculateRecommendationScore(
    hourlyRate: number,
    workloadHours: number,
    skillFitScore: number
): number {
    // 時給スコア（0-10点）: 時給が高いほど高得点
    let hourlyScore = 0;
    if (hourlyRate >= 4000) hourlyScore = 10;
    else if (hourlyRate >= 3500) hourlyScore = 9;
    else if (hourlyRate >= 3000) hourlyScore = 8;
    else if (hourlyRate >= 2500) hourlyScore = 7;
    else if (hourlyRate >= 2000) hourlyScore = 6;
    else if (hourlyRate >= 1500) hourlyScore = 5;
    else if (hourlyRate >= 1000) hourlyScore = 4;
    else if (hourlyRate >= 500) hourlyScore = 3;
    else if (hourlyRate > 0) hourlyScore = 2;
    else hourlyScore = 0;

    // 工数スコア（0-10点）: 適度な工数（20-80時間）が高得点
    let workloadScore = 0;
    if (workloadHours >= 20 && workloadHours <= 80) {
        workloadScore = 10; // 最適範囲
    } else if (workloadHours >= 10 && workloadHours <= 120) {
        workloadScore = 8; // 良い範囲
    } else if (workloadHours >= 5 && workloadHours <= 160) {
        workloadScore = 6; // 許容範囲
    } else if (workloadHours > 0 && workloadHours <= 200) {
        workloadScore = 4; // 微妙な範囲
    } else {
        workloadScore = 2; // 極端な工数
    }

    // 係数システムによる総合スコア計算（スキル適性重視）
    const totalScore = (hourlyScore * EVALUATION_COEFFICIENTS.HOURLY) +
        (workloadScore * EVALUATION_COEFFICIENTS.WORKLOAD) +
        (skillFitScore * EVALUATION_COEFFICIENTS.SKILL_FIT);

    return Math.round(totalScore * 10) / 10; // 小数点1位まで
}

// 詳細データから元のタイトルを取得する関数
function getOriginalJobData(jobId: string, detailsData: any[], lancersJobs?: any[]): any {
    // まずCrowdWorksの詳細データから検索
    const crowdWorksJob = detailsData.find(job => job.jobId === jobId);
    if (crowdWorksJob) {
        return crowdWorksJob;
    }

    // ランサーズの案件データから検索
    if (lancersJobs) {
        const lancersJob = lancersJobs.find(item => item.id === jobId);
        if (lancersJob) {
            return {
                jobId: lancersJob.id,
                title: lancersJob.title,
                detailedDescription: lancersJob.description,
                url: lancersJob.url,
                source: 'lancers'
            };
        }
    }

    return null;
}

// 並列実行制御クラス
class ConcurrencyLimiter {
    private runningCount = 0;
    private queue: (() => Promise<void>)[] = [];

    constructor(private maxConcurrency: number) { }

    async execute<T>(task: () => Promise<T>): Promise<T> {
        return new Promise<T>((resolve, reject) => {
            const wrappedTask = async () => {
                try {
                    this.runningCount++;
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.runningCount--;
                    this.processQueue();
                }
            };

            if (this.runningCount < this.maxConcurrency) {
                wrappedTask();
            } else {
                this.queue.push(wrappedTask);
            }
        });
    }

    private processQueue() {
        if (this.queue.length > 0 && this.runningCount < this.maxConcurrency) {
            const nextTask = this.queue.shift();
            if (nextTask) {
                nextTask();
            }
        }
    }
}

// メイン処理（非同期版）
async function main(): Promise<void> {
    console.log('🚀 おすすめ案件の計算を開始します...');

    // 応募済み案件IDを取得（現在は無効化）
    console.log('\n📋 応募済み案件の取得はスキップします（APIキー未設定のため）');

    // クローズした案件を削除
    cleanupClosedJobs();

    const startTime = Date.now();

    try {
        // 処理済み案件キャッシュを読み込み
        const processedCache = loadProcessedJobsCache();
        console.log(`📋 処理済みキャッシュ読み込み: ${processedCache.size}件`);

        const scoredJobs: ScoredJob[] = [];

        // 詳細データも読み込む（元のタイトル取得用）
        let ecDetailsData: any[] = [];
        let webDetailsData: any[] = [];
        let softwareDetailsData: any[] = [];
        let developmentDetailsData: any[] = [];
        let lancersDetailsData: any[] = [];

        // CrowdWorks詳細データの読み込み
        try {
            ecDetailsData = JSON.parse(readFileSync('output/details-ec.json', 'utf8'));
            console.log(`📂 CrowdWorks EC詳細データ: ${ecDetailsData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ CrowdWorks EC詳細データの読み込みに失敗: ${error}`);
        }

        try {
            webDetailsData = JSON.parse(readFileSync('output/details-web_products.json', 'utf8'));
            console.log(`📂 CrowdWorks Web製品詳細データ: ${webDetailsData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ CrowdWorks Web製品詳細データの読み込みに失敗: ${error}`);
        }

        try {
            softwareDetailsData = JSON.parse(readFileSync('output/details-software_development.json', 'utf8'));
            console.log(`📂 CrowdWorks ソフトウェア開発詳細データ: ${softwareDetailsData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ CrowdWorks ソフトウェア開発詳細データの読み込みに失敗: ${error}`);
        }

        try {
            developmentDetailsData = JSON.parse(readFileSync('output/details-development.json', 'utf8'));
            console.log(`📂 CrowdWorks 開発詳細データ: ${developmentDetailsData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ CrowdWorks 開発詳細データの読み込みに失敗: ${error}`);
        }

        // ランサーズ詳細データの読み込み
        console.log(`🔍 ランサーズ詳細データの読み込みを開始...`);
        try {
            const lancersAllDetails = JSON.parse(readFileSync('output/lancers-all-details.json', 'utf8'));
            lancersDetailsData = lancersAllDetails.details || [];
            console.log(`📂 ランサーズ詳細データ: ${lancersDetailsData.length}件読み込み SUCCESS`);
        } catch (error) {
            console.log(`⚠️ ランサーズ詳細データの読み込みに失敗: ${error}`);
        }

        // AI分析済みデータの読み込み（オプション）
        let ecAnalyzedData: any[] = [];
        let webAnalyzedData: any[] = [];
        let softwareAnalyzedData: any[] = [];
        let developmentAnalyzedData: any[] = [];
        let lancersAnalyzedData: any[] = [];

        try {
            ecAnalyzedData = JSON.parse(readFileSync('output/analyzed-ec.json', 'utf8'));
            console.log(`🧠 EC AI分析データ: ${ecAnalyzedData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ ECカテゴリファイルが見つかりません: analyzed-ec.json`);
        }

        try {
            webAnalyzedData = JSON.parse(readFileSync('output/analyzed-web_products.json', 'utf8'));
            console.log(`🧠 Web製品 AI分析データ: ${webAnalyzedData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ Web製品カテゴリファイルが見つかりません: analyzed-web_products.json`);
        }

        try {
            softwareAnalyzedData = JSON.parse(readFileSync('output/analyzed-software_development.json', 'utf8'));
            console.log(`🧠 ソフトウェア開発 AI分析データ: ${softwareAnalyzedData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ ソフトウェア開発カテゴリファイルが見つかりません: analyzed-software_development.json`);
        }

        try {
            developmentAnalyzedData = JSON.parse(readFileSync('output/analyzed-development.json', 'utf8'));
            console.log(`🧠 開発 AI分析データ: ${developmentAnalyzedData.length}件読み込み`);
        } catch (error) {
            console.log(`⚠️ 開発カテゴリファイルが見つかりません: analyzed-development.json`);
        }

        // ランサーズ分析データの読み込み
        console.log(`🔍 ランサーズ分析データの読み込みを開始...`);
        try {
            lancersAnalyzedData = JSON.parse(readFileSync('output/analyzed-lancers.json', 'utf8'));
            console.log(`🧠 ランサーズ AI分析データ: ${lancersAnalyzedData.length}件読み込み SUCCESS`);
        } catch (error) {
            console.log(`⚠️ ランサーズカテゴリファイルが見つかりません: analyzed-lancers.json - ${error}`);
        }

        // 全カテゴリの分析データをマージして終了案件を除外
        const allAnalyzedJobs = [
            ...ecAnalyzedData,
            ...webAnalyzedData,
            ...softwareAnalyzedData,
            ...developmentAnalyzedData,
            ...lancersAnalyzedData
        ];

        console.log(`📊 統合後の全案件数: ${allAnalyzedJobs.length}件`);
        console.log(`📊 EC: ${ecAnalyzedData.length}件, Web: ${webAnalyzedData.length}件, Software: ${softwareAnalyzedData.length}件, Development: ${developmentAnalyzedData.length}件, Lancers: ${lancersAnalyzedData.length}件`);

        // 現在の日付を取得
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

        // ランサーズの案件データも読み込み
        console.log(`🔍 ランサーズ案件データの読み込みを開始...`);
        let lancersJobsData: any[] = [];
        try {
            const lancersAllJobs = JSON.parse(readFileSync('output/lancers-all-jobs.json', 'utf8'));
            lancersJobsData = lancersAllJobs.jobs || [];
            console.log(`📂 ランサーズ案件データ: ${lancersJobsData.length}件読み込み SUCCESS`);
        } catch (error) {
            console.log(`⚠️ ランサーズ案件データの読み込みに失敗: ${error}`);
        }

        // 全詳細データをマージ
        const allDetailsData = [
            ...ecDetailsData,
            ...webDetailsData,
            ...softwareDetailsData,
            ...developmentDetailsData,
            ...lancersDetailsData
        ];

        // 🚀 統合前のLancers案件確認
        const lancersInAll = allAnalyzedJobs.filter(job => job.jobId.includes('lancers_test'));
        console.log(`🚀 デバッグ - allAnalyzedJobsにLancers案件: ${lancersInAll.length}件`);
        lancersInAll.forEach(job => {
            console.log(`   - ${job.jobId}: ${job.title}`);
        });

        // 終了している案件を除外（応募締切が過ぎた案件）
        const activeJobs = allAnalyzedJobs.filter(job => {
            // 対応する詳細データを検索
            const detailData = allDetailsData.find(detail => detail.jobId === job.jobId);



            if (!detailData || !detailData.applicationDeadline) {
                return true; // 詳細データまたは締切が設定されていない場合は有効とする
            }

            try {
                // 日本語の日付形式（YYYY年MM月DD日）をパース
                const deadlineStr = detailData.applicationDeadline;
                const match = deadlineStr.match(/(\d{4})年(\d{1,2})月(\d{1,2})日/);
                if (!match) {
                    return true; // パースできない場合は有効とする
                }

                const deadlineDate = new Date(
                    parseInt(match[1]),
                    parseInt(match[2]) - 1, // 月は0ベース
                    parseInt(match[3])
                );

                return deadlineDate >= today; // 今日以降なら有効
            } catch (error) {
                console.log(`⚠️ 締切日パースエラー (jobId: ${job.jobId}): ${detailData.applicationDeadline}`);
                return true; // エラーの場合は有効とする
            }
        });

        const excludedCount = allAnalyzedJobs.length - activeJobs.length;
        console.log(`📅 応募締切チェック: 総${allAnalyzedJobs.length}件中、${excludedCount}件の終了案件を除外`);
        console.log(`✅ 有効案件: ${activeJobs.length}件で処理を継続`);

        // 応募済み案件を除外（現在は無効化）
        const notAppliedJobs = activeJobs; // 除外処理をスキップ
        console.log(`📝 応募済み案件チェック: スキップ（APIキー未設定）`);
        console.log(`✅ 最終対象案件: ${notAppliedJobs.length}件で処理を継続`);

        console.log(`\n📊 有効案件の分布:`);

        // フィルタリング済みの有効案件のみを処理
        notAppliedJobs.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            const workloadHours = parseWorkloadHours(item.工数_見積もり);
            const difficultyScore = parseDifficultyScore(item.難易度);
            const skillFitScore = 5; // 仮のスキル適性スコア（後で更新）
            const recommendationScore = calculateRecommendationScore(hourlyRate, workloadHours, skillFitScore);

            // カテゴリに応じて詳細データを取得
            let originalJob;
            let categoryName = '';

            if (ecAnalyzedData.some(job => job.jobId === item.jobId)) {
                originalJob = getOriginalJobData(item.jobId, ecDetailsData, lancersJobsData);
                categoryName = 'EC';
            } else if (webAnalyzedData.some(job => job.jobId === item.jobId)) {
                originalJob = getOriginalJobData(item.jobId, webDetailsData, lancersJobsData);
                categoryName = 'Web製品';
            } else if (softwareAnalyzedData.some(job => job.jobId === item.jobId)) {
                originalJob = getOriginalJobData(item.jobId, softwareDetailsData, lancersJobsData);
                categoryName = 'ソフトウェア開発';
            } else if (developmentAnalyzedData.some(job => job.jobId === item.jobId)) {
                originalJob = getOriginalJobData(item.jobId, developmentDetailsData, lancersJobsData);
                categoryName = '開発';
            } else if (lancersAnalyzedData.some(job => job.jobId === item.jobId)) {
                originalJob = getOriginalJobData(item.jobId, lancersDetailsData, lancersJobsData);
                categoryName = 'ランサーズ';
                console.log(`🚀 Lancers案件処理: ${item.jobId} - ${item.title}`);
            }

            const proposalAmount = Math.round(workloadHours * PROPOSAL_GENERATION_MIN_HOURLY_RATE);
            const finishDays = Math.ceil((workloadHours / 6) * 2);
            const finishDate = new Date();
            finishDate.setDate(finishDate.getDate() + finishDays);
            const estimatedFinishDate = finishDate.toISOString().split('T')[0];

            // リンクの生成（プラットフォームに応じて）
            let jobLink = `https://crowdworks.jp/public/jobs/${item.jobId}`;
            if (categoryName === 'ランサーズ') {
                jobLink = originalJob?.url || `https://www.lancers.jp/work/detail/${item.jobId}`;
            }

            scoredJobs.push({
                ...item,
                category: categoryName,
                hourly_rate_numeric: hourlyRate,
                workload_hours: workloadHours,
                difficulty_score: difficultyScore,
                skill_fit_score: skillFitScore,
                recommendation_score: recommendationScore,
                link: jobLink,
                original_title: originalJob?.title || item.title,
                proposal_amount: proposalAmount,
                estimated_finish_date: estimatedFinishDate
            });
        });

        console.log(`✅ 有効案件処理完了: ${notAppliedJobs.length}件`);

        if (scoredJobs.length === 0) {
            console.error('❌ データが読み込めませんでした');
            return;
        }

        // 全案件のスキル適性評価を実行
        console.log(`\n🧠 全案件のスキル適性評価中（最大10件並列）...`);

        const limiter = new ConcurrencyLimiter(10);
        let skillAnalysisCount = 0;
        let cacheHitCount = 0;
        let newProcessingCount = 0;

        const skillAnalysisPromises = scoredJobs.map(async (job, index) => {
            try {
                // キャッシュから既存の結果を確認
                const cachedResult = processedCache.get(job.jobId);

                if (cachedResult) {
                    // キャッシュヒット：既存の結果を使用
                    job.skill_fit_score = cachedResult.skill_fit_score;
                    job.skill_analysis = cachedResult.skill_analysis;

                    // スキル適性スコアでおすすめ点数を再計算
                    job.recommendation_score = calculateRecommendationScore(
                        job.hourly_rate_numeric,
                        job.workload_hours,
                        cachedResult.skill_fit_score
                    );

                    cacheHitCount++;
                    console.log(`💾 [${skillAnalysisCount + cacheHitCount}/${scoredJobs.length}] ${job.original_title?.substring(0, 40)}... キャッシュから取得`);

                    return { success: true, index, fromCache: true };
                } else {
                    // キャッシュミス：新規でGPT処理
                    const allDetailsData = [...ecDetailsData, ...webDetailsData, ...softwareDetailsData, ...developmentDetailsData, ...lancersDetailsData];
                    const originalJob = getOriginalJobData(job.jobId, allDetailsData, lancersJobsData);

                    const { score, analysis } = await limiter.execute(() =>
                        analyzeSkillFit(job, originalJob)
                    );

                    job.skill_fit_score = score;
                    job.skill_analysis = analysis;

                    // スキル適性スコアでおすすめ点数を再計算
                    job.recommendation_score = calculateRecommendationScore(
                        job.hourly_rate_numeric,
                        job.workload_hours,
                        score
                    );

                    // キャッシュに追加（提案文は後で追加）
                    processedCache.set(job.jobId, {
                        jobId: job.jobId,
                        skill_fit_score: score,
                        skill_analysis: analysis,
                        proposal_greeting: '', // 後で更新
                        delivery_estimate: '', // 後で更新
                        specification_questions: '', // 後で更新
                        processed_at: new Date().toISOString()
                    });

                    newProcessingCount++;
                    console.log(`✅ [${newProcessingCount}/${scoredJobs.length - cacheHitCount}] ${job.original_title?.substring(0, 40)}... スキル適性評価完了（新規処理）`);

                    return { success: true, index, fromCache: false };
                }
            } catch (error) {
                console.error(`❌ [${index + 1}/${scoredJobs.length}] スキル適性評価エラー:`, error);
                return { success: false, index, fromCache: false };
            }
        });

        await Promise.allSettled(skillAnalysisPromises);
        skillAnalysisCount = cacheHitCount + newProcessingCount;
        console.log(`🎯 スキル適性評価完了: ${skillAnalysisCount}/${scoredJobs.length}件成功（キャッシュ: ${cacheHitCount}件、新規: ${newProcessingCount}件）`);

        // おすすめ点数順でソート（高得点順）
        const sortedJobs = scoredJobs.sort((a, b) => b.recommendation_score - a.recommendation_score);

        // 統計情報表示
        const validJobs = sortedJobs.filter(j => j.hourly_rate_numeric > 0);
        if (validJobs.length > 0) {
            const maxScore = Math.max(...validJobs.map(j => j.recommendation_score));
            const minScore = Math.min(...validJobs.map(j => j.recommendation_score));
            const avgScore = Math.round((validJobs.reduce((sum, j) => sum + j.recommendation_score, 0) / validJobs.length) * 10) / 10;
            const avgSkillFit = Math.round((validJobs.reduce((sum, j) => sum + j.skill_fit_score, 0) / validJobs.length) * 10) / 10;

            console.log(`\n📈 統計情報:`);
            console.log(`最高おすすめ点数: ${maxScore}点`);
            console.log(`最低おすすめ点数: ${minScore}点`);
            console.log(`平均おすすめ点数: ${avgScore}点`);
            console.log(`平均スキル適性: ${avgSkillFit}点`);
            console.log(`有効案件: ${validJobs.length}件 / 全${sortedJobs.length}件`);
        }

        // 全案件に提案文生成を追加
        console.log(`\n🤖 全案件の提案文生成中（最大8件並列）...`);
        console.log(`対象案件: ${sortedJobs.length}件`);

        const proposalLimiter = new ConcurrencyLimiter(8); // 提案文生成は8件並列
        let proposalCount = 0;
        let proposalCacheHitCount = 0;
        let newProposalProcessingCount = 0;

        const proposalPromises = sortedJobs.map(async (job, index) => {
            try {
                // キャッシュから既存の提案文を確認
                const cachedResult = processedCache.get(job.jobId);

                if (cachedResult && cachedResult.proposal_greeting && cachedResult.proposal_greeting.trim() !== '') {
                    // キャッシュヒット：既存の提案文を使用
                    job.proposal_greeting = cachedResult.proposal_greeting;
                    job.delivery_estimate = cachedResult.delivery_estimate;
                    job.specification_questions = cachedResult.specification_questions;

                    proposalCacheHitCount++;
                    console.log(`💾 [${proposalCount + proposalCacheHitCount}/${sortedJobs.length}] ${job.original_title?.substring(0, 40)}... 提案文をキャッシュから取得`);

                    return { success: true, index, fromCache: true };
                } else {
                    // キャッシュミス：新規でGPT処理
                    const allDetailsData = [...ecDetailsData, ...webDetailsData, ...softwareDetailsData, ...developmentDetailsData, ...lancersDetailsData];
                    const originalJob = getOriginalJobData(job.jobId, allDetailsData, lancersJobsData);

                    const { greeting, delivery_estimate, questions } = await proposalLimiter.execute(() =>
                        generateProposalContent(job, originalJob)
                    );

                    job.proposal_greeting = greeting;
                    job.delivery_estimate = delivery_estimate;
                    job.specification_questions = questions;

                    // キャッシュを更新
                    if (processedCache.has(job.jobId)) {
                        const existingCache = processedCache.get(job.jobId)!;
                        existingCache.proposal_greeting = greeting;
                        existingCache.delivery_estimate = delivery_estimate;
                        existingCache.specification_questions = questions;
                    } else {
                        // スキル適性評価がキャッシュから取得された場合でも、提案文は新規作成
                        processedCache.set(job.jobId, {
                            jobId: job.jobId,
                            skill_fit_score: job.skill_fit_score,
                            skill_analysis: job.skill_analysis || '',
                            proposal_greeting: greeting,
                            delivery_estimate: delivery_estimate,
                            specification_questions: questions,
                            processed_at: new Date().toISOString()
                        });
                    }

                    newProposalProcessingCount++;
                    console.log(`✅ [${newProposalProcessingCount}/${sortedJobs.length - proposalCacheHitCount}] ${job.original_title?.substring(0, 40)}... 提案文生成完了（新規処理）`);

                    return { success: true, index, fromCache: false };
                }
            } catch (error) {
                console.error(`❌ [${index + 1}/${sortedJobs.length}] 提案文生成エラー:`, error);
                return { success: false, index, fromCache: false };
            }
        });

        await Promise.allSettled(proposalPromises);
        proposalCount = proposalCacheHitCount + newProposalProcessingCount;
        console.log(`🎯 提案文生成完了: ${proposalCount}/${sortedJobs.length}件成功（キャッシュ: ${proposalCacheHitCount}件、新規: ${newProposalProcessingCount}件）`);

        // キャッシュを保存
        saveProcessedJobsCache(processedCache);

        // 結果表示（上位20件）
        console.log(`\n🏆 Webエンジニア向けおすすめ案件ランキング TOP20:\n`);

        sortedJobs.slice(0, 20).forEach((job, index) => {
            const rank = index + 1;
            const score = job.recommendation_score;
            const hourlyRate = job.hourly_rate_numeric.toLocaleString() + '円';
            const category = job.category || 'N/A';
            const difficulty = job.難易度 || 'N/A';
            const workload = job.工数_見積もり || 'N/A';
            const skillFit = job.skill_fit_score?.toFixed(1) || 'N/A';
            const summary = (job.gpt_summary || '').substring(0, 60) + '...';

            console.log(`${rank}位: ${score}点 | ${hourlyRate} (${category}) | 難易度: ${difficulty} | スキル適性: ${skillFit}点`);
            console.log(`   工数: ${workload}`);
            console.log(`   概要: ${summary}`);

            if (job.skill_analysis) {
                console.log(`   🧠 適性: ${job.skill_analysis.substring(0, 80)}...`);
            }

            // 提案文があれば表示
            if (job.proposal_greeting) {
                console.log(`   💬 提案文: ${job.proposal_greeting.substring(0, 60)}...`);
            }
            console.log('');
        });

        // 時給3000円以上の案件のみをMarkdownに出力
        const highValueJobs = sortedJobs.filter(job => job.hourly_rate_numeric >= PROPOSAL_GENERATION_MIN_HOURLY_RATE);

        // 時給分布の詳細を表示
        console.log(`\n📊 時給分布の詳細:`);
        const hourlyRateDistribution = sortedJobs.reduce((acc, job) => {
            const rate = job.hourly_rate_numeric;
            if (rate >= 4000) acc['4000円以上']++;
            else if (rate >= 3500) acc['3500円以上']++;
            else if (rate >= 3000) acc['3000円以上']++;
            else if (rate >= 2500) acc['2500円以上']++;
            else if (rate >= 2000) acc['2000円以上']++;
            else if (rate >= 1500) acc['1500円以上']++;
            else if (rate >= 1000) acc['1000円以上']++;
            else acc['1000円未満']++;
            return acc;
        }, {
            '4000円以上': 0,
            '3500円以上': 0,
            '3000円以上': 0,
            '2500円以上': 0,
            '2000円以上': 0,
            '1500円以上': 0,
            '1000円以上': 0,
            '1000円未満': 0
        });

        Object.entries(hourlyRateDistribution).forEach(([range, count]) => {
            if (count > 0) {
                console.log(`   ${range}: ${count}件`);
            }
        });

        console.log(`\n📝 時給${PROPOSAL_GENERATION_MIN_HOURLY_RATE}円以上の案件: ${highValueJobs.length}件をMarkdownに出力`);

        // 全案件データ用のMarkdownファイルを生成
        const allJobsMarkdown = generateAllJobsMarkdown(sortedJobs);
        writeFileSync('output/all-jobs-ranked.md', allJobsMarkdown, 'utf8');
        console.log(`📄 全案件ランキングを保存: output/all-jobs-ranked.md (${sortedJobs.length}件)`);

        // 高時給案件データ用のMarkdownファイルを生成（既存）
        const highValueMarkdown = generateRecommendationMarkdown(highValueJobs, sortedJobs.length); // 時給3000円以上のみ表示
        writeFileSync('output/recommended-jobs.md', highValueMarkdown, 'utf8');
        console.log(`📄 高時給案件おすすめを保存: output/recommended-jobs.md (${highValueJobs.length}件)`);

        // 一時的に生成されたJSONファイルを削除
        try {
            const tempFiles = [
                'output/jobs-with-recommendation-scores.json',
                'output/high-hourly-jobs-3000+.md'
            ];
            tempFiles.forEach(file => {
                if (existsSync(file)) {
                    unlinkSync(file);
                    console.log(`��️ 一時ファイルを削除: ${file}`);
                }
            });
        } catch (error) {
            console.warn('⚠️ 一時ファイル削除中にエラー:', error);
        }

        const endTime = Date.now();
        const duration = ((endTime - startTime) / 1000).toFixed(2);
        console.log(`🎉 おすすめ案件の計算が完了しました。処理時間: ${duration}秒`);
    } catch (error) {
        console.error(`❌ おすすめ案件の計算中にエラーが発生しました:`, error);
    }
}

// Markdown生成関数
function generateRecommendationMarkdown(jobs: ScoredJob[], totalJobs?: number): string {
    // 日本時間で秒まで含む詳細な時刻を取得
    const now = new Date();
    const jstOffset = 9 * 60; // JST = UTC+9
    const jstTime = new Date(now.getTime() + jstOffset * 60 * 1000);
    const currentDateTime = jstTime.toISOString().replace('T', ' ').replace('Z', '').substring(0, 19) + ' JST';

    let markdown = `# Webエンジニア向けおすすめ案件ランキング（時給${PROPOSAL_GENERATION_MIN_HOURLY_RATE}円以上）\n\n`;
    markdown += `> **生成日時**: ${currentDateTime}  \n`;
    markdown += `> 評価基準: 係数システム（時給×${EVALUATION_COEFFICIENTS.HOURLY} + 工数×${EVALUATION_COEFFICIENTS.WORKLOAD} + スキル適性×${EVALUATION_COEFFICIENTS.SKILL_FIT}）  \n`;
    markdown += `> 対象者: 高スキルWebエンジニア（デザインスキル低め）  \n`;
    markdown += `> 最高得点: ${Math.max(...jobs.map(j => j.recommendation_score))}点  \n`;
    markdown += `> 表示件数: ${jobs.length}件（全${totalJobs || jobs.length}件から時給${PROPOSAL_GENERATION_MIN_HOURLY_RATE}円以上を抽出）\n\n`;

    markdown += `## 👨‍💻 対象スキルプロフィール\n\n`;
    markdown += `- **高スキルWebエンジニア**（フロントエンド・バックエンド両方）\n`;
    markdown += `- **得意分野**: プログラミング・システム開発・API連携・DB設計・パフォーマンス最適化\n`;
    markdown += `- **苦手分野**: グラフィックデザイン・UI/UXデザイン（CSSスタイリング程度なら対応可能）\n\n`;

    markdown += `## 📊 評価基準の詳細\n\n`;
    markdown += `### 💰 時給スコア（係数：${EVALUATION_COEFFICIENTS.HOURLY}）\n`;
    markdown += `- 4000円以上: 10点 → ${10 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 3500円以上: 9点 → ${9 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 3000円以上: 8点 → ${8 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 2500円以上: 7点 → ${7 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 2000円以上: 6点 → ${6 * EVALUATION_COEFFICIENTS.HOURLY}点\n\n`;

    markdown += `### ⏰ 工数スコア（係数：${EVALUATION_COEFFICIENTS.WORKLOAD}）\n`;
    markdown += `- 20-80時間: 10点 → ${10 * EVALUATION_COEFFICIENTS.WORKLOAD}点（最適な工数）\n`;
    markdown += `- 10-120時間: 8点 → ${8 * EVALUATION_COEFFICIENTS.WORKLOAD}点（良い範囲）\n`;
    markdown += `- 5-160時間: 6点 → ${6 * EVALUATION_COEFFICIENTS.WORKLOAD}点（許容範囲）\n\n`;

    markdown += `### 🧠 スキル適性スコア（係数：${EVALUATION_COEFFICIENTS.SKILL_FIT}）\n`;
    markdown += `- 10点: 技術力を最大限活かせる案件（システム開発、API連携、パフォーマンス改善等）\n`;
    markdown += `- 8-9点: 技術スキルが重要な案件（WordPressカスタマイズ、EC機能開発等）\n`;
    markdown += `- 6-7点: 技術とデザインが半々（既存サイト修正、簡単なスタイリング等）\n`;
    markdown += `- 4-5点: デザイン要素が多い（レイアウト作成、ビジュアル重視等）\n`;
    markdown += `- 1-3点: 純粋なデザイン案件（グラフィック制作、UI/UXデザイン等）\n`;
    markdown += `- 0点: 完全にスキル外（イラスト制作、動画編集等）\n\n`;

    markdown += `## 🔧 係数の意味\n\n`;
    markdown += `- **時給係数 ${EVALUATION_COEFFICIENTS.HOURLY}**: 収益性重視\n`;
    markdown += `- **工数係数 ${EVALUATION_COEFFICIENTS.WORKLOAD}**: 適度な作業量をバランス評価\n`;
    markdown += `- **スキル適性係数 ${EVALUATION_COEFFICIENTS.SKILL_FIT}**: スキル適性を最重視（技術案件を優遇）\n`;
    markdown += `- **難易度**: 参考情報として表示（点数計算には含めない）\n\n`;

    const maxScore = (10 * EVALUATION_COEFFICIENTS.HOURLY) + (10 * EVALUATION_COEFFICIENTS.WORKLOAD) + (10 * EVALUATION_COEFFICIENTS.SKILL_FIT);
    markdown += `**最高理論値**: ${10 * EVALUATION_COEFFICIENTS.HOURLY} + ${10 * EVALUATION_COEFFICIENTS.WORKLOAD} + ${10 * EVALUATION_COEFFICIENTS.SKILL_FIT} = ${maxScore}点\n\n`;

    markdown += `## 🏆 ランキング\n\n`;

    jobs.forEach((job, index) => {
        const rank = index + 1;
        markdown += `### ${rank}位: ${job.recommendation_score}点 - ${job.original_title || job.title}\n\n`;
        markdown += `**💰 想定時給:** ${job.hourly_rate_numeric.toLocaleString()}円  \n`;
        markdown += `**🎯 難易度:** ${job.難易度}  \n`;
        markdown += `**⏰ 見積工数:** ${job.工数_見積もり}  \n`;
        markdown += `**🧠 スキル適性:** ${job.skill_fit_score?.toFixed(1)}点/10点  \n`;
        markdown += `**🏷️ カテゴリ:** ${job.category}  \n`;
        markdown += `**🔗 案件URL:** ${job.link}\n\n`;

        // 提案金額と納期を追加
        if (job.proposal_amount && job.delivery_estimate) {
            markdown += `**💴 提案金額:** ${job.proposal_amount.toLocaleString()}円  \n`;
            markdown += `**📅 納期提案:** ${job.delivery_estimate}  \n\n`;
        }

        markdown += `**📝 分析概要:**  \n`;
        markdown += `${job.gpt_summary}\n\n`;

        if (job.skill_analysis) {
            markdown += `**🧠 スキル適性分析:**  \n`;
            markdown += `${job.skill_analysis}\n\n`;
        }

        // 提案文と質問を追加
        if (job.proposal_greeting && job.specification_questions) {
            markdown += `**💬 戦略的提案文:**  \n`;
            markdown += `${job.proposal_greeting}\n\n`;

            markdown += `**❓ 仕様確認質問:**  \n`;
            markdown += `${job.specification_questions}\n\n`;
        }

        markdown += `---\n\n`;
    });

    // 案件一覧を表形式で出力
    if (jobs.length > 0) {
        markdown += `\n## 💴 案件一覧（時給${PROPOSAL_GENERATION_MIN_HOURLY_RATE}円以上）\n\n`;
        markdown += `| 案件名 | 提案金額 | 納期提案 | 提案文（抜粋） |\n`;
        markdown += `|---|---|---|---|\n`;
        jobs.forEach(job => {
            const title = job.original_title || job.title || '案件名不明';
            const amount = job.proposal_amount?.toLocaleString() || '要相談';
            const delivery = job.delivery_estimate || '要相談';
            const greeting = (job.proposal_greeting || '').replace(/\n/g, ' ').substring(0, 80);
            markdown += `| [${title}](${job.link}) | ${amount}円 | ${delivery} | ${greeting}... |\n`;
        });
        markdown += `\n`;
    }

    return markdown;
}

// 全案件用のMarkdown生成関数
function generateAllJobsMarkdown(jobs: ScoredJob[]): string {
    // 日本時間で秒まで含む詳細な時刻を取得
    const now = new Date();
    const jstOffset = 9 * 60; // JST = UTC+9
    const jstTime = new Date(now.getTime() + jstOffset * 60 * 1000);
    const currentDateTime = jstTime.toISOString().replace('T', ' ').replace('Z', '').substring(0, 19) + ' JST';

    let markdown = `# 全案件ランキング（おすすめ度順）\n\n`;
    markdown += `> **生成日時**: ${currentDateTime}  \n`;
    markdown += `> 評価基準: 係数システム（時給×${EVALUATION_COEFFICIENTS.HOURLY} + 工数×${EVALUATION_COEFFICIENTS.WORKLOAD} + スキル適性×${EVALUATION_COEFFICIENTS.SKILL_FIT}）  \n`;
    markdown += `> 対象者: 高スキルWebエンジニア（デザインスキル低め）  \n`;
    markdown += `> 最高得点: ${Math.max(...jobs.map(j => j.recommendation_score))}点  \n`;
    markdown += `> 総案件数: ${jobs.length}件（提案文生成対象外の案件も含む）\n\n`;

    // 時給分布を表示
    const hourlyRateDistribution = jobs.reduce((acc, job) => {
        const rate = job.hourly_rate_numeric;
        if (rate >= 4000) acc['4000円以上']++;
        else if (rate >= 3500) acc['3500円以上']++;
        else if (rate >= 3000) acc['3000円以上']++;
        else if (rate >= 2500) acc['2500円以上']++;
        else if (rate >= 2000) acc['2000円以上']++;
        else if (rate >= 1500) acc['1500円以上']++;
        else if (rate >= 1000) acc['1000円以上']++;
        else acc['1000円未満']++;
        return acc;
    }, {
        '4000円以上': 0,
        '3500円以上': 0,
        '3000円以上': 0,
        '2500円以上': 0,
        '2000円以上': 0,
        '1500円以上': 0,
        '1000円以上': 0,
        '1000円未満': 0
    });

    markdown += `## 📊 時給分布\n\n`;
    Object.entries(hourlyRateDistribution).forEach(([range, count]) => {
        if (count > 0) {
            markdown += `- ${range}: ${count}件\n`;
        }
    });
    markdown += `\n`;

    markdown += `## 🏆 全案件ランキング\n\n`;

    jobs.forEach((job, index) => {
        const rank = index + 1;
        markdown += `### ${rank}位: ${job.recommendation_score}点 - ${job.original_title || job.title}\n\n`;
        markdown += `**💰 想定時給:** ${job.hourly_rate_numeric.toLocaleString()}円  \n`;
        markdown += `**🎯 難易度:** ${job.難易度}  \n`;
        markdown += `**⏰ 見積工数:** ${job.工数_見積もり}  \n`;
        markdown += `**🧠 スキル適性:** ${job.skill_fit_score?.toFixed(1)}点/10点  \n`;
        markdown += `**🏷️ カテゴリ:** ${job.category}  \n`;
        markdown += `**🔗 案件URL:** ${job.link}\n\n`;

        markdown += `**📝 分析概要:**  \n`;
        markdown += `${job.gpt_summary}\n\n`;

        if (job.skill_analysis) {
            markdown += `**🧠 スキル適性分析:**  \n`;
            markdown += `${job.skill_analysis}\n\n`;
        }

        // 提案文がある場合のみ表示（時給3000円以上の案件）
        if (job.proposal_greeting && job.specification_questions) {
            markdown += `**💬 戦略的提案文:**  \n`;
            markdown += `${job.proposal_greeting}\n\n`;

            markdown += `**❓ 仕様確認質問:**  \n`;
            markdown += `${job.specification_questions}\n\n`;

            if (job.proposal_amount && job.delivery_estimate) {
                markdown += `**💴 提案金額:** ${job.proposal_amount.toLocaleString()}円  \n`;
                markdown += `**📅 納期提案:** ${job.delivery_estimate}  \n\n`;
            }
        } else {
            markdown += `**💡 注意:** この案件は時給${PROPOSAL_GENERATION_MIN_HOURLY_RATE}円未満のため、提案文は生成されていません。\n\n`;
        }

        markdown += `---\n\n`;
    });

    // 案件一覧を表形式で出力
    if (jobs.length > 0) {
        markdown += `\n## 📋 案件一覧（全${jobs.length}件）\n\n`;
        markdown += `| 順位 | 案件名 | 時給 | おすすめ度 | カテゴリ |\n`;
        markdown += `|---|---|---|---|---|\n`;
        jobs.forEach((job, index) => {
            const rank = index + 1;
            const title = job.original_title || job.title || '案件名不明';
            const hourlyRate = job.hourly_rate_numeric.toLocaleString() + '円';
            const score = job.recommendation_score;
            const category = job.category || 'N/A';
            markdown += `| ${rank} | [${title.substring(0, 40)}...](${job.link}) | ${hourlyRate} | ${score}点 | ${category} |\n`;
        });
        markdown += `\n`;
    }

    return markdown;
}

// GPTで提案用挨拶文と仕様質問を生成する関数
async function generateProposalContent(job: AnalysisResult, originalJob: any): Promise<{ greeting: string; delivery_estimate: string; questions: string }> {
    const prompt = `以下のクラウドワークス案件について、下記3点を日本語で出力してください。

【案件情報】
タイトル: ${job.title}
詳細説明: ${originalJob?.detailedDescription || '詳細不明'}
想定時給: ${job.想定時給}
見積工数: ${job.工数_見積もり}
難易度: ${job.難易度}

【出力内容】
1. 戦略的提案文（プロフェッショナルで親しみやすい、簡潔な自己紹介・案件への取り組み姿勢 2-3行）
2. 納期見込み（何日で納品できそうか。根拠も1文で）
3. 仕様確認質問（案件を確実に成功させるための具体的な質問を3-5個）

【提案文のポイント】
- 経験と専門性をアピール
- 案件への真剣な取り組み姿勢を示す
- クライアントの課題解決に焦点

【出力フォーマット】
提案文:
<プロフェッショナルで簡潔な提案文>

納期見込み:
<例: 10日（要件定義・修正対応含む）>

質問:
1. <質問1>
2. <質問2>
3. <質問3>
4. <質問4>
5. <質問5>`;

    try {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは経験豊富なフリーランサーで、クラウドワークス案件への効果的な提案文作成の専門家です。クライアントの信頼を得て、案件を受注するための戦略的なコミュニケーションに長けています。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 800,
            temperature: 0.3,
        });

        const text = res.choices[0]?.message?.content || '';

        // 提案文、納期見込み、質問を分離
        const greetingMatch = text.match(/提案文[:：]\s*([\s\S]*?)(?=納期見込み[:：]|$)/);
        const deliveryMatch = text.match(/納期見込み[:：]\s*([\s\S]*?)(?=質問[:：]|$)/);
        const questionsMatch = text.match(/質問[:：]\s*([\s\S]*)/);

        const greeting = greetingMatch?.[1]?.trim() || '';
        const delivery_estimate = deliveryMatch?.[1]?.trim() || '';
        const questions = questionsMatch?.[1]?.trim() || '';

        return { greeting, delivery_estimate, questions };
    } catch (e) {
        console.error(`❌ 提案文・納期・質問生成エラー (${job.jobId}):`, e);
        return { greeting: '', delivery_estimate: '', questions: '' };
    }
}

// GPTでスキル適性を評価する関数
async function analyzeSkillFit(job: AnalysisResult, originalJob: any): Promise<{ score: number; analysis: string }> {
    const prompt = `以下のクラウドワークス案件を、高スキルWebエンジニアの視点で評価してください。

【依頼者のスキルプロフィール】
- 高スキルWebエンジニア（フロントエンド・バックエンド両方）
- プログラミング・システム開発・API連携が得意
- データベース設計・パフォーマンス最適化などの技術力高い
- デザインスキルは低い（グラフィックデザイン・UI/UXデザインは苦手）
- CSSスタイリング程度なら対応可能

【案件情報】
タイトル: ${job.title}
詳細説明: ${originalJob?.detailedDescription || '詳細不明'}
カテゴリ: ${job.category}
難易度: ${job.難易度}

【評価基準】
スキル適性スコア（0-10点）:
- 10点: 技術力を最大限活かせる案件（システム開発、API連携、パフォーマンス改善等）
- 8-9点: 技術スキルが重要な案件（WordPressカスタマイズ、EC機能開発等）
- 6-7点: 技術とデザインが半々（既存サイト修正、簡単なスタイリング等）
- 4-5点: デザイン要素が多い（レイアウト作成、ビジュアル重視等）
- 1-3点: 純粋なデザイン案件（グラフィック制作、UI/UXデザイン等）
- 0点: 完全にスキル外（イラスト制作、動画編集等）

【出力フォーマット】
スコア: <0-10の数値>
分析: <なぜそのスコアなのか、技術的な観点での評価理由を2-3行で>`;

    try {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは技術人材のスキルマッチング専門家で、Webエンジニアの技術力と案件要件を正確に評価できます。デザインスキルの有無を考慮した実用的な評価を行います。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 300,
            temperature: 0.2,
        });

        const text = res.choices[0]?.message?.content || '';

        // スコアと分析を分離
        const scoreMatch = text.match(/スコア[:：]\s*([0-9.]+)/);
        const analysisMatch = text.match(/分析[:：]\s*([\s\S]*)/);

        const score = scoreMatch?.[1] ? parseFloat(scoreMatch[1]) : 5;
        const analysis = analysisMatch?.[1]?.trim() || '';

        return { score: Math.max(0, Math.min(10, score)), analysis };
    } catch (e) {
        console.error(`❌ スキル適性分析エラー (${job.jobId}):`, e);
        return { score: 5, analysis: '分析エラー' };
    }
}

// 実行
(async () => {
    await main();
})();
</file>

<file path="readme.md">
# CrowdWorks 自動化システム

## メモ
とりあえず、指定件数データを取って、ざっくりの時給と、工数と、提案文を自動生成できるようになった
かかった日数は一日
とりあえず回せるようにはなったので、調整しながら進める

[![CI/CD Pipeline](https://github.com/masayuki-akinari/crowdworks-search/actions/workflows/ci.yml/badge.svg)](https://github.com/masayuki-akinari/crowdworks-search/actions/workflows/ci.yml)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.6.3-blue.svg)](https://www.typescriptlang.org/)
[![AWS CDK](https://img.shields.io/badge/AWS%20CDK-2.170.0-orange.svg)](https://aws.amazon.com/cdk/)

## 📋 概要

CrowdWorksとUpworkの案件情報を自動収集・AI評価し、高時給案件をレポート出力するサーバーレスシステムです。

### 🚀 主要機能
- **統合ジョブサーチ**: CrowdWorks + Upworkの統合案件検索
- **自動スクレイピング**: Playwright + Chromiumによる15分間隔実行
- **AI評価**: OpenAI GPT-4による案件品質評価
- **高時給フィルタリング**: 時給一定以上の案件自動抽出
- **詳細レポート**: Markdown/JSON形式での自動レポート生成
- **スマート通知**: 高評価案件の即座メール送信
- **コスト最適化**: 月額$5以下での運用

### 🏗️ アーキテクチャ

```mermaid
graph TB
    A[EventBridge] -->|15分間隔| B[Lambda Function]
    B -->|スクレイピング| C[CrowdWorks]
    B -->|AI評価| D[OpenAI API]
    B -->|データ保存| E[S3 Bucket]
    B -->|高評価通知| F[SNS/SES]
    G[CloudWatch] -->|監視| B
```

**技術スタック:**
- **実行環境**: AWS Lambda (コンテナイメージ)
- **ブラウザ自動化**: Playwright + Chromium
- **AI評価**: OpenAI GPT-4 API
- **データストレージ**: Amazon S3
- **通知**: Amazon SNS/SES
- **スケジューリング**: Amazon EventBridge
- **インフラ**: AWS CDK (TypeScript)

## ⚠️ **重要: Playwright Lambda制約と対応**

### 技術的課題
- **Lambda ZIP制限**: 250MB（Playwright: ~300MB）
- **ブラウザバイナリ**: Chromium単体で200MB+

### ✅ **採用方針: Lambdaコンテナイメージ**

**選択理由:**
- ✅ **容量制限**: 10GBまで対応（ZIP: 250MB → Container: 10GB）
- ✅ **完全機能**: フルPlaywright + Chromium環境
- ✅ **パフォーマンス**: ZIP版と同等の起動時間
- ✅ **開発効率**: 既存Dockerfileを活用可能
- ✅ **運用コスト**: 月$5-10での動作確認済み

```dockerfile
# 現在のDockerfile構成
FROM mcr.microsoft.com/playwright/python:v1.45.0-jammy
# → Lambda Container Imageとして活用
```

## 🚀 クイックスタート

### 1. 前提条件
```bash
# 必要なツール
- Node.js 18+
- AWS CLI v2
- Docker Desktop
- AWS CDK CLI
```

### 2. 環境セットアップ
```bash
# リポジトリクローン
git clone https://github.com/masayuki-akinari/crowdworks-search.git
cd crowdworks-search

# 依存関係インストール
npm install

# 環境変数設定
cp env.example .env
# .envファイルを編集してAPI認証情報を設定

# ランサーズ自動ログイン設定（オプション）
# プロジェクトルートに.envファイルを作成し、以下を追加：
# LANCERS_EMAIL=your-lancers-email@example.com
# LANCERS_PASSWORD=your-lancers-password

# AWS認証情報設定
aws configure

# CDK初期化（初回のみ）
npx cdk bootstrap
```

### 3. 新機能: 統合ジョブサーチ
```bash
# 基本的な統合検索実行（最低時給3000円）
npm run integrated-search

# 高時給案件検索（最低時給4000円）
npm run search:high-rate

# 開発者向け案件検索（React, TypeScript等）
npm run search:dev

# カスタム検索
npm run integrated-search -- --min-rate 5000 --max-jobs 30 --keywords "nodejs,aws"
```

### 3. **コンテナイメージ版デプロイ（推奨）**
```bash
# ビルド & デプロイ
npm run cdk:deploy

# または手動での段階実行
docker build -t crowdworks-searcher .
npx cdk deploy --context deployMethod=container
```

### 4. 設定
```bash
# AWS Parameter Storeにシークレット設定
aws ssm put-parameter \
  --name "/crowdworks-search/openai-api-key" \
  --value "your-openai-api-key" \
  --type "SecureString"

aws ssm put-parameter \
  --name "/crowdworks-search/crowdworks-email" \
  --value "your-crowdworks-email" \
  --type "SecureString"
```

## 📊 システム仕様

### 実行スペック
```yaml
Lambda仕様:
  デプロイ形式: Container Image (ECR)
  メモリ: 3,008 MB
  タイムアウト: 15分
  アーキテクチャ: x86_64
  
Playwright設定:
  ブラウザ: Chromium (フル版)
  ヘッドレスモード: true
  実行間隔: 15分
```

### コスト構造（月額）
```yaml
Lambda実行:
  1,000回/月 × 10秒: $2-5
ECRストレージ: 
  1GB Docker Image: $0.10
CloudWatch:
  ログ & 監視: $2-3
OpenAI API:
  GPT-4呼び出し: $1-2
合計: $5-10/月
```

## 🔧 開発・デバッグ

### ローカル開発
```bash
# TypeScript開発モード
npm run dev

# Dockerでのテスト
npm run docker:build
npm run docker:run

# ローカルPlaywright実行
npx playwright install chromium
npm run test:e2e
```

## 📚 統合ジョブサーチの使用方法

### 基本コマンド
```bash
# 全てのオプション表示
npm run integrated-search -- --help

# 基本検索（最低時給3000円、最大50件/サイト）
npm run integrated-search

# 条件指定検索
npm run integrated-search -- --min-rate 4000 --max-jobs 30

# カテゴリ指定検索
npm run integrated-search -- --categories "web,mobile"

# キーワード検索
npm run integrated-search -- --keywords "react,typescript,nodejs"

# 出力形式指定
npm run integrated-search -- --format markdown
```

### 環境変数設定
```bash
# Upwork API認証（必須）
UPWORK_CONSUMER_KEY=your_consumer_key
UPWORK_CONSUMER_SECRET=your_consumer_secret
UPWORK_ACCESS_TOKEN=your_access_token    # オプション
UPWORK_ACCESS_TOKEN_SECRET=your_secret   # オプション

# OpenAI API（AI分析用）
OPENAI_API_KEY=your_openai_api_key
```

### 出力ファイル
実行後、`output/`ディレクトリに以下のファイルが生成されます：

- `integrated-job-report-YYYY-MM-DD.json` - JSON形式の詳細レポート
- `integrated-job-report-YYYY-MM-DD.md` - Markdown形式のサマリーレポート  
- `high-value-jobs-YYYY-MM-DD.md` - 高時給案件の詳細レポート

### レポート内容
- **CrowdWorks**: 既存スクレイピング機能による案件取得
- **Upwork**: API経由での案件取得（モック実装）
- **通貨変換**: USD→JPY自動変換（現在レート: 1USD = 150JPY）
- **フィルタリング**: 時給一定以上の案件自動抽出
- **AI分析**: 市場動向とおすすめ案件の分析

### ログ確認
```bash
# CloudWatch Logs確認
aws logs tail /aws/lambda/crowdworks-searcher-main --follow

# Lambda実行状況確認
aws lambda invoke \
  --function-name crowdworks-searcher-main \
  --payload '{}' \
  response.json
```

## 🛠️ 代替アプローチ: 軽量版

**予算最優先の場合:**
```typescript
// @sparticuz/chromium使用（軽量版）
import { chromium } from 'playwright-core';
import chromium_binary from '@sparticuz/chromium';

const browser = await chromium.launch({
  args: [...chromium_binary.args, '--no-sandbox'],
  executablePath: await chromium_binary.executablePath()
});
```

**制約:**
- 機能制限あり（軽量Chromium）
- Lambda Layer必要
- デバッグ困難

## 📚 ドキュメント

### 設計書
- [📋 実装計画書](./docs/05_implementation_plan.md)
- [🏗️ アーキテクチャ設計](./docs/01_architecture.md)
- [🔧 CI/CD セットアップ](./docs/CI_CD_SETUP.md)

### 運用ガイド
- [🚀 デプロイガイド](./docs/02_deployment.md)
- [📊 監視・アラート](./docs/03_monitoring.md)
- [🛡️ セキュリティ](./docs/04_security.md)

デプロイガイドでは、前提条件の確認から `cdk bootstrap`、`npm run cdk:deploy` の実行までを整理しています。さらに、CI/CDパイプラインによる自動デプロイ方法も紹介しています。

## 🎯 現在の開発状況

### ✅ 完了済み
- [x] CI/CDパイプライン構築
- [x] TypeScript + CDK基盤
- [x] Docker環境整備
- [x] Playwright Lambda対応策策定

### 🔄 進行中
- [ ] **ブラウザ環境動作確認**（最優先）
- [ ] CrowdWorksスクレイピング実装
- [ ] OpenAI API連携

### 📋 今後の予定
- [ ] S3データ保存機能
- [ ] メール通知システム
- [ ] エラー監視・アラート

## 🚨 既知の制約・注意事項

### Playwright制約
- ❌ **Lambda ZIP版**: 確実に容量制限超過
- ✅ **Container版**: 動作確認済み、推奨
- ⚠️ **軽量版**: 機能制限あり、予算重視向け

### CrowdWorks制約
- **利用規約遵守**: 過度なアクセス禁止
- **レート制限**: 15分間隔での穏健な実行
- **仕様変更リスク**: サイト変更への対応必要

### コスト制約
- **月額目標**: $5以下
- **実測値**: コンテナ版で$5-10
- **監視**: AWS Cost Explorer設定済み

## 🤝 コントリビューション

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

### コード品質基準
- TypeScript strict mode必須
- any型使用禁止
- 80%以上のテストカバレッジ
- ESLint + Prettierルール遵守

## 📄 ライセンス

MIT License - 詳細は [LICENSE](./LICENSE) ファイルを参照

## 📞 サポート

- **Issue報告**: [GitHub Issues](https://github.com/masayuki-akinari/crowdworks-search/issues)
- **質問・相談**: [GitHub Discussions](https://github.com/masayuki-akinari/crowdworks-search/discussions)

---

**⚡ 次のアクション**: [実装計画書](./docs/05_implementation_plan.md) で詳細な開発ロードマップを確認してください。

npm run full-analysis:quick
とりあえず実行用コマンド
</file>

<file path="package.json">
{
    "name": "crowdworks-search",
    "version": "1.0.0",
    "description": "クラウドワークス案件自動検索・評価システム",
    "main": "dist/index.js",
    "scripts": {
        "build": "tsc",
        "start": "node dist/index.js",
        "test": "echo \"Error: no test specified\" && exit 1",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        
        "handler": "npx ts-node -r dotenv/config src/lambda/handler.ts",
        "h": "npm run handler",
        
        "auto": "npx ts-node scripts/full-pipeline.ts 3000 10",
        "auto:quick": "npx ts-node scripts/full-pipeline.ts 2000 5",
        "auto:premium": "npx ts-node scripts/full-pipeline.ts 5000 15",
        
        "analysis": "npx ts-node scripts/create-unified-report.ts 3000",
        "analysis:quick": "npx ts-node scripts/create-unified-report.ts 1000", 
        "analysis:premium": "npx ts-node scripts/create-unified-report.ts 5000"
    },
    "keywords": [
        "crowdworks",
        "automation",
        "scraping",
        "aws",
        "serverless",
        "typescript"
    ],
    "author": "Your Name",
    "license": "MIT",
    "private": true,
    "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
    },
    "dependencies": {
        "@aws-sdk/client-lambda": "^3.450.0",
        "@aws-sdk/client-s3": "^3.450.0",
        "@aws-sdk/client-sns": "^3.450.0",
        "@aws-sdk/client-ssm": "^3.540.0",
        "aws-cdk-lib": "^2.156.0",
        "aws-lambda": "^1.0.7",
        "aws-sdk": "^2.1691.0",
        "constructs": "^10.3.0",
        "dotenv": "^16.5.0",
        "openai": "^4.50.0",
        "playwright": "^1.48.2",
        "source-map-support": "^0.5.21",
        "typescript": "^5.6.3",
        "zod": "^3.22.0"
    },
    "devDependencies": {
        "@types/aws-lambda": "^8.10.145",
        "@types/jest": "^29.5.14",
        "@types/node": "^22.9.1",
        "@typescript-eslint/eslint-plugin": "^8.14.0",
        "@typescript-eslint/parser": "^8.14.0",
        "aws-cdk": "^2.170.0",
        "cross-env": "^7.0.3",
        "esbuild": "^0.24.0",
        "eslint": "^9.14.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-prettier": "^5.2.1",
        "husky": "^8.0.0",
        "jest": "^29.7.0",
        "lint-staged": "^15.0.0",
        "nock": "^13.3.0",
        "nodemon": "^3.1.7",
        "prettier": "^3.3.3",
        "ts-jest": "^29.2.5",
        "ts-node": "^10.9.2",
        "tsconfig-paths": "^4.2.0"
    },
    "husky": {
        "hooks": {
            "pre-commit": "lint-staged",
            "pre-push": "npm run type-check && npm run test"
        }
    },
    "lint-staged": {
        "src/**/*.{ts,tsx}": [
            "eslint --fix",
            "prettier --write",
            "git add"
        ]
    }
}
</file>

<file path="src/lambda/handler.ts">
/**
 * AWS Lambda Handler for CrowdWorks Search System
 * スクレイピング + AI分析の統合システム
 */

// ローカル開発時の環境変数読み込み
if (!process.env['AWS_LAMBDA_FUNCTION_NAME']) {
  try {
    require('dotenv').config();
    console.log('🏠 ローカル環境: .envファイルを読み込みました');
  } catch (error) {
    console.log('⚠️ dotenvが見つかりません（Lambda環境では正常）');
  }
}

import { Context } from 'aws-lambda';
import { chromium, Browser, Page } from 'playwright';
import { LancersService, LancersJob, LancersJobDetail, LancersScrapingResult } from '../services/LancersService';

// Lambda Event Types
interface ScheduledExecutionEvent {
  source: string;
  'detail-type': string;
  detail: Record<string, any>;
  time?: string;
}

interface ScheduledExecutionResponse {
  statusCode: number;
  body: string;
  executionTime: number;
  timestamp: string;
}

// CrowdWorks案件データ型
interface CrowdWorksJob {
  id: string;
  title: string;
  description: string;
  url: string;
  budget: {
    type: 'fixed' | 'hourly' | 'unknown';
    amount: number;
    currency: string;
  };
  category: string;
  tags: string[];
  client: {
    name: string;
    rating: number;
    reviewCount: number;
  };
  postedAt: string;
  deadline?: string;
  applicants: number;
  scrapedAt: string;
}

// スクレイピング結果型
interface ScrapingResult {
  success: boolean;
  jobsFound: number;
  jobs: CrowdWorksJob[];
  error?: string;
  executionTime: number;
}

// 案件詳細情報の型定義
interface CrowdWorksJobDetail {
  jobId: string;
  title: string;
  category: string;
  url: string;
  paymentType: string;
  budget: string;
  deliveryDate: string;
  postDate: string;
  applicationDeadline: string;
  desiredImages: string[];
  applicantCount: number;
  contractCount: number;
  recruitmentCount: number;
  favoriteCount: number;
  detailedDescription: string;
  client: {
    name: string;
    url: string;
    overallRating: string;
    orderHistory: string;
    completionRate: string;
    thankCount: string;
    identityVerified: boolean;
    orderRuleCheck: boolean;
    description: string;
  };
  recentApplicants: Array<{
    name: string;
    url: string;
    applicationDate: string;
  }>;
  scrapedAt: string;
}

// ファイル読み込み用ユーティリティ
async function readFileAsync(filePath: string): Promise<string | null> {
  return new Promise((resolve) => {
    const fs = require('fs');
    fs.readFile(filePath, 'utf8', (err: any, data: string) => {
      if (err) resolve(null);
      else resolve(data);
    });
  });
}

/**
 * カテゴリ別CrowdWorks案件スクレイピング（メイン機能）
 */
async function scrapeCrowdWorksJobsByCategory(
  page: Page,
  category: string,
  maxJobs: number = 20
): Promise<ScrapingResult> {
  const startTime = Date.now();

  try {
    const categoryUrls: { [key: string]: string } = {
      'ec': 'https://crowdworks.jp/public/jobs/group/ec',
      'web_products': 'https://crowdworks.jp/public/jobs/group/web_products',
      'software_development': 'https://crowdworks.jp/public/jobs/group/software_development',
      'development': 'https://crowdworks.jp/public/jobs/group/development',
      'writing': 'https://crowdworks.jp/public/jobs/category/141',
      'translation': 'https://crowdworks.jp/public/jobs/category/406',
      'marketing': 'https://crowdworks.jp/public/jobs/category/539',
      'system_development': 'https://crowdworks.jp/public/jobs/group/development',
      'app_development': 'https://crowdworks.jp/public/jobs/group/software_development'
    };

    const baseUrl = categoryUrls[category];
    if (!baseUrl) {
      throw new Error(`未知のカテゴリ: ${category}`);
    }

    console.log(`📂 カテゴリ「${category}」のスクレイピング開始 (最大${maxJobs}件)`);

    const jobs: CrowdWorksJob[] = [];
    let currentPage = 1;
    let consecutiveEmptyPages = 0;
    const maxConsecutiveEmptyPages = 3;
    const maxPages = Math.ceil(maxJobs / 20) + 2; // 1ページ約20件として計算し、余裕をもたせる

    while (jobs.length < maxJobs && currentPage <= maxPages && consecutiveEmptyPages < maxConsecutiveEmptyPages) {
      const pageUrl = currentPage === 1 ? baseUrl : `${baseUrl}?page=${currentPage}`;
      console.log(`📄 ページ ${currentPage} を処理中: ${pageUrl}`);

      try {
        await page.goto(pageUrl, { waitUntil: 'networkidle', timeout: 30000 });
        await page.waitForTimeout(2000); // ページロード後の待機

        // 案件リストの取得
        const pageJobs = await page.evaluate(() => {
          // 実際のDOM構造に合わせたセレクタ
          const jobListContainer = document.querySelector('main list, [role="list"], ul:has(li h3)');
          if (!jobListContainer) {
            console.log('案件リスト容器が見つかりません');
            return [];
          }

          const jobElements = jobListContainer.querySelectorAll('listitem, [role="listitem"], li:has(h3)');
          console.log(`取得した案件要素数: ${jobElements.length}`);
          
          const pageJobs: any[] = [];

          jobElements.forEach((element: Element, index: number) => {
            try {
              // タイトルの取得
              let titleElement = element.querySelector('h3 a, [level="3"] a, heading a');
              let titleText = '';
              let jobUrl = '';
              
              if (titleElement) {
                titleText = titleElement.textContent?.trim() || '';
                jobUrl = (titleElement as HTMLAnchorElement).href || '';
              }

              // カテゴリーの取得（案件内のカテゴリーリンクから）
              let categoryElement = element.querySelector('a[href*="/category/"]');
              let categoryText = categoryElement?.textContent?.trim() || '';

              // 説明文の取得
              let descriptionElement = element.querySelector('paragraph, p');
              let descriptionText = descriptionElement?.textContent?.trim() || '';

              // 報酬情報の取得
              let priceText = '';
              const priceElements = element.querySelectorAll('generic');
              for (const generic of Array.from(priceElements)) {
                const text = generic.textContent?.trim() || '';
                if (text.includes('円') && (text.includes('〜') || text.includes('固定') || text.includes('時間'))) {
                  priceText = text;
                  break;
                }
              }

              // 契約数・応募期限の取得
              let contractsText = '';
              let deadlineText = '';
              for (const generic of Array.from(priceElements)) {
                const text = generic.textContent?.trim() || '';
                if (text.includes('契約数')) {
                  contractsText = text;
                } else if (text.includes('あと') && (text.includes('日') || text.includes('時間'))) {
                  deadlineText = text;
                }
              }

              // クライアント名の取得
              let clientElement = element.querySelector('a[href*="/employers/"]');
              let clientName = clientElement?.textContent?.trim() || '';

              // URLが相対パスの場合は絶対パスに変換
              if (jobUrl && jobUrl.startsWith('/')) {
                jobUrl = 'https://crowdworks.jp' + jobUrl;
              }

              // 必要な情報が取得できた場合のみ追加
              if (titleText && jobUrl) {
                console.log(`案件${index + 1}: ${titleText}`);
                pageJobs.push({
                  title: titleText,
                  url: jobUrl,
                  description: descriptionText.substring(0, 200), // 200文字で切り詰め
                  price: priceText,
                  client: clientName,
                  category: categoryText,
                  contracts: contractsText,
                  deadline: deadlineText,
                  scraped_at: new Date().toISOString()
                });
              } else {
                console.log(`案件${index + 1}: 必要な情報が不足 - title: ${titleText}, url: ${jobUrl}`);
              }
            } catch (error) {
              console.log(`案件${index + 1}の処理でエラー:`, error);
            }
          });

          console.log(`ページから取得された案件数: ${pageJobs.length}`);
          return pageJobs;
        });

        if (pageJobs.length === 0) {
          consecutiveEmptyPages++;
          console.log(`⚠️ ページ ${currentPage}: 案件が見つかりません (連続${consecutiveEmptyPages}回目)`);
        } else {
          consecutiveEmptyPages = 0;
          jobs.push(...pageJobs);
          console.log(`✅ ページ ${currentPage}: ${pageJobs.length}件取得 (累計: ${jobs.length}件)`);
        }

      } catch (error) {
        console.log(`❌ ページ ${currentPage} 処理エラー:`, error instanceof Error ? error.message : String(error));
        consecutiveEmptyPages++;
      }

      currentPage++;
    }

    // 最大件数に制限
    const limitedJobs = jobs.slice(0, maxJobs);
    const executionTime = Date.now() - startTime;

    console.log(`✅ カテゴリ「${category}」完了: ${limitedJobs.length}件取得 (${executionTime}ms)`);

    return {
      success: true,
      jobsFound: limitedJobs.length,
      jobs: limitedJobs,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`❌ カテゴリ「${category}」スクレイピングエラー:`, errorMessage);

    return {
      success: false,
      jobsFound: 0,
      jobs: [],
      error: errorMessage,
      executionTime
    };
  }
}

/**
 * 案件詳細スクレイピング
 */
export async function scrapeCrowdWorksJobDetail(page: Page, jobUrl: string): Promise<CrowdWorksJobDetail> {
  console.log(`🔍 詳細取得: ${jobUrl}`);

  try {
    await page.goto(jobUrl, { waitUntil: 'networkidle', timeout: 30000 });

    const detail = await page.evaluate(() => {
      const getNumbers = (text: string): number => {
        const match = text.match(/(\d+)/);
        return match?.[1] ? parseInt(match[1]) : 0;
      };

      // タイトルの取得（実際のDOM構造に基づく）
      const title = (() => {
        // メインのh1要素から抽出
        const h1 = document.querySelector('heading[level="1"]');
        if (h1) {
          const fullText = h1.textContent?.trim() || '';
          // "★★スーツケースベルトの推薦をしてくださる方を募集します★★ 商品紹介文作成の仕事の依頼"から案件名を抽出
          const jobMatch = fullText.split('の仕事の依頼')[0];
          if (jobMatch) {
            // さらに最後のカテゴリ名を除去
            const titleParts = jobMatch.split(' ');
            if (titleParts.length > 1) {
              // 最後の要素がカテゴリ名の場合は除去
              const lastPart = titleParts[titleParts.length - 1];
              if (lastPart && (lastPart.includes('作成') || lastPart.includes('開発') || lastPart.includes('運営'))) {
                titleParts.pop();
              }
            }
            return titleParts.join(' ').trim();
          }
        }
        return '';
      })();

      // テーブルから基本情報を取得（role="table"で検索）
      const tables = document.querySelectorAll('table, [role="table"]');
      let paymentType = '';
      let budget = '';
      let deliveryDate = '';
      let postDate = '';
      let applicationDeadline = '';
      let applicantCount = 0;
      let contractCount = 0;
      let recruitmentCount = 0;
      let favoriteCount = 0;
      
      // 仕事の概要テーブル（1番目）から取得
      if (tables.length > 0) {
        const conceptTable = tables[0];
        if (conceptTable) {
          // rowで検索してセル情報を取得
          const rows = conceptTable.querySelectorAll('row, tr, [role="row"]');
          rows.forEach(row => {
            const cells = row.querySelectorAll('cell, td, [role="cell"]');
            if (cells.length >= 2) {
              const label = cells[0]?.textContent?.trim() || '';
              const value = cells[1]?.textContent?.trim() || '';
              
              if (label.includes('固定報酬制') || label.includes('時間単価')) {
                paymentType = label;
                budget = value;
              } else if (label.includes('納品希望日')) {
                deliveryDate = value;
              } else if (label.includes('掲載日')) {
                postDate = value;
              } else if (label.includes('応募期限')) {
                applicationDeadline = value;
              }
            }
          });
        }
      }

      // 応募状況テーブル（2番目）から取得
      if (tables.length > 1) {
        const statusTable = tables[1];
        if (statusTable) {
          const rows = statusTable.querySelectorAll('row, tr, [role="row"]');
          rows.forEach(row => {
            const cells = row.querySelectorAll('cell, td, [role="cell"]');
            if (cells.length >= 2) {
              const label = cells[0]?.textContent?.trim() || '';
              const value = cells[1]?.textContent?.trim() || '';
              
              if (label.includes('応募した人')) {
                applicantCount = getNumbers(value);
              } else if (label.includes('契約した人')) {
                contractCount = getNumbers(value);
              } else if (label.includes('募集人数')) {
                recruitmentCount = getNumbers(value);
              } else if (label.includes('気になる')) {
                favoriteCount = getNumbers(value);
              }
            }
          });
        }
      }

      // 詳細説明の取得（仕事の詳細テーブルから）
      let detailedDescription = '';
      if (tables.length > 2) {
        const detailTable = tables[2];
        if (detailTable) {
          const rows = detailTable.querySelectorAll('row, tr, [role="row"]');
          if (rows.length > 0) {
            const firstRow = rows[0];
            if (firstRow) {
              const cell = firstRow.querySelector('cell, td, [role="cell"]');
              if (cell) {
                detailedDescription = cell.textContent?.trim() || '';
              }
            }
          }
        }
      }

      // クライアント情報の取得（正確なセレクタで）
      let clientName = '';
      let clientUrl = '';
      let overallRating = '';
      let orderHistory = '';
      let completionRate = '';
      let thankCount = '';
      let identityVerified = false;
      let orderRuleCheck = false;
      let clientDescription = '';

      // クライアント名とURLの取得
      const clientLink = document.querySelector('link[href*="employers"]:not([href*="user_occupations"])');
      if (clientLink) {
        clientName = clientLink.textContent?.trim() || '';
        const href = (clientLink as any).getAttribute('href');
        if (href) {
          clientUrl = href.startsWith('http') ? href : `https://crowdworks.jp${href}`;
        }
      }

      // 評価・実績情報（definition要素から）
      const definitions = document.querySelectorAll('definition, [role="definition"]');
      definitions.forEach((def) => {
        const text = def.textContent?.trim() || '';
        if (text.match(/^\d+(\.\d+)?$/)) { // 数値のみ（評価）
          overallRating = text;
        } else if (text.includes('件') && text.match(/^\d+/)) { // ○○件（募集実績）
          orderHistory = text;
        } else if (text.includes('%')) { // ○○%（完了率）
          completionRate = text;
        }
      });

      // ありがとう件数
      const thankElements = document.querySelectorAll('text');
      thankElements.forEach(textEl => {
        const text = textEl.textContent?.trim() || '';
        if (text.includes('ありがとう') && text.includes('件')) {
          thankCount = text;
        } else if (text.includes('本人確認')) {
          identityVerified = !text.includes('未提出');
        } else if (text.includes('発注ルール')) {
          orderRuleCheck = text.includes('済み');
        }
      });

      // クライアント説明（事業内容）
      const businessElements = document.querySelectorAll('generic');
      businessElements.forEach(el => {
        const text = el.textContent?.trim() || '';
        if (text && text.includes('事業') && text.length > 5 && text.length < 50) {
          clientDescription = text;
        }
      });

      return {
        title,
        paymentType,
        budget,
        deliveryDate,
        postDate,
        applicationDeadline,
        applicantCount,
        contractCount,
        recruitmentCount,
        favoriteCount,
        detailedDescription,
        client: {
          name: clientName,
          url: clientUrl,
          overallRating,
          orderHistory,
          completionRate,
          thankCount,
          identityVerified,
          orderRuleCheck,
          description: clientDescription
        },
        recentApplicants: []
      };
    });

    // URLからjobIdを抽出
    const jobId = jobUrl.match(/\/jobs\/(\d+)/)?.[1] || '';

    return {
      jobId,
      category: '',
      url: jobUrl,
      desiredImages: [],
      scrapedAt: new Date().toISOString(),
      ...detail
    };

  } catch (error) {
    console.error(`❌ 詳細取得エラー (${jobUrl}):`, error);
    throw error;
  }
}

/**
 * カテゴリ別案件取得（詳細付き）- メイン機能
 */
export async function scrapeCrowdWorksJobsByCategoryWithDetails(params: {
  category: string;
  maxJobs: number;
  maxDetails?: number;
}): Promise<{
  jobs: CrowdWorksJob[];
  jobDetails: CrowdWorksJobDetail[];
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log(`🚀 カテゴリ「${params.category}」詳細取得開始`);

    // ブラウザ起動
    browser = await chromium.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
    });

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    });
    const page = await context.newPage();

    // 既存詳細の読み込み
    let existingDetails: CrowdWorksJobDetail[] = [];
    const detailsFile = `output/details-${params.category}.json`;

    try {
      const existingData = await readFileAsync(detailsFile);
      if (existingData) {
        existingDetails = JSON.parse(existingData);
        console.log(`📂 既存詳細データ: ${existingDetails.length}件`);
      }
    } catch (e) {
      console.log('📝 詳細データファイルなし（新規作成）');
    }

    // 案件一覧の取得
    const scrapingResult = await scrapeCrowdWorksJobsByCategory(page, params.category, params.maxJobs);

    if (!scrapingResult.success) {
      throw new Error(scrapingResult.error || 'スクレイピング失敗');
    }

    const jobs = scrapingResult.jobs;
    const maxDetails = params.maxDetails ?? params.maxJobs;

    // 詳細取得（重複チェック付き）
    const existingJobIds = new Set(existingDetails.map(d => d.jobId));
    const newJobs = jobs.filter(job => !existingJobIds.has(job.id));
    const jobsToDetail = newJobs.slice(0, maxDetails);

    console.log(`📊 詳細取得対象: ${jobsToDetail.length}件 (既存除外: ${jobs.length - newJobs.length}件)`);

    const newDetails: CrowdWorksJobDetail[] = [];
    for (let i = 0; i < jobsToDetail.length; i++) {
      const job = jobsToDetail[i];
      if (!job) continue; // null/undefined チェック

      try {
        const detail = await scrapeCrowdWorksJobDetail(page, job.url);
        detail.category = params.category;
        newDetails.push(detail);
        console.log(`✅ [${i + 1}/${jobsToDetail.length}] ${job.title.substring(0, 50)}...`);

        // API制限対応
        await page.waitForTimeout(1000);
      } catch (error) {
        console.error(`❌ 詳細取得失敗: ${job.title}`);
      }
    }

    // 全詳細をマージして保存
    const allDetails = [...existingDetails, ...newDetails];
    const fs = require('fs');
    fs.writeFileSync(detailsFile, JSON.stringify(allDetails, null, 2), 'utf8');
    console.log(`💾 詳細保存完了: ${detailsFile} (${allDetails.length}件)`);

    const executionTime = Date.now() - startTime;
    console.log(`🎯 カテゴリ「${params.category}」完了: ${jobs.length}件一覧, ${newDetails.length}件新規詳細 (${Math.round(executionTime / 1000)}秒)`);

    return {
      jobs,
      jobDetails: allDetails
    };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`❌ カテゴリ「${params.category}」エラー:`, errorMessage);
    return { jobs: [], jobDetails: [] };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * Lambda関数エントリーポイント
 */
export const lambdaHandler = async (
  event: ScheduledExecutionEvent,
  _context: Context
): Promise<ScheduledExecutionResponse> => {
  const startTime = Date.now();

  try {
    console.log('⚡ Lambda実行開始:', JSON.stringify(event, null, 2));

    const result = await executeFullAnalysisWorkflow({
      maxJobsPerCategory: 20,
      maxDetailsPerCategory: 20
    });

    const executionTime = Date.now() - startTime;

    return {
      statusCode: 200,
      body: JSON.stringify({
        success: result.success,
        summary: result.summary,
        reportFile: result.reportFile,
        executionTime
      }),
      executionTime,
      timestamp: new Date().toISOString()
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);

    console.error('❌ Lambda実行エラー:', errorMessage);

    return {
      statusCode: 500,
      body: JSON.stringify({
        success: false,
        error: errorMessage,
        executionTime
      }),
      executionTime,
      timestamp: new Date().toISOString()
    };
  }
};

/**
 * 全カテゴリスクレイピング→AI分析→レポート生成を統合実行
 */
export async function executeFullAnalysisWorkflow(params?: {
  maxJobsPerCategory?: number;
  maxDetailsPerCategory?: number;
}): Promise<{
  success: boolean;
  summary: {
    totalCategories: number;
    successfulCategories: number;
    totalJobs: number;
    totalDetails: number;
    analysisResults?: { [key: string]: number };
    reportGenerated: boolean;
  };
  reportFile?: string;
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  const maxJobs = params?.maxJobsPerCategory ?? 50;
  const maxDetails = params?.maxDetailsPerCategory ?? 50;

  try {
    console.log('🚀 統合分析ワークフロー開始...');
    console.log(`📊 設定: 各カテゴリ ${maxJobs}件取得, 詳細 ${maxDetails}件`);

    // ステップ1: 全カテゴリスクレイピング
    console.log('\n📂 ステップ1: 全カテゴリスクレイピング実行中...');
    const categories = ['ec', 'web_products', 'software_development', 'development'];
    let totalJobs = 0;
    let totalDetails = 0;
    let successfulCategories = 0;

    for (const category of categories) {
      try {
        console.log(`\n📈 ${category} カテゴリ処理中...`);
        const result = await scrapeCrowdWorksJobsByCategoryWithDetails({
          category,
          maxJobs,
          maxDetails
        });

        if (result.jobs.length > 0) {
          console.log(`✅ ${category}: ${result.jobs.length}件一覧, ${result.jobDetails.length}件詳細`);
          totalJobs += result.jobs.length;
          totalDetails += result.jobDetails.length;
          successfulCategories++;
        }

        // カテゴリ間で待機
        if (categories.indexOf(category) < categories.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      } catch (e) {
        console.log(`❌ ${category}: エラー -`, e instanceof Error ? e.message : String(e));
      }
    }

    console.log(`\n📊 スクレイピング完了: ${successfulCategories}/${categories.length}カテゴリ成功`);

    // ステップ2: AI分析実行
    console.log('\n🧠 ステップ2: AI分析実行中...');
    const analysisResults: { [key: string]: number } = {};

    for (const category of categories) {
      try {
        const detailsFile = `output/details-${category}.json`;
        const fs = require('fs');

        if (!fs.existsSync(detailsFile)) {
          console.log(`⚠️ ${category}: 詳細ファイルが見つかりません`);
          continue;
        }

        await new Promise<void>((resolve, reject) => {
          const { exec } = require('child_process');
          const analysisCmd = `npx ts-node scripts/analyze-details.ts ${detailsFile} output/analyzed-${category}.json`;
          exec(analysisCmd, (error: any) => {
            if (error) {
              console.log(`❌ ${category} AI分析エラー:`, error.message);
              reject(error);
            } else {
              console.log(`✅ ${category} AI分析完了`);
              try {
                const analyzedData = JSON.parse(fs.readFileSync(`output/analyzed-${category}.json`, 'utf8'));
                analysisResults[category] = analyzedData.length;
                console.log(`📊 ${category}: ${analyzedData.length}件分析完了`);
              } catch (parseError) {
                console.log(`⚠️ ${category}: 分析結果ファイルの読み込みエラー`);
              }
              resolve();
            }
          });
        });

        await new Promise(resolve => setTimeout(resolve, 3000));
      } catch (e) {
        console.log(`❌ ${category} AI分析失敗:`, e instanceof Error ? e.message : String(e));
      }
    }

    // ステップ3: おすすめ度計算
    console.log('\n⭐ ステップ3: おすすめ度計算実行中...');
    try {
      await new Promise<void>((resolve, reject) => {
        const { exec } = require('child_process');
        const recommendCmd = 'npx ts-node scripts/calculate-recommendation-score.ts';
        exec(recommendCmd, (error: any) => {
          if (error) {
            console.log('❌ おすすめ度計算エラー:', error.message);
            reject(error);
          } else {
            console.log('✅ おすすめ度計算完了');
            resolve();
          }
        });
      });
    } catch (e) {
      console.log('❌ おすすめ度計算失敗:', e instanceof Error ? e.message : String(e));
    }

    // ステップ4: 高時給案件抽出
    console.log('\n💰 ステップ4: 高時給案件抽出中...');
    try {
      await new Promise<void>((resolve, reject) => {
        const { exec } = require('child_process');
        const extractCmd = 'npx ts-node scripts/extract-high-hourly-jobs.ts';
        exec(extractCmd, (error: any) => {
          if (error) {
            console.log('❌ 高時給案件抽出エラー:', error.message);
            reject(error);
          } else {
            console.log('✅ 高時給案件抽出完了');
            resolve();
          }
        });
      });
    } catch (e) {
      console.log('❌ 高時給案件抽出失敗:', e instanceof Error ? e.message : String(e));
    }

    // ステップ5: 統合レポート生成
    console.log('\n📋 ステップ5: 統合レポート生成中...');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportFile = `output/crowdworks-analysis-report-${timestamp}.md`;

    try {
      const reportContent = await generateComprehensiveReport({
        totalCategories: categories.length,
        successfulCategories,
        totalJobs,
        totalDetails,
        analysisResults,
        timestamp: new Date().toISOString()
      });

      const fs = require('fs');
      fs.writeFileSync(reportFile, reportContent, 'utf8');
      console.log(`✅ 統合レポート生成完了: ${reportFile}`);

    } catch (e) {
      console.log('❌ レポート生成失敗:', e instanceof Error ? e.message : String(e));
    }

    const executionTime = Date.now() - startTime;

    console.log('\n🎉 統合分析ワークフロー完了！');
    console.log(`⏱️ 総実行時間: ${Math.round(executionTime / 1000)}秒`);

    return {
      success: true,
      summary: {
        totalCategories: categories.length,
        successfulCategories,
        totalJobs,
        totalDetails,
        analysisResults,
        reportGenerated: true
      },
      reportFile,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ 統合分析ワークフローエラー:', errorMessage);

    return {
      success: false,
      summary: {
        totalCategories: 0,
        successfulCategories: 0,
        totalJobs: 0,
        totalDetails: 0,
        reportGenerated: false
      },
      error: errorMessage,
      executionTime
    };
  }
}

/**
 * 統合レポート生成
 */
async function generateComprehensiveReport(data: {
  totalCategories: number;
  successfulCategories: number;
  totalJobs: number;
  totalDetails: number;
  analysisResults?: { [key: string]: number };
  timestamp: string;
}): Promise<string> {
  const date = new Date().toLocaleDateString('ja-JP');

  let report = `# CrowdWorks案件分析レポート

> 生成日: ${date}  
> 実行時刻: ${data.timestamp}  
> 対象: 全カテゴリ自動分析  

## 📊 実行サマリー

| 項目 | 結果 |
|------|------|
| 対象カテゴリ数 | ${data.totalCategories} |
| 成功カテゴリ数 | ${data.successfulCategories} |
| 総案件取得数 | ${data.totalJobs} |
| 総詳細取得数 | ${data.totalDetails} |
| AI分析完了 | ${data.analysisResults ? Object.keys(data.analysisResults).length : 0}カテゴリ |

## 🎯 カテゴリ別結果

`;

  if (data.analysisResults) {
    for (const [category, count] of Object.entries(data.analysisResults)) {
      const categoryName = category === 'ec' ? 'EC・ネットショップ' :
        category === 'web_products' ? 'Web制作・Webデザイン' :
          category === 'software_development' ? 'ソフトウェア開発' :
            category === 'development' ? 'システム開発' :
              category;
      report += `### ${categoryName}\n- AI分析件数: ${count}件\n\n`;
    }
  }

  // 高時給案件があれば追加
  try {
    const fs = require('fs');
    if (fs.existsSync('output/high-hourly-jobs-3000+.md')) {
      const highHourlyContent = fs.readFileSync('output/high-hourly-jobs-3000+.md', 'utf8');
      report += `\n## 💰 高時給案件抽出結果\n\n`;
      report += highHourlyContent.split('\n').slice(10).join('\n');
    }
  } catch (e) {
    report += `\n## 💰 高時給案件抽出結果\n\n高時給案件ファイルの読み込みに失敗しました。\n\n`;
  }

  // おすすめ案件があれば追加
  try {
    const fs = require('fs');
    if (fs.existsSync('output/recommended-jobs-top30.md')) {
      const recommendedContent = fs.readFileSync('output/recommended-jobs-top30.md', 'utf8');
      report += `\n## ⭐ おすすめ案件TOP30\n\n`;
      report += recommendedContent.split('\n').slice(5).join('\n');
    }
  } catch (e) {
    report += `\n## ⭐ おすすめ案件TOP30\n\nおすすめ案件ファイルの読み込みに失敗しました。\n\n`;
  }

  report += `\n---\n\n*このレポートは自動生成されました*\n`;

  return report;
}

/**
 * CLIインターフェース
 */
export async function runHandlerCLI(): Promise<void> {
  const args = process.argv.slice(2);

  if (args.length === 0) {
    console.log('🎯 利用可能なコマンド:');
    console.log('  full-analysis [件数] - 🚀 全処理統合実行 (スクレイピング→AI分析→レポート)');
    console.log('  scrape-ec [件数]     - EC案件取得 (デフォルト: 50件)');
    console.log('  scrape-web [件数]    - Web製品案件取得 (デフォルト: 50件)');
    console.log('  scrape-dev [件数]    - システム開発案件取得 (デフォルト: 50件)');
    console.log('  scrape-app [件数]    - アプリ開発案件取得 (デフォルト: 50件)');
    console.log('  lancers-system [件数] - ランサーズシステム開発案件取得 (デフォルト: 20件)');
    console.log('  lancers-web [件数]    - ランサーズWeb案件取得 (デフォルト: 20件)');
    console.log('  lancers-app [件数]    - ランサーズアプリ案件取得 (デフォルト: 20件)');
    console.log('  lancers-design [件数] - ランサーズデザイン案件取得 (デフォルト: 20件)');
    console.log('');
    console.log('📝 環境変数 LANCERS_EMAIL, LANCERS_PASSWORD を設定するとログインして取得します');
    console.log('例: npm run handler full-analysis 20');
    console.log('例: npm run handler scrape-ec 30');
    console.log('例: npm run handler lancers-system 15');
    return;
  }

  const command = args[0];
  const maxJobs = args[1] ? parseInt(args[1]) : 50;

  try {
    switch (command) {
      case 'full-analysis':
        console.log('🚀 全処理統合実行中...');
        const fullAnalysisResult = await executeFullAnalysisWorkflow({
          maxJobsPerCategory: maxJobs,
          maxDetailsPerCategory: maxJobs
        });
        console.log(JSON.stringify(fullAnalysisResult, null, 2));
        break;

      case 'scrape-ec':
        console.log(`📈 EC案件取得実行中 (${maxJobs}件)...`);
        const ecResult = await scrapeCrowdWorksJobsByCategoryWithDetails({
          category: 'ec',
          maxJobs,
          maxDetails: maxJobs
        });
        console.log(`✅ EC取得完了: ${ecResult.jobs.length}件一覧, ${ecResult.jobDetails.length}件詳細`);
        break;

      case 'scrape-web':
        console.log(`🌐 Web製品案件取得実行中 (${maxJobs}件)...`);
        const webResult = await scrapeCrowdWorksJobsByCategoryWithDetails({
          category: 'web_products',
          maxJobs,
          maxDetails: maxJobs
        });
        console.log(`✅ Web製品取得完了: ${webResult.jobs.length}件一覧, ${webResult.jobDetails.length}件詳細`);
        break;

      case 'scrape-dev':
        console.log(`💻 システム開発案件取得実行中 (${maxJobs}件)...`);
        const devResult = await scrapeCrowdWorksJobsByCategoryWithDetails({
          category: 'development',
          maxJobs,
          maxDetails: maxJobs
        });
        console.log(`✅ システム開発取得完了: ${devResult.jobs.length}件一覧, ${devResult.jobDetails.length}件詳細`);
        break;

      case 'scrape-app':
        console.log(`📱 アプリ開発案件取得実行中 (${maxJobs}件)...`);
        const appResult = await scrapeCrowdWorksJobsByCategoryWithDetails({
          category: 'software_development',
          maxJobs,
          maxDetails: maxJobs
        });
        console.log(`✅ アプリ開発取得完了: ${appResult.jobs.length}件一覧, ${appResult.jobDetails.length}件詳細`);
        break;

      case 'lancers-system':
        console.log(`💻 ランサーズシステム開発案件取得実行中 (${maxJobs}件)...`);
        const lancersSystemResult = await scrapeLancersJobsByCategory({
          category: 'system',
          maxJobs,
          ...(process.env['LANCERS_EMAIL'] && process.env['LANCERS_PASSWORD'] && { 
            email: process.env['LANCERS_EMAIL'], 
            password: process.env['LANCERS_PASSWORD'] 
          })
        });
        console.log(`✅ ランサーズシステム開発取得完了: ${lancersSystemResult.jobs.length}件取得`);
        break;

      case 'lancers-web':
        console.log(`🌐 ランサーズWeb案件取得実行中 (${maxJobs}件)...`);
        const lancersWebResult = await scrapeLancersJobsByCategory({
          category: 'web',
          maxJobs,
          ...(process.env['LANCERS_EMAIL'] && process.env['LANCERS_PASSWORD'] && { 
            email: process.env['LANCERS_EMAIL'], 
            password: process.env['LANCERS_PASSWORD'] 
          })
        });
        console.log(`✅ ランサーズWeb取得完了: ${lancersWebResult.jobs.length}件取得`);
        break;

      case 'lancers-app':
        console.log(`📱 ランサーズアプリ案件取得実行中 (${maxJobs}件)...`);
        const lancersAppResult = await scrapeLancersJobsByCategory({
          category: 'app',
          maxJobs,
          ...(process.env['LANCERS_EMAIL'] && process.env['LANCERS_PASSWORD'] && { 
            email: process.env['LANCERS_EMAIL'], 
            password: process.env['LANCERS_PASSWORD'] 
          })
        });
        console.log(`✅ ランサーズアプリ取得完了: ${lancersAppResult.jobs.length}件取得`);
        break;

      case 'lancers-design':
        console.log(`🎨 ランサーズデザイン案件取得実行中 (${maxJobs}件)...`);
        const lancersDesignResult = await scrapeLancersJobsByCategory({
          category: 'design',
          maxJobs,
          ...(process.env['LANCERS_EMAIL'] && process.env['LANCERS_PASSWORD'] && { 
            email: process.env['LANCERS_EMAIL'], 
            password: process.env['LANCERS_PASSWORD'] 
          })
        });
        console.log(`✅ ランサーズデザイン取得完了: ${lancersDesignResult.jobs.length}件取得`);
        break;

      default:
        console.log(`❌ 不明なコマンド: ${command}`);
        console.log('利用可能なコマンドを確認するには引数なしで実行してください。');
        process.exit(1);
    }
  } catch (error) {
    console.error('❌ 実行エラー:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

// CLI実行時の処理
if (require.main === module) {
  runHandlerCLI().catch(error => {
    console.error('❌ CLI実行エラー:', error);
    process.exit(1);
  });
}

/**
 * ランサーズ案件スクレイピング（ログイン機能付き）
 */
export async function scrapeLancersJobsByCategory(params: {
  category: string;
  maxJobs: number;
  email?: string;
  password?: string;
}): Promise<LancersScrapingResult> {
  const { category, maxJobs, email, password } = params;
  
  let browser: Browser | null = null;
  
  try {
    console.log(`🚀 ランサーズ「${category}」カテゴリスクレイピング開始`);
    
    browser = await chromium.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
    });
    
    const page = await browser.newPage();
    
    // User-Agentを設定
    await page.setExtraHTTPHeaders({
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    });
    
    const lancersService = new LancersService(page);
    
    // ログイン処理（認証情報がある場合）
    if (email && password) {
      console.log('🔐 ランサーズログイン実行中...');
      const loginSuccess = await lancersService.login(email, password);
      if (loginSuccess) {
        console.log('✅ ランサーズログイン成功');
      } else {
        console.log('⚠️ ランサーズログイン失敗 - 公開案件のみ取得します');
      }
    } else {
      console.log('ℹ️ 認証情報なし - 公開案件のみ取得します');
    }
    
    // 案件スクレイピング実行
    const jobsResult = await lancersService.scrapeJobs(category, maxJobs);
    
    console.log(`✅ ランサーズスクレイピング完了: ${jobsResult.length}件取得`);
    
    return {
      jobs: jobsResult,
      jobDetails: []
    };
    
  } catch (error) {
    console.error('❌ ランサーズスクレイピングエラー:', error);
    throw error;
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * ランサーズ案件詳細取得
 */
export async function scrapeLancersJobDetail(jobUrl: string, email?: string, password?: string): Promise<LancersJobDetail | null> {
  let browser: Browser | null = null;
  
  try {
    browser = await chromium.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage']
    });
    
    const page = await browser.newPage();
    await page.setExtraHTTPHeaders({
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
    });
    
    const lancersService = new LancersService(page);
    
    // ログイン処理（認証情報がある場合）
    if (email && password) {
      const loginSuccess = await lancersService.login(email, password);
      if (!loginSuccess) {
        console.log('⚠️ ランサーズログイン失敗 - 詳細取得に失敗する可能性があります');
      }
    }
    
    // 詳細取得
    const detail = await lancersService.scrapeJobDetail(jobUrl);
    
    return detail;
    
  } catch (error) {
    console.error('❌ ランサーズ詳細取得エラー:', error);
    return null;
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * ランサーズ案件スクレイピング（詳細付き・ログイン機能付き）
 */
export async function scrapeLancersJobsByCategoryWithDetails(params: {
  category: string;
  maxJobs: number;
  maxDetails?: number;
  email?: string;
  password?: string;
}): Promise<{
  jobs: LancersJob[];
  jobDetails: LancersJobDetail[];
}> {
  const { category, maxJobs, maxDetails = 10, email, password } = params;
  
  try {
    console.log(`🚀 ランサーズ「${category}」カテゴリ詳細付きスクレイピング開始`);
    
    // 案件リスト取得
    const scrapingResult = await scrapeLancersJobsByCategory({
      category,
      maxJobs,
      ...(email && password && { email, password })
    });
    
    if (scrapingResult.jobs.length === 0) {
      console.log('⚠️ 案件が見つかりませんでした');
      return { jobs: [], jobDetails: [] };
    }
    
    console.log(`📋 ${scrapingResult.jobs.length}件の案件から詳細を取得中...`);
    
    // 詳細取得対象を制限
    const jobsForDetails = scrapingResult.jobs.slice(0, maxDetails);
    const jobDetails: LancersJobDetail[] = [];
    
    for (let i = 0; i < jobsForDetails.length; i++) {
      const job = jobsForDetails[i];
      if (!job) continue; // undefined チェック
      
      console.log(`📋 詳細取得中 ${i + 1}/${jobsForDetails.length}: ${job.title}`);

      try {
        const detail = await scrapeLancersJobDetail(job.url, email, password);
        if (detail) {
          jobDetails.push(detail);
        }
        
        // レート制限対策（詳細取得間隔）
        if (i < jobsForDetails.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 3000));
        }
        
      } catch (error) {
        console.error(`❌ 詳細取得エラー (${job.url}):`, error);
      }
    }
    
    console.log(`✅ ランサーズ詳細付きスクレイピング完了: 案件${scrapingResult.jobs.length}件, 詳細${jobDetails.length}件`);
    
    return {
      jobs: scrapingResult.jobs,
      jobDetails
    };
    
  } catch (error) {
    console.error('❌ ランサーズ詳細付きスクレイピングエラー:', error);
    return { jobs: [], jobDetails: [] };
  }
}
</file>

</files>
