This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.eslintrc.js
.github/workflows/ci.yml
.gitignore
.prettierrc
app.ts
cdk.json
crowdworks-ec-jobs-2025-06-04T23-52-12-130Z.json
crowdworks-web_products-jobs-2025-06-04T23-52-25-027Z.json
docker-compose.yml
Dockerfile
Dockerfile.lambda
docs/01_requirements.md
docs/02_deployment.md
docs/02_system_design.md
docs/03_data_design.md
docs/04_api_design.md
docs/05_implementation_plan.md
docs/AWS_DEPLOYMENT_SETUP.md
docs/CI_CD_SETUP.md
docs/README.md
env.example
high-hourly-jobs-3000+.md
jest.config.js
package.json
README-setup.md
readme.md
recommended-jobs-top30.md
scripts/analyze-details.ts
scripts/analyze-development-details.ts
scripts/calculate-recommendation-score.ts
scripts/collect-development-categories.ts
scripts/extract-high-hourly-jobs.ts
scripts/setup-github-oidc.sh
scripts/sort-by-hourly-rate.ts
src/index.ts
src/infrastructure/crowdworks-searcher-stack.ts
src/lambda/handler.ts
src/services/index.ts
src/types/index.ts
src/utils/index.ts
tsconfig.cdk.json
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="high-hourly-jobs-3000+.md">
# 高時給案件一覧（3000円以上）

> 生成日: 2025-06-05  
> 対象: 時給3,000円以上の案件  
> 総件数: 44件  
> 注意: 工数見積もりには要件定義、打ち合わせ、修正作業などの前作業も含まれています

## 📊 概要

| 統計項目 | 値 |
|----------|----|
| 最高時給 | 4,166円 |
| 最低時給 | 3,000円 |
| 平均時給 | 3,088円 |
| EC案件数 | 30件 |
| Web製品案件数 | 14件 |

## 💼 案件一覧

### 1. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12145920)

**💰 想定時給:** 4,166円  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12145920

**📝 分析概要:**  
この案件は既存のWordPressサイトの全面リニューアルであり、20ページのコーディングとWordPressテーマの開発が必要です。要件定義や打ち合わせは完了しているものの、Figmaデザインに基づく実装、SEO最適化、レスポンシブ対応などの技術的な作業が多岐にわたります。これに加え、進捗報告や修正対応、テスト・検証作業も考慮すると、120時間程度の工数が妥当です。50万円の予算からシステム利用料を差し引いた金額を考慮し、現実的な時給を算出しました。

---

### 2. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12157565)

**💰 想定時給:** 3,750円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12157565

**📝 分析概要:**  
8ページの特集ページデザインには、要件定義や打ち合わせ、提案書作成、修正作業、テスト、納品後のサポートなどの付帯作業が含まれます。報酬300,000円から手数料を引いた額を考慮し、プロフェッショナルなデザインスキルが求められるため、時給は3750円と見積もりました。

---

### 3. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12152614)

**💰 想定時給:** 3,500円  
**⏰ 見積工数:** 10時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12152614

**📝 分析概要:**  
店舗1件あたりの報酬が3500円であり、要件定義、打ち合わせ、リサーチ、写真撮影、報告、修正対応、納品後のサポートを含めると約10時間の工数が見込まれます。報酬が固定されているため、時給は3500円と算出されますが、交通費が別途支給される点は考慮されています。

---

### 4. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12151707)

**💰 想定時給:** 3,500円  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12151707

**📝 分析概要:**  
この案件は戦略立案からレポーティングまで幅広い業務を含み、要件定義や打ち合わせ、修正作業などの付帯作業も多く発生するため、実際の工数は大きくなると見込まれます。時給は、求められるスキルと経験、出社の必要性を考慮し、提示された範囲の中間値を採用しました。

---

### 5. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156561)

**💰 想定時給:** 3,500円  
**⏰ 見積工数:** 160時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156561

**📝 分析概要:**  
この案件はUIデザインの実務経験が求められ、複数のツールを使用してのデザイン作業やコミュニケーションが必要です。要件定義や打ち合わせ、修正作業などの付帯作業も含めると、1人月（約160時間）の工数が見込まれます。高い専門性と経験が求められるため、時給は3500円程度が妥当です。

---

### 6. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12057717)

**💰 想定時給:** 3,333円  
**⏰ 見積工数:** 15時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12057717

**📝 分析概要:**  
この案件は、監修と推薦文の作成に加え、クライアントとの打ち合わせや商品確認、推薦文の修正作業が含まれます。報酬50,000円からシステム利用料を差し引いた金額を考慮し、実際の作業時間を15時間と見積もると、時給は約3333円となります。資格保持者の専門性が求められるため、通常のライティング案件よりも高めの時給設定が妥当です。

---

### 7. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/11530243)

**💰 想定時給:** 3,125円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/11530243

**📝 分析概要:**  
楽天市場のコンサルティング業務は専門性が高く、要件定義や打ち合わせ、進捗報告、修正作業などの付帯作業を含めると月に約80時間程度の工数が見込まれます。固定給250,000円を基に時給を算出しましたが、インセンティブは不確定要素が多いため、基本給のみで計算しました。

---

### 8. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158071)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158071

**📝 分析概要:**  
この案件はLP 8本と共通プラットフォームページ1本の制作で、要件定義や打ち合わせ、修正作業が複数回必要です。特に、ABテストやUX対応、タグ設置などの技術要件が含まれており、専門的な知識と経験が求められます。これらを考慮し、フリーランスの現実的な作業時間と市場相場を反映した時給を設定しました。

---

### 9. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/11921930)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 150時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/11921930

**📝 分析概要:**  
この案件は在庫管理システムの構築と物流設計を含むため、要件定義やシステム設計、クライアントとの打ち合わせ、複数回の修正が必要です。時給は経験とスキルに基づき、提示された範囲の中間値を選びました。

---

### 10. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12123340)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12123340

**📝 分析概要:**  
この案件は、デザイン制作に加え、競合分析やA+コンテンツの制作が含まれており、要件定義や複数回の修正作業が必要です。長期的な協力を求めているため、初期のコミュニケーションや提案書作成、進捗報告などの付帯作業も多く発生します。実務経験5年以上のスキルを求めていることから、時給は市場相場に基づき3000円としました。

---

### 11. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12123328)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12123328

**📝 分析概要:**  
この案件はEコマースのアカウントマネジメントや戦略立案、SEO対策など多岐にわたる業務を含むため、要件定義や打ち合わせ、進捗確認、修正作業などの付帯作業を含めると約120時間の工数が見込まれます。専門的なスキルが求められるため、時給は3000円程度が妥当です。長期的な協力を求めているため、継続的なコミュニケーション能力も重要です。

---

### 12. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12123333)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12123333

**📝 分析概要:**  
この案件はアマゾン関連の多岐にわたるサポート業務を含み、クライアントとのコミュニケーションや進捗管理、トラブルシューティングなどの付帯作業が多く発生します。専任での対応が求められており、経験豊富な人材が必要なため、時給は市場相場を考慮して3000円としました。

---

### 13. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12137358)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12137358

**📝 分析概要:**  
案件詳細が曖昧で具体的な作業内容が不明なため、要件定義や打ち合わせに多くの時間を要する可能性があります。また、複数回の修正や品質チェックが必要となることを考慮し、現実的な工数と時給を設定しました。

---

### 14. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156271)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156271

**📝 分析概要:**  
要件定義や打ち合わせ、撮影指示書の作成、デザイン作成、修正対応、納品後のサポートなど多岐にわたる作業が必要です。特にAmazon用のカタログやプレミアムAプラスのデザインは高い専門性が求められ、経験者が優遇されるため、時給は3000円としました。納期や継続案件の可能性も考慮し、十分な工数を見積もりました。

---

### 15. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12155324)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12155324

**📝 分析概要:**  
EC-CUBEでのデザイン・コーディングに加え、Figmaデザインのブラッシュアップやバナー制作も含まれるため、要件定義や打ち合わせ、修正作業などを含めた工数が大きくなります。スピード感とコミュニケーション能力が求められるため、専門性の高いフリーランスに適した時給設定が必要です。

---

### 16. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12155322)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 12時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12155322

**📝 分析概要:**  
この案件は製品レビューと監修が主な作業ですが、要件定義や打ち合わせ、レビュー文の作成、写真・動画撮影、SNS投稿などの付帯作業が含まれます。専門的な知識と信頼性が求められるため、時給は高めに設定しました。

---

### 17. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12155277)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 15時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12155277

**📝 分析概要:**  
この案件は、専門資格を持つ監修者としての顔出しや実名公表、商品紹介文の執筆、写真・動画撮影、SNS投稿など多岐にわたる作業が求められます。要件定義や打ち合わせ、修正作業、納品後のサポートも含めると、専門性と時間を要するため、時給3000円が妥当と考えられます。報酬が明示されていないため、交渉が必要です。

---

### 18. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12151998)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12151998

**📝 分析概要:**  
本案件はWordPressをベースにしたECサイトのカスタマイズで、デザインから予約機能、CRMの実装までを含むため、要件定義や打ち合わせ、修正作業が多く発生します。アジャイル開発で進行中のプロジェクトに参加する形で、既存メンバーで対応不可能な部分を担当するため、柔軟な対応力と高い技術力が求められます。

---

### 19. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12152774)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12152774

**📝 分析概要:**  
要件定義や複数回の打ち合わせ、タグ設定の仕様書作成、進捗報告、修正作業、テスト、納品後のサポートなどを考慮すると、全体で約40時間の工数が見込まれます。時給3000円は、専門的なスキルと付帯作業を含む現実的なフリーランス市場の相場を反映しています。

---

### 20. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12105892)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12105892

**📝 分析概要:**  
30ページのレスポンシブ化には、要件定義や打ち合わせ、修正作業を含めると80時間程度が現実的です。時給は、専門的なスキルを要する作業であることから3000円としました。納期が特に設けられていないため、クオリティを重視した作業が可能ですが、契約金額が曖昧なため、事前に詳細な見積もりを提示し、クライアントと合意を得ることが重要です。

---

### 21. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12152177)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12152177

**📝 分析概要:**  
案件詳細が曖昧で具体的な作業内容が不明なため、要件定義や打ち合わせに多くの時間を要する可能性が高い。さらに、修正作業や品質チェックも複数回発生することを考慮し、十分な工数を見積もる必要がある。

---

### 22. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12149970)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12149970

**📝 分析概要:**  
この案件はAmazonDSPの運用経験者を対象としており、要件定義や打ち合わせ、運用方法の指導、レポート作成など多岐にわたる作業が含まれます。時給は経験に応じて変動する可能性がありますが、専門知識を要するため、3000円程度が妥当です。契約期間が3ヶ月以上と長期にわたるため、初回の低価格設定に注意し、継続的な関与が求められることを考慮しました。

---

### 23. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12100569)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12100569

**📝 分析概要:**  
ECサイト運営サポートは、要件定義や打ち合わせ、進捗報告、修正作業など多岐にわたるため、実際の作業時間は多くなる。特にQoo10での経験が求められており、専門性が高いため、時給は市場相場を考慮して3000円とした。

---

### 24. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12150373)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12150373

**📝 分析概要:**  
Amazonの運用全般を担当するため、要件定義や打ち合わせ、進捗報告、修正作業など多岐にわたる付帯作業が発生します。報酬は要相談となっているが、専門性と長期的な関与が求められるため、時給3000円程度が妥当です。

---

### 25. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12150031)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12150031

**📝 分析概要:**  
Shopifyの多言語化と多通貨対応は技術的なスキルを要し、要件定義や修正作業、テストなどの付帯作業を含めると約40時間の工数が見込まれます。契約金額が5~10万円であることから、システム利用料を考慮しても時給3000円が妥当です。

---

### 26. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12148025)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12148025

**📝 分析概要:**  
広告運用の経験と専門知識が求められるため、要件定義や提案書作成、進捗報告、修正作業などの付帯作業を含めて40時間程度を見積もります。報酬が広告費の10%と成果に依存するため、時給は専門性に見合った3000円としました。

---

### 27. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12146909)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 10時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12146909

**📝 分析概要:**  
顔出しと推薦コメント作成のための準備や打ち合わせ、商品使用後のコメント作成、修正対応などを含めると、工数は約10時間と見積もられます。報酬は相談の上決定とありますが、顔出しや推薦のリスクを考慮し、時給3000円程度が妥当です。

---

### 28. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12093839)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 160時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12093839

**📝 分析概要:**  
この案件は長期的な業務であり、AMAZONの運営管理経験が求められています。平日フルタイムでの対応が必要で、要件定義や打ち合わせ、進捗報告、修正作業などの付帯作業を含めると、月160時間程度の工数が見込まれます。報酬は「応相談」とありますが、専門的なスキルと経験が求められるため、時給3000円が妥当と考えられます。

---

### 29. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12146961)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12146961

**📝 分析概要:**  
この案件はShopifyのテーマ移行とカスタマイズを含むため、要件定義や打ち合わせ、テストなどの付帯作業が多く発生します。特に、ECサイトの移行はダウンタイムを最小化する必要があり、慎重な計画と実行が求められます。時給3000円は、専門的なスキルと経験が必要な作業に対する適正な報酬と考えられます。

---

### 30. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12146628)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 15時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12146628

**📝 分析概要:**  
クライアントとの要件定義やヒアリング、提案書作成、進捗報告、修正作業、テスト、納品後のサポートなどを考慮すると、相談と実務を含めた工数は15時間程度と見積もられます。Shopifyへの移行経験が豊富な専門性が求められるため、時給は3000円が妥当です。

---

### 31. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/11996406)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 10時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/11996406

**📝 分析概要:**  
顔出しや推薦コメント作成に加え、要件定義や打ち合わせ、商品使用後のコメント作成、修正対応などの付帯作業が発生するため、総工数は10時間程度と見積もります。報酬が相談の上決定されるため、専門性や影響力を考慮し、時給は3000円と推定します。

---

### 32. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/11203604)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/11203604

**📝 分析概要:**  
この案件は、3つのECサイトのデザイン業務全般を担当するため、要件定義や打ち合わせ、修正作業を含めた工数が多くなると予想されます。前任者の経験からも、クライアントは誠実であるものの、デザインに対する要求が高いため、十分なスキルと時間が必要です。時給は、Webデザインの実務経験やコーディングスキルを持つプロフェッショナルに見合う額として設定しました。

---

### 33. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12154049)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12154049

**📝 分析概要:**  
サイト改修のデザイン案制作には要件定義や打ち合わせ、修正作業が含まれ、特に継続的な依頼を想定しているため、初回の工数が多くなる。報酬は協議で決定されるが、2年以上の実務経験が求められるため、時給は3000円程度が妥当と考えられる。

---

### 34. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158668)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 15時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158668

**📝 分析概要:**  
WordPressのタイムライン表示不具合の修正は技術的な調査と修正が必要で、要件定義や打ち合わせ、修正作業を含めると15時間程度と見積もります。時給は、専門的な技術とクライアントとの複数回のコミュニケーションを考慮し、3000円としました。

---

### 35. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158596)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158596

**📝 分析概要:**  
WordPressの新規サイト構築にはデザイン、コーディング、プラグイン設定、要件定義、打ち合わせ、修正作業など多くの工程が含まれます。特にUltimate MemberやFluentCRMの設定は複雑で、クライアントとの相談事項も多いため、十分な工数を見積もる必要があります。時給は専門的なスキルと経験を考慮し、3000円としました。

---

### 36. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158547)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 25時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158547

**📝 分析概要:**  
要件定義や打ち合わせ、デザイン作成、修正作業、テスト・検証などを含めると、実際の作業は25時間程度と見積もられます。短納期での対応が求められており、デザインの質も要求されるため、時給は3000円が妥当です。納期が厳しいため、効率的な作業が求められます。

---

### 37. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12028490)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12028490

**📝 分析概要:**  
この案件はデザインの方向性が多岐にわたり、クライアントとの認識合わせや修正作業が多く発生する可能性が高いです。要件定義や打ち合わせ、修正作業を含めると、十分な時間を見積もる必要があります。タイトルや詳細に具体的な作業内容が記載されていないため、曖昧な部分を考慮して慎重に見積もりました。

---

### 38. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158114)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158114

**📝 分析概要:**  
要件定義や打ち合わせ、修正作業を含めると、サイトのブラッシュアップには40時間程度が必要です。時給3000円は、デザイン・開発スキルを考慮した適正価格で、曖昧な報酬設定に対するリスクも考慮しています。

---

### 39. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12157546)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12157546

**📝 分析概要:**  
デザイン変更は要件定義や打ち合わせ、修正作業が発生しやすく、特にelementor + astraのカスタマイズには専門知識が必要です。納期が1週間と短いため、迅速な対応が求められます。これらを考慮し、現実的な工数と専門性に見合った時給を設定しました。

---

### 40. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156999)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156999

**📝 分析概要:**  
案件詳細が曖昧で具体的な作業内容が不明なため、要件定義や打ち合わせに多くの時間を要する可能性があります。また、デザインの方向性が多岐にわたるため、修正や調整作業も複数回発生することが予想されます。これらを考慮し、フリーランスの実務経験に基づいた現実的な時給を設定しました。

---

### 41. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156658)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156658

**📝 分析概要:**  
要件定義や打ち合わせ、修正作業を含めると、Figmaデザインからの静的コーディングは20時間程度が妥当です。時給は、コーディングの専門性と付帯作業を考慮し、3000円としました。納期が3日程度と短いため、迅速な対応が求められます。

---

### 42. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156312)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 60時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156312

**📝 分析概要:**  
ランディングページ制作には、要件定義やデザイン、コーディング、テストなど多岐にわたる作業が含まれ、特に素材が未提供であるため打ち合わせや提案作成に時間がかかる。時給は、専門的なスキルを要するため、相場を考慮して設定。

---

### 43. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12154648)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12154648

**📝 分析概要:**  
多言語対応のUI/UXデザインは要件定義や調整が複雑で、Figmaを用いたデザインシステムの構築や多言語レイアウト調整、開発・翻訳チームとの連携が求められるため、工数が増加します。専門的なスキルと経験が必要なため、時給は3000円が妥当です。

---

### 44. [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12154466)

**💰 想定時給:** 3,000円  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12154466

**📝 分析概要:**  
この案件は具体的な作業内容が不明瞭で、要件定義や打ち合わせに多くの時間を要する可能性があります。クライアントとの認識合わせや修正作業が複数回発生することを考慮し、十分な工数を見積もりました。時給はフリーランスの平均的な相場を基に設定しました。

---

## 📋 注記

- 時給は「要件定義」「打ち合わせ」「修正作業」「テスト」「納品後サポート」などの付帯作業も含めた現実的な工数見積もりに基づいています
- 案件の詳細は各リンクをクリックしてクラウドワークスのページでご確認ください
- 時給計算はGPT-4oによる分析結果であり、実際の作業時間や報酬は異なる場合があります
- 案件の募集状況は変動するため、リンク先で最新情報をご確認ください
</file>

<file path="recommended-jobs-top30.md">
# おすすめ案件ランキング TOP30

> 生成日: 2025-06-05  
> 評価基準: 係数システム（時給×2.5 + 工数×1.5）  
> 最高得点: 37.5点  
> 対象件数: 30件
> 💬 TOP10案件には戦略的提案文・質問を生成

## 📊 評価基準の詳細

### 💰 時給スコア（係数：2.5）
- 4000円以上: 10点 → 25点
- 3500円以上: 9点 → 22.5点
- 3000円以上: 8点 → 20点
- 2500円以上: 7点 → 17.5点
- 2000円以上: 6点 → 15点

### ⏰ 工数スコア（係数：1.5）
- 20-80時間: 10点 → 15点（最適な工数）
- 10-120時間: 8点 → 12点（良い範囲）
- 5-160時間: 6点 → 9点（許容範囲）

## 🔧 係数の意味

- **時給係数 2.5**: 収益性を最重視
- **工数係数 1.5**: 適度な作業量をバランス評価
- **難易度**: 参考情報として表示（点数計算には含めない）

**最高理論値**: 25 + 15 = 40点

## 🏆 ランキング

### 1位: 37.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12123340)

**💰 想定時給:** 3,500円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12123340

**📝 分析概要:**  
この案件は、アマゾンでの売上拡大を目的とした商品ページのビジュアルデザインを担当するもので、高度なデザインスキルとEコマースの実務経験が求められます。要件定義や複数回の打ち合わせ、競合分析、修正作業などの付帯作業を含めると、工数は大きくなり、専門的な知識と経験が必要なため難易度は高いと判断しました。

**💬 戦略的提案文:**  
初めまして、[あなたの名前]と申します。Eコマースとビジュアルデザインの分野で10年以上の経験を持ち、特にアマゾンのブランド強化において多くの成功事例を積み重ねてきました。貴社の売上拡大に貢献できるよう、ユーザー視点での訴求力のあるクリエイティブを全力でサポートいたします。

**❓ 仕様確認質問:**  
1. 商品ページのビジュアル表現に関して、特に強調したいブランドメッセージやテーマはありますか？
2. カタログのサブ画像制作において、ターゲットとする市場（国内・海外）ごとに異なる仕様や要件はありますでしょうか？
3. A+コンテンツ制作の際、既存のブランドガイドラインやテンプレートがあれば共有いただけますか？
4. プロジェクト進行中のコミュニケーション方法や頻度について、貴社のご希望をお聞かせください。
5. 成果物の評価基準や成功と見なす具体的な指標があれば教えていただけますか？

---

### 2位: 37.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12157565)

**💰 想定時給:** 3,750円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12157565

**📝 分析概要:**  
この案件は、8ページの特集ページデザインをShopify上で行う必要があり、デザインの専門知識とShopifyの操作スキルが求められます。要件定義や打ち合わせ、修正作業、納品後のサポートなどの付帯作業を含めると、工数は80時間程度と見積もられます。報酬から手数料を差し引いた実質的な報酬を考慮し、時給は3750円と推定されます。デザインの高級感や可愛さを表現するための高度なスキルが必要であるため、難易度は「難しい」と判断しました。

**💬 戦略的提案文:**  
初めまして。デザイン業界で10年以上の経験を持つ[あなたの名前]と申します。特にオンラインショップのデザインにおいて、ブランドの魅力を最大限に引き出すことを得意としております。御社のクラシック楽譜特集ページのデザインを通じて、貴社のビジョンを具現化するお手伝いができればと考えております。

**❓ 仕様確認質問:**  
1. 特集ページのデザインにおける具体的なブランドガイドラインや参考にしたい競合サイトがあれば教えていただけますか？
2. 各ページのセクション構成やレイアウトに関して、特に重視される要素（例：ユーザーの視線誘導、情報の優先順位など）はございますか？
3. デザインのフィードバックプロセスについて、どのような頻度でレビューを行い、どのようにコミュニケーションを取ることを希望されますか？
4. 納品形式について、Shopify上での作業が可能な場合とそうでない場合の具体的な納品手順や期待される成果物の詳細を教えていただけますか？
5. デザインの成功基準やKPIがあれば、具体的にどのような点を重視されるか教えていただけますか？

---

### 3位: 37.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12146628)

**💰 想定時給:** 3,500円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12146628

**📝 分析概要:**  
Shopifyへの会員情報移行は専門的な知識が必要で、要件定義や複数回の打ち合わせ、テストが不可欠です。特に、異なるプラットフォーム間のデータ移行は複雑で、経験豊富な専門家が求められます。

**💬 戦略的提案文:**  
はじめまして。Shopify移行の専門家として、これまでに多くのプロジェクトを成功に導いてきた[あなたの名前]と申します。特に会員情報の移行においては、最適なアプリ選定とスムーズな移行プロセスの構築に自信があります。貴社のプロジェクトを成功させるために、全力でサポートさせていただきますので、どうぞよろしくお願いいたします。

**❓ 仕様確認質問:**  
1. 現在ご利用中のメイクショップ等のカートシステムの具体的なバージョンやカスタマイズの有無について教えていただけますか？
2. 会員情報の移行に際して、特に重視されているデータ項目（例：購入履歴、ポイント情報など）はございますか？
3. 移行作業中のダウンタイムについて、許容される範囲や時間帯の制約があれば教えてください。
4. 移行後のShopify環境で、特に必要とされている機能やカスタマイズの要件があればお知らせください。
5. プロジェクト進行中のコミュニケーション方法や頻度について、希望されるスタイルがあれば教えていただけますか？

---

### 4位: 37点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12145920)

**💰 想定時給:** 4,166円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 120時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12145920

**📝 分析概要:**  
この案件は既存のWordPressサイトの全面リニューアルであり、20ページの構築とSEO最適化が求められています。要件定義やデザインは完了しているものの、技術的な実装には高度な専門知識が必要で、複雑な構造のサイトを効率的に構築するための経験が求められます。

**💬 戦略的提案文:**  
初めまして。私は10年以上のWordPress開発経験を持つエンジニアの[あなたの名前]と申します。これまで多くのメディアサイトのリニューアルを手掛け、特に内部SEOの最適化に注力して参りました。貴社のプロジェクトにおいても、技術面での課題解決に全力で取り組み、成功に導くお手伝いをさせていただきます。

**❓ 仕様確認質問:**  
1. 現在のサイトの具体的な課題（表示速度やスマホ閲覧時の使いづらさなど）について、詳細なデータや指標があれば共有いただけますか？
2. 内部SEOの最適化において、特に重視されている要素（例：ページ速度、モバイルフレンドリー、構造化データなど）があれば教えていただけますか？
3. ページ単位での中間納品・確認の際、どのようなフィードバックプロセスをお考えですか？また、フィードバックのターンアラウンドタイムはどの程度を想定されていますか？
4. 使用するプラグイン（ACF、SEO SIMPLE PACKなど）について、既に決定しているもの以外に追加のプラグインや技術的要件がある場合、事前にご相談いただけますか？
5. プロジェクトの成功基準やKPIとして設定されているものがあれば、具体的に教えていただけますか？

---

### 5位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/11530243)

**💰 想定時給:** 3,125円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/11530243

**📝 分析概要:**  
楽天市場のコンサルティング業務は専門的な知識と経験が必要で、クライアントとの要件定義や調整、進捗報告、修正作業が複数回発生するため、工数が多くなる。固定給250,000円を基に、月80時間の稼働を想定し、時給を算出した。

**💬 戦略的提案文:**  
初めまして、[あなたの名前]と申します。楽天市場の運用とコンサルティングにおいて5年以上の経験を持ち、数々のクライアント様の売上向上に貢献して参りました。御社のプロジェクトにおいても、確かな成果をお届けできるよう全力で取り組む所存です。どうぞよろしくお願いいたします。

**❓ 仕様確認質問:**  
1. 現在の運用部隊の体制や役割分担について、もう少し詳しく教えていただけますか？
2. KPIの具体的な内容や達成基準について、事前に共有いただける情報はありますでしょうか？
3. クライアント様とのコミュニケーションは主にどのように行われる予定でしょうか？また、頻度についても教えてください。
4. 楽天市場の運用において、特に重点を置いている施策や戦略があれば教えていただけますか？
5. 長期的なお付き合いを希望されているとのことですが、具体的な期間やフェーズごとの目標設定についてお伺いしたいです。

---

### 6位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156271)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156271

**📝 分析概要:**  
本案件は、Amazon用の商品画像デザインに加え、カメラマンへの撮影指示や構成作成が含まれるため、デザインスキルとコミュニケーション能力が求められます。要件定義や打ち合わせ、修正作業などの付帯作業を含めると、工数は約40時間と見積もられます。過去の経験や作品を求められていることから、ある程度の実務経験が必要であるため、難易度は「普通」と判断しました。

**💬 戦略的提案文:**  
はじめまして、[あなたの名前]と申します。楽天市場やAmazonでの画像デザイン経験を活かし、貴社のカー用品を魅力的に演出するお手伝いをさせていただきたいと考えております。貴社のビジョンを理解し、チームの一員として共に成果を上げることを楽しみにしています。

**❓ 仕様確認質問:**  
1. 商品の特徴や詳細について、特に強調したいポイントやブランドイメージはありますか？
2. カメラマンへの撮影指示書作成にあたり、特定のスタイルやフォーマットのご希望はありますか？
3. デザインのフィードバックプロセスについて、どのような流れを想定されていますか？
4. 納期の相談について、通常どのくらいの期間を見込んでいらっしゃいますか？
5. 継続的なコミュニケーションを円滑にするために、特に重視されている点やご希望の方法はございますか？

---

### 7位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12155324)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12155324

**📝 分析概要:**  
EC-CUBEでのデザイン・コーディングに加え、Figmaからのブラッシュアップやバナー作成、ディレクション的な役割も求められており、高度な専門知識と経験が必要です。要件定義や打ち合わせ、修正作業などの付帯作業も多く、スピード感が求められるため、工数は多めに見積もっています。

**💬 戦略的提案文:**  
初めまして、フリーランスの[あなたの名前]と申します。10年以上のECサイトデザインとコーディングの経験を活かし、御社の健康・ヘルスケアジャンルのECサイトをさらに魅力的にするお手伝いをさせていただきたいと考えております。迅速かつ柔軟に対応し、貴社のビジョンを実現するために全力を尽くします。

**❓ 仕様確認質問:**  
1. Figmaのデザインに関して、具体的にどの部分のブラッシュアップを希望されていますか？優先順位があれば教えてください。
2. EC-CUBEのバージョンはどれを使用していますか？また、既存のプラグインやカスタム機能がある場合、それらについての詳細を教えていただけますか？
3. バナー等のデザインに関して、具体的な数やサイズ、スタイルの指示があれば教えてください。
4. 納期について、具体的なスケジュールやマイルストーンの設定はありますか？また、急な変更があった場合の対応についても教えてください。
5. Slackでのコミュニケーションを希望されているとのことですが、日常的なやり取りの頻度や時間帯についてのご希望をお聞かせください。

---

### 8位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12155277)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12155277

**📝 分析概要:**  
この案件は専門資格を持つ監修者を求めており、実名と顔写真の公表が必要なため、専門性と信頼性が求められます。要件定義や打ち合わせ、商品紹介文の執筆、写真・動画撮影、SNS投稿など多岐にわたる作業が含まれるため、工数が増加します。報酬は明示されていないため、専門性に見合った時給を設定しました。

**💬 戦略的提案文:**  
初めまして、[あなたの名前]と申します。私は[関連資格や経験]を持つプロフェッショナルとして、これまで多くの健康関連商品の監修を行ってまいりました。貴社の「ホットアイマスク」プロジェクトにおいても、専門性を活かし、商品の魅力を最大限に引き出すお手伝いができればと考えております。

**❓ 仕様確認質問:**  
1. 商品紹介文のトーンやスタイルについて、特に重視されている点はありますか？
2. 商品の写真や動画撮影に関して、具体的な要件や希望されるシチュエーションはありますでしょうか？
3. SNSでの投稿を希望される場合、どのような内容や頻度を想定されていますか？
4. 商品サンプルの送付後、監修作業の納期はどの程度を予定されていますか？
5. 成果物の評価基準や、成功と見なされる条件について具体的に教えていただけますでしょうか？

---

### 9位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12151998)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12151998

**📝 分析概要:**  
この案件は、WordPressのカスタマイズに加え、複数のプラグインの調整や連携が必要であり、さらにアジャイル開発で進行するため、柔軟な対応力と高度な技術が求められます。設計書がないため、要件定義や仕様の確認に多くの時間がかかる可能性があり、また、音楽やカルチャーに対する理解も求められるため、難易度は高いと判断しました。

**💬 戦略的提案文:**  
はじめまして。WordPressを中心に10年以上の経験を持つ[あなたの名前]と申します。特にElementor Proを用いたカスタマイズやUXデザインに自信があり、音楽やカルチャーに対する深い理解を活かして、貴社のECサイト構築を成功に導くお手伝いをしたいと考えています。貴社のプロジェクトに対する真剣な取り組みと課題解決に全力を尽くしますので、どうぞよろしくお願いいたします。

**❓ 仕様確認質問:**  
1. 現在の開発状況や進捗について、具体的に教えていただけますか？特に優先度の高いタスクがあればお知らせください。
2. デザインや機能に関する具体的な要件やビジョンがあれば、詳細を共有いただけますでしょうか？特に音楽・カルチャーに関連する部分での期待する表現などがあれば教えてください。
3. 使用中のプラグインの選定理由や、特に注意が必要な連携部分について詳しく教えていただけますか？
4. コミュニケーションはどのようなツールや頻度で行う予定でしょうか？また、フィードバックのプロセスについても教えていただけると助かります。
5. 成功基準やKPIとして設定されているものがあれば教えてください。特にリリースに向けて重要視されているポイントを知りたいです。

---

### 10位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12152774)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 25時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12152774

**📝 分析概要:**  
タグ設定と価格変更の作業は技術的には標準的ですが、要件定義やクライアントとの調整、複数回の修正が必要となるため、工数が増加します。価格設定の曖昧さに注意し、見積もり時に詳細な要件確認が重要です。

**💬 戦略的提案文:**  
初めまして、[あなたの名前]と申します。クラウドソーシングプラットフォームでのシステム開発を専門としており、特にユーザー別のカスタマイズ機能の実装に豊富な経験があります。貴社のニーズに応じた最適なソリューションを提供し、プロジェクトの成功に貢献できるよう全力を尽くします。

**❓ 仕様確認質問:**  
1. ユーザーごとの価格設定に関して、具体的な価格変動の基準やルールはどのようにお考えでしょうか？
2. 商品表示設定のパターンについて、具体的にどのような条件やタグが想定されていますか？
3. プロジェクトの進行にあたり、コミュニケーションはどのような頻度で、どのツールを使用して行う予定でしょうか？
4. 成果物の納品形式や、テスト環境での動作確認についてのご要望があれば教えてください。
5. 本プロジェクトの成功基準や、特に重視されるポイントについてお伺いできますか？

---

### 11位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12105892)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12105892

**📝 分析概要:**  
30ページのレスポンシブ化は、各ページのデザイン調整やテストが必要で、SOYCMSとEGマイショップの知識も求められるため、専門的なスキルが必要です。要件定義や修正作業も含めると、工数は大きくなり、難易度も高いです。

---

### 12位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12149970)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 50時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12149970

**📝 分析概要:**  
AmazonDSPとPacvueの専門知識が求められ、運用経験が必須であるため、難易度は「難しい」と判断しました。要件定義や打ち合わせ、運用方法の説明、レポート作成、修正対応などの付帯作業を含めると、工数は50時間程度と見積もられます。専門性の高さから、時給は3000円が妥当です。

---

### 13位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12100569)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12100569

**📝 分析概要:**  
この案件はECサイトの運営コンサルサポートであり、Qoo10での販売経験やコンサル実績が求められているため、専門的な知識と経験が必要です。要件定義やクライアントとの打ち合わせ、進捗報告、修正作業などの付帯作業も多く、平日の日中に対応可能な本業の方を求めていることから、工数は多めに見積もる必要があります。

---

### 14位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12150373)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12150373

**📝 分析概要:**  
この案件はAmazonの最高責任者としての役割を担うため、高度な専門知識と豊富な経験が求められます。要件定義や打ち合わせ、進捗報告、修正作業などの付帯作業も多く、長期的なコミットメントが必要です。報酬は要相談ですが、専門性の高さから時給3000円程度が妥当と考えられます。

---

### 15位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12150031)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12150031

**📝 分析概要:**  
Shopifyの越境EC化には、LiquidやUIの深い理解が必要で、多言語化や多通貨対応の調整も含まれるため、専門的な知識と経験が求められます。要件定義や修正作業、テストなどの付帯作業も多く、工数がかさむことが予想されます。

---

### 16位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12148025)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 60時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12148025

**📝 分析概要:**  
この案件は、広告運用の専門知識と実績が求められ、特に車関連パーツECの特性を理解した上でのマーケティング提案が必要です。報酬が広告費の10%という成果報酬型であるため、実績に応じた高いスキルが求められ、難易度は高いと判断されます。また、要件定義や提案、複数回の修正作業が発生する可能性が高く、工数も多く見積もる必要があります。

---

### 17位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/11203604)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 60時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/11203604

**📝 分析概要:**  
この案件は、3つのネットショップのデザイン業務全般を担当し、Webデザインの実務経験やコーディングスキルが求められるため、専門的なスキルと経験が必要です。要件定義や打ち合わせ、修正作業などの付帯作業も多く、クライアントの期待に応えるための高い訴求力が求められることから、難易度は「難しい」と判断しました。

---

### 18位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12154049)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12154049

**📝 分析概要:**  
サービスサイトの改修において、Figmaでのデザイン案制作やクライアントとの共同作業が求められ、Webサイト制作の実務経験が必要です。要件定義や打ち合わせ、修正作業が複数回発生するため、標準的な業務と判断しました。報酬は協議の上で決定されるため、実務経験に基づいた適正な時給を設定しました。

---

### 19位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158596)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158596

**📝 分析概要:**  
WordPressサイトの新規構築に加え、Ultimate MemberやFluentCRMなどのプラグインを使用した複雑な機能実装が求められており、要件定義やデザイン、コーディング、テストなど多岐にわたる作業が必要です。クライアントとの要件整理や複数回の修正対応も考慮すると、工数は大きくなり、専門的な知識が必要なため難易度は高いと判断しました。

---

### 20位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158547)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 25時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158547

**📝 分析概要:**  
要件定義や打ち合わせ、デザインの提案・修正、テスト・納品作業を含めると25時間程度が妥当です。デザインの装飾は一般的なスキルで対応可能ですが、展示会向けのクオリティを求められるため、多少の経験と調査が必要です。納期が短いため、効率的な作業が求められます。

---

### 21位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12158114)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12158114

**📝 分析概要:**  
既存サイトのブラッシュアップには、要件定義やデザイン調整、動きのある要素の実装が必要で、複数回の打ち合わせや修正が発生します。SWELLの知識とWebデザインのスキルが求められるため、一般的なスキルレベルが必要です。

---

### 22位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12157546)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12157546

**📝 分析概要:**  
デザイン変更はelementorとastraを使用するため、一般的なスキルで対応可能ですが、要件定義や修正作業、納品後のサポートを含めると工数が増加します。納期が1週間と短いため、効率的な作業が求められます。

---

### 23位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156658)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 20時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156658

**📝 分析概要:**  
Figmaからの静的コーディングは一般的なスキルで対応可能ですが、レスポンシブ対応やクライアントとの打ち合わせ、修正作業を含めると工数が増加します。特に、要件定義や進捗報告、納品後のサポートも考慮すると、全体で20時間程度が妥当です。時給は、一般的なWebコーディングの相場を考慮して3000円としました。

---

### 24位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12156312)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 60時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12156312

**📝 分析概要:**  
ワイヤーフレームや素材が提供されておらず、構成からデザイン、コーディングまで全てを担当する必要があるため、要件定義やクライアントとの打ち合わせに多くの時間がかかることが予想されます。また、レスポンシブ対応も求められており、技術的なスキルが必要です。

---

### 25位: 35点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12154648)

**💰 想定時給:** 3,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12154648

**📝 分析概要:**  
多言語対応のUI/UXデザインやFigmaを用いたデザインシステムの構築は高度な専門知識が必要で、開発チームや翻訳チームとの連携も求められるため、工数が多く難易度も高いです。要件定義や修正作業、納品後のサポートも含めると、全体で80時間程度が見込まれます。

---

### 26位: 34.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12152614)

**💰 想定時給:** 3,500円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 10時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12152614

**📝 分析概要:**  
店舗リサーチと写真撮影は現地訪問が必要で、要件定義や打ち合わせ、修正作業を含むと工数が増加します。報酬は店舗1件あたり固定されているため、時給は3500円と推定されます。ハイブランドの知識が求められるため、難易度は普通と判断しました。

---

### 27位: 34点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12151707)

**💰 想定時給:** 4,000円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 150時間  
**🏷️ カテゴリ:** EC  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12151707

**📝 分析概要:**  
この案件は、ECビジネスの経営企画に関する高度な専門知識と経験が求められ、戦略立案やAI活用推進など多岐にわたる業務を含むため、工数が大きくなることが予想されます。時給は、求められるスキルと経験の高さに基づき、上限に近い4000円としました。

---

### 28位: 32.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12146187)

**💰 想定時給:** 2,500円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 80時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12146187

**📝 分析概要:**  
UI/UXデザイン業務は専門的なスキルを要し、要件定義や修正作業、進捗確認などの付帯作業が多いため、工数が増加します。時給は市場相場を考慮し、スキルに応じた報酬が見込まれるため2500円としました。

---

### 29位: 32.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12149324)

**💰 想定時給:** 2,500円  
**🎯 難易度:** 普通  
**⏰ 見積工数:** 40時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12149324

**📝 分析概要:**  
LP制作にはデザインカンプ作成から実装、素材準備、クライアントとのコミュニケーションや修正作業が含まれ、WordPressやデザインツールのスキルが求められるため、一般的なスキルレベルが必要です。案件は継続的なパートナーシップを前提としているが、初回の契約金額が低いため、実際の作業量に対して時給が低くなりがちです。

---

### 30位: 32.5点 - [クラウドソーシング・仕事依頼・求人情報は日本最大級のクラウドワークス](https://crowdworks.jp/public/jobs/12155918)

**💰 想定時給:** 2,500円  
**🎯 難易度:** 難しい  
**⏰ 見積工数:** 60時間  
**🏷️ カテゴリ:** Web製品  
**🔗 案件URL:** https://crowdworks.jp/public/jobs/12155918

**📝 分析概要:**  
この案件は、ECモールでのLP制作において、ブランドの世界観を伝えるための高度なデザインスキルと、楽天市場のガイドラインに準拠した技術的な知識が必要です。要件定義や打ち合わせ、修正作業が複数回発生することが予想され、また、NDA締結後の詳細情報の確認や、納品形式の多様性も考慮すると、工数は多くなり、難易度も高いと判断されます。

---
</file>

<file path="scripts/analyze-details.ts">
require('dotenv').config();

import { readFileSync, writeFileSync } from 'fs';
import { OpenAI } from 'openai';
import * as path from 'path';

// 型定義
interface CrowdWorksJobDetail {
    jobId: string;
    title: string;
    detailedDescription: string;
    [key: string]: any;
}

interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    難易度: string;
    gpt_summary: string;
}

// .envからAPIキー取得
const apiKey = process.env['OPENAI_API_KEY'];
if (!apiKey) {
    console.error('❌ OPENAI_API_KEYが設定されていません');
    process.exit(1);
}

const openai = new OpenAI({ apiKey });

// 引数: 入力ファイル, 出力ファイル
const [, , inputFile, outputFile] = process.argv;
if (!inputFile || !outputFile) {
    console.error('Usage: ts-node scripts/analyze-details.ts <input.json> <output.json>');
    process.exit(1);
}

const inputPath = path.resolve(inputFile);
const outputPath = path.resolve(outputFile);

const details: CrowdWorksJobDetail[] = JSON.parse(readFileSync(inputPath, 'utf8'));

// 並列実行制御クラス
class ConcurrencyLimiter {
    private runningCount = 0;
    private queue: (() => Promise<void>)[] = [];

    constructor(private maxConcurrency: number) { }

    async execute<T>(task: () => Promise<T>): Promise<T> {
        return new Promise<T>((resolve, reject) => {
            const wrappedTask = async () => {
                try {
                    this.runningCount++;
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.runningCount--;
                    this.processQueue();
                }
            };

            if (this.runningCount < this.maxConcurrency) {
                wrappedTask();
            } else {
                this.queue.push(wrappedTask);
            }
        });
    }

    private processQueue() {
        if (this.queue.length > 0 && this.runningCount < this.maxConcurrency) {
            const nextTask = this.queue.shift();
            if (nextTask) {
                nextTask();
            }
        }
    }
}

const limiter = new ConcurrencyLimiter(5); // 最大5件並列

async function analyzeDetail(detail: CrowdWorksJobDetail): Promise<AnalysisResult> {
    const prompt = `以下はクラウドワークスの案件詳細です。内容を読んで、
1. この仕事にかかるおおよその工数（何時間くらいか）
2. 想定される時給（日本円・固定値で1つの数値のみ）
3. 案件の難易度（簡単/普通/難しい のいずれか）
4. その根拠や注意点
を日本語で簡潔にまとめてください。

【重要な工数見積もりのポイント】
- 記載された作業内容だけでなく、以下の前作業・付帯作業も必ず含めて計算してください：
  * 要件定義・要件整理（クライアントとの認識合わせ）
  * 初回打ち合わせ・ヒアリング（1-3回程度）
  * 提案書・企画書・仕様書の作成
  * 作業中の進捗報告・中間確認
  * 修正・調整作業（通常2-3回は発生）
  * テスト・検証・品質チェック
  * 納品作業・説明・引き継ぎ
  * 納品後の軽微なサポート・質問対応

【重要な難易度判定のポイント】
- **簡単**: 初心者・未経験者でも対応可能、基本的なスキルで十分、テンプレート作業中心
- **普通**: 一般的なスキルレベルが必要、多少の学習や調査が必要、標準的な業務
- **難しい**: 高度な専門知識・技術が必要、豊富な経験が前提、複雑な要件や新技術

【重要な注意点】
- クラウドワークスの案件は玉石混交で、タイトルで指定した価格が案件詳細では嘘だと書かれていたりします
- 詳細説明を注意深く読み、実際の作業内容と報酬を正確に把握してください
- タイトルの金額に惑わされず、詳細に書かれた実際の条件から確からしい想定時給を算出してください
- 「〇〇円スタート」「能力に応じて」などの曖昧な表現にも注意してください
- 初回は低価格で「継続で単価アップ」という案件は、初回価格を基準に計算してください
- **時給は必ず1つの具体的な数値で回答してください（例：2500円）。範囲や曖昧な表現は禁止です**
- **難易度は必ず「簡単」「普通」「難しい」のいずれか1つで回答してください**
- **実際のフリーランス作業の現実を反映した、十分な工数を見積もってください**

---
タイトル: ${detail.title}

詳細説明: ${detail.detailedDescription}
---

【出力フォーマット】
工数: <例: 8時間>
時給: <例: 2500円>
難易度: <例: 普通>
要約: <根拠や注意点を1-2文で>`;

    return limiter.execute(async () => {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは日本のフリーランス市場の専門家で、クラウドワークス案件の現実的な工数見積もりと時給推定の専門家です。実際のフリーランス作業では要件定義や打ち合わせ、修正作業なども必要で、記載された作業以外にも多くの付帯作業が発生することを理解しています。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 512,
            temperature: 0.2,
        });

        const text = res.choices[0]?.message?.content || '';
        // シンプルなパース
        const 工数 = text.match(/工数[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 時給 = text.match(/時給[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 難易度 = text.match(/難易度[:：]\s*(.+)/)?.[1]?.trim() || '';
        const 要約 = text.match(/要約[:：]\s*([\s\S]*)/)?.[1]?.trim() || text;

        return {
            jobId: detail.jobId,
            title: detail.title,
            工数_見積もり: 工数,
            想定時給: 時給,
            難易度: 難易度,
            gpt_summary: 要約,
        };
    });
}

(async () => {
    console.log(`🚀 並列分析開始: ${details.length}件（最大5件並列）`);
    const results: AnalysisResult[] = [];
    let completed = 0;

    // 全ての案件を並列で処理開始
    const promises = details.map(async (detail, index) => {
        try {
            const result = await analyzeDetail(detail);
            results.push(result);
            completed++;
            console.log(`✅ [${completed}/${details.length}] ${detail.title.substring(0, 50)}...`);

            // 定期的に中間結果を保存
            if (completed % 5 === 0 || completed === details.length) {
                // 結果をjobId順にソートして保存
                const sortedResults = results.sort((a, b) => a.jobId.localeCompare(b.jobId));
                writeFileSync(outputPath, JSON.stringify(sortedResults, null, 2), 'utf8');
                console.log(`💾 中間保存: ${completed}件完了`);
            }

            return { success: true, result, index };
        } catch (e) {
            console.error(`❌ [${index + 1}/${details.length}] ${detail.title.substring(0, 50)}... - エラー:`, e);
            return { success: false, error: e, index };
        }
    });

    // 全ての処理が完了するまで待機
    const settledResults = await Promise.allSettled(promises);

    // 最終結果の統計
    const successful = settledResults.filter(r => r.status === 'fulfilled' && r.value.success).length;
    const failed = settledResults.length - successful;

    console.log(`\n🎯 並列分析完了:`)
    console.log(`✅ 成功: ${successful}件`);
    console.log(`❌ 失敗: ${failed}件`);
    console.log(`📁 出力ファイル: ${outputPath}`);

    // 最終保存（jobId順でソート）
    const finalResults = results.sort((a, b) => a.jobId.localeCompare(b.jobId));
    writeFileSync(outputPath, JSON.stringify(finalResults, null, 2), 'utf8');
    console.log(`💾 最終保存完了: ${finalResults.length}件`);
})();
</file>

<file path="scripts/analyze-development-details.ts">
#!/usr/bin/env node
require('dotenv').config();

import { readFileSync, writeFileSync, existsSync } from 'fs';
import { OpenAI } from 'openai';

// 型定義
interface JobDetail {
    jobId: string;
    title: string;
    detailedDescription: string;
    category: string;
    budget: string;
    paymentType: string;
    [key: string]: any;
}

interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    難易度: string;
    gpt_summary: string;
    category?: string;
}

// .envからAPIキー取得
const apiKey = process.env['OPENAI_API_KEY'];
if (!apiKey) {
    console.error('❌ OPENAI_API_KEYが設定されていません');
    process.exit(1);
}

const openai = new OpenAI({ apiKey });

// 開発系カテゴリのリスト
const DEVELOPMENT_CATEGORIES = ['development', 'software_development'];

// GPTで案件を分析する関数
async function analyzeJobWithGPT(job: JobDetail): Promise<AnalysisResult> {
    const prompt = `以下のクラウドワークス案件を分析して、工数見積もり、想定時給、難易度、概要を日本語で回答してください。

【案件情報】
タイトル: ${job.title}
カテゴリ: ${job.category}
詳細説明: ${job.detailedDescription || '詳細不明'}
予算情報: ${job.budget || '不明'}
支払い方式: ${job.paymentType || '不明'}

【回答形式】
工数見積もり: <時間数や期間を具体的に>
想定時給: <円単位で金額を>
難易度: <簡単/普通/難しいから選択>
概要: <案件の要点を2-3行で>

特に開発案件については、技術的な複雑さ、必要なスキルレベル、実装規模を考慮して評価してください。`;

    try {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは経験豊富なITフリーランサーで、案件の工数見積もりと技術的難易度の評価が得意です。開発案件の特性を正確に把握し、現実的な評価を行います。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 500,
            temperature: 0.3,
        });

        const text = res.choices[0]?.message?.content || '';

        // レスポンスをパースして構造化
        const workloadMatch = text.match(/工数見積もり[:：]\s*(.+)/);
        const hourlyMatch = text.match(/想定時給[:：]\s*(.+)/);
        const difficultyMatch = text.match(/難易度[:：]\s*(.+)/);
        const summaryMatch = text.match(/概要[:：]\s*([\s\S]+)/);

        return {
            jobId: job.jobId,
            title: job.title,
            工数_見積もり: workloadMatch?.[1]?.trim() || '不明',
            想定時給: hourlyMatch?.[1]?.trim() || '0円',
            難易度: difficultyMatch?.[1]?.trim() || '普通',
            gpt_summary: summaryMatch?.[1]?.trim() || text.trim(),
            category: job.category
        };
    } catch (e) {
        console.error(`❌ GPT分析エラー (${job.jobId}):`, e);
        return {
            jobId: job.jobId,
            title: job.title,
            工数_見積もり: '分析エラー',
            想定時給: '0円',
            難易度: '普通',
            gpt_summary: 'GPT分析でエラーが発生しました',
            category: job.category
        };
    }
}

// 並列分析処理
async function analyzeJobsInBatches(jobs: JobDetail[], batchSize: number = 3): Promise<AnalysisResult[]> {
    const results: AnalysisResult[] = [];

    console.log(`📊 ${jobs.length}件の案件を${batchSize}件ずつ並列で分析開始...`);

    for (let i = 0; i < jobs.length; i += batchSize) {
        const batch = jobs.slice(i, i + batchSize);
        console.log(`\n🔄 バッチ ${Math.floor(i / batchSize) + 1}/${Math.ceil(jobs.length / batchSize)}: ${batch.length}件処理中...`);

        const batchPromises = batch.map(async (job, index) => {
            try {
                const result = await analyzeJobWithGPT(job);
                console.log(`✅ [${i + index + 1}/${jobs.length}] ${job.title.substring(0, 40)}... 分析完了`);
                return result;
            } catch (error) {
                console.error(`❌ [${i + index + 1}/${jobs.length}] 分析エラー:`, error);
                return {
                    jobId: job.jobId,
                    title: job.title,
                    工数_見積もり: 'エラー',
                    想定時給: '0円',
                    難易度: '普通',
                    gpt_summary: '分析エラーが発生しました',
                    category: job.category
                };
            }
        });

        const batchResults = await Promise.all(batchPromises);
        results.push(...batchResults);

        // API制限回避のため少し待機
        if (i + batchSize < jobs.length) {
            console.log('⏳ APIレート制限回避のため2秒待機...');
            await new Promise(resolve => setTimeout(resolve, 2000));
        }
    }

    return results;
}

// メイン処理
async function analyzeDevelopmentDetails(): Promise<void> {
    console.log('🔄 開発系カテゴリの詳細分析を開始...');

    for (const category of DEVELOPMENT_CATEGORIES) {
        const detailsFile = `details-${category}.json`;

        if (!existsSync(detailsFile)) {
            console.log(`⚠️ ${detailsFile} が見つかりません。スキップします。`);
            continue;
        }

        try {
            console.log(`\n📂 カテゴリ「${category}」の分析開始...`);

            // 詳細データ読み込み
            const jobDetails: JobDetail[] = JSON.parse(readFileSync(detailsFile, 'utf8'));
            console.log(`📄 ${jobDetails.length}件の詳細データを読み込み`);

            if (jobDetails.length === 0) {
                console.log(`⚠️ カテゴリ「${category}」にデータがありません`);
                continue;
            }

            // GPT分析実行
            const analysisResults = await analyzeJobsInBatches(jobDetails, 3);

            // 結果保存
            const outputFile = `analyzed-${category}.json`;
            writeFileSync(outputFile, JSON.stringify(analysisResults, null, 2), 'utf8');

            console.log(`✅ 分析結果保存: ${outputFile}`);
            console.log(`📊 カテゴリ「${category}」分析完了: ${analysisResults.length}件`);

            // 統計情報表示
            const successCount = analysisResults.filter(r => r.工数_見積もり !== 'エラー' && r.工数_見積もり !== '分析エラー').length;
            const errorCount = analysisResults.length - successCount;

            console.log(`   - 成功: ${successCount}件`);
            console.log(`   - エラー: ${errorCount}件`);

            // サンプル表示
            if (analysisResults.length > 0) {
                const sample = analysisResults[0];
                console.log(`📝 サンプル分析結果:`);
                console.log(`   タイトル: ${sample.title.substring(0, 50)}...`);
                console.log(`   工数: ${sample.工数_見積もり}`);
                console.log(`   時給: ${sample.想定時給}`);
                console.log(`   難易度: ${sample.難易度}`);
            }

        } catch (error) {
            console.error(`❌ カテゴリ「${category}」の分析でエラー:`, error);
            continue;
        }
    }

    console.log('\n🎉 開発系カテゴリの分析完了！');
}

// 実行
if (require.main === module) {
    analyzeDevelopmentDetails().catch(console.error);
}

export { analyzeDevelopmentDetails };
</file>

<file path="scripts/calculate-recommendation-score.ts">
require('dotenv').config();

import { readFileSync, writeFileSync } from 'fs';
import { OpenAI } from 'openai';

// 型定義
interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    難易度: string;
    gpt_summary: string;
    category?: string;
}

interface ScoredJob extends AnalysisResult {
    hourly_rate_numeric: number;
    workload_hours: number;
    difficulty_score: number;
    skill_fit_score: number;
    recommendation_score: number;
    link: string;
    original_title?: string;
    proposal_greeting?: string;
    specification_questions?: string;
    skill_analysis?: string;
}

// .envからAPIキー取得
const apiKey = process.env['OPENAI_API_KEY'];
if (!apiKey) {
    console.error('❌ OPENAI_API_KEYが設定されていません');
    process.exit(1);
}

const openai = new OpenAI({ apiKey });

// 時給文字列を数値に変換する関数
function parseHourlyRate(hourlyRateString: string): number {
    if (!hourlyRateString || hourlyRateString.trim() === '' || hourlyRateString === '0円') {
        return 0;
    }

    const match = hourlyRateString.match(/([0-9,]+)/);
    if (match && match[1]) {
        const numericString = match[1].replace(/,/g, '');
        return parseInt(numericString, 10);
    }

    return 0;
}

// 工数文字列を数値（時間）に変換する関数
function parseWorkloadHours(workloadString: string): number {
    if (!workloadString || workloadString.trim() === '') {
        return 40; // デフォルト値
    }

    // 「120時間」「2週間」「1ヶ月」などを解析
    const hourMatch = workloadString.match(/([0-9,]+)\s*時間/);
    if (hourMatch && hourMatch[1]) {
        return parseInt(hourMatch[1].replace(/,/g, ''), 10);
    }

    const dayMatch = workloadString.match(/([0-9,]+)\s*日/);
    if (dayMatch && dayMatch[1]) {
        return parseInt(dayMatch[1].replace(/,/g, ''), 10) * 8; // 1日8時間想定
    }

    const weekMatch = workloadString.match(/([0-9,]+)\s*週間/);
    if (weekMatch && weekMatch[1]) {
        return parseInt(weekMatch[1].replace(/,/g, ''), 10) * 40; // 1週間40時間想定
    }

    const monthMatch = workloadString.match(/([0-9,]+)\s*ヶ?月/);
    if (monthMatch && monthMatch[1]) {
        return parseInt(monthMatch[1].replace(/,/g, ''), 10) * 160; // 1ヶ月160時間想定
    }

    return 40; // デフォルト値
}

// 難易度を点数に変換する関数（簡単ほど高得点）
function parseDifficultyScore(difficultyString: string): number {
    const difficulty = difficultyString.trim().toLowerCase();

    if (difficulty.includes('簡単') || difficulty.includes('かんたん')) {
        return 10; // 簡単 = 高得点
    } else if (difficulty.includes('普通') || difficulty.includes('ふつう') || difficulty.includes('標準')) {
        return 6; // 普通 = 中得点
    } else if (difficulty.includes('難しい') || difficulty.includes('むずかしい') || difficulty.includes('困難')) {
        return 3; // 難しい = 低得点
    }

    return 5; // 不明な場合はデフォルト
}

// ===== 評価係数設定 =====
// 係数を変更することで評価の重要度を調整できます
const EVALUATION_COEFFICIENTS = {
    HOURLY: 2.0,          // 時給重視度
    WORKLOAD: 1.0,        // 工数バランス重視度
    SKILL_FIT: 2.5        // スキル適性重視度
    // 難易度は表示のみで点数計算から除外
};

// おすすめ点数を計算する関数（スキル適性考慮版）
function calculateRecommendationScore(
    hourlyRate: number,
    workloadHours: number,
    skillFitScore: number
): number {
    // 時給スコア（0-10点）: 時給が高いほど高得点
    let hourlyScore = 0;
    if (hourlyRate >= 4000) hourlyScore = 10;
    else if (hourlyRate >= 3500) hourlyScore = 9;
    else if (hourlyRate >= 3000) hourlyScore = 8;
    else if (hourlyRate >= 2500) hourlyScore = 7;
    else if (hourlyRate >= 2000) hourlyScore = 6;
    else if (hourlyRate >= 1500) hourlyScore = 5;
    else if (hourlyRate >= 1000) hourlyScore = 4;
    else if (hourlyRate >= 500) hourlyScore = 3;
    else if (hourlyRate > 0) hourlyScore = 2;
    else hourlyScore = 0;

    // 工数スコア（0-10点）: 適度な工数（20-80時間）が高得点
    let workloadScore = 0;
    if (workloadHours >= 20 && workloadHours <= 80) {
        workloadScore = 10; // 最適範囲
    } else if (workloadHours >= 10 && workloadHours <= 120) {
        workloadScore = 8; // 良い範囲
    } else if (workloadHours >= 5 && workloadHours <= 160) {
        workloadScore = 6; // 許容範囲
    } else if (workloadHours > 0 && workloadHours <= 200) {
        workloadScore = 4; // 微妙な範囲
    } else {
        workloadScore = 2; // 極端な工数
    }

    // 係数システムによる総合スコア計算（スキル適性重視）
    const totalScore = (hourlyScore * EVALUATION_COEFFICIENTS.HOURLY) +
        (workloadScore * EVALUATION_COEFFICIENTS.WORKLOAD) +
        (skillFitScore * EVALUATION_COEFFICIENTS.SKILL_FIT);

    return Math.round(totalScore * 10) / 10; // 小数点1位まで
}

// 詳細データから元のタイトルを取得する関数
function getOriginalJobData(jobId: string, detailsData: any[]): any {
    return detailsData.find(job => job.jobId === jobId);
}

// 並列実行制御クラス
class ConcurrencyLimiter {
    private runningCount = 0;
    private queue: (() => Promise<void>)[] = [];

    constructor(private maxConcurrency: number) { }

    async execute<T>(task: () => Promise<T>): Promise<T> {
        return new Promise<T>((resolve, reject) => {
            const wrappedTask = async () => {
                try {
                    this.runningCount++;
                    const result = await task();
                    resolve(result);
                } catch (error) {
                    reject(error);
                } finally {
                    this.runningCount--;
                    this.processQueue();
                }
            };

            if (this.runningCount < this.maxConcurrency) {
                wrappedTask();
            } else {
                this.queue.push(wrappedTask);
            }
        });
    }

    private processQueue() {
        if (this.queue.length > 0 && this.runningCount < this.maxConcurrency) {
            const nextTask = this.queue.shift();
            if (nextTask) {
                nextTask();
            }
        }
    }
}

// メイン処理（非同期版）
async function calculateRecommendationScores(): Promise<void> {
    console.log('🔄 おすすめ点数計算を開始...');

    const scoredJobs: ScoredJob[] = [];

    // 詳細データも読み込む（元のタイトル取得用）
    let ecDetailsData: any[] = [];
    let webDetailsData: any[] = [];

    try {
        ecDetailsData = JSON.parse(readFileSync('details-ec.json', 'utf8'));
        console.log(`📂 EC詳細データ: ${ecDetailsData.length}件読み込み`);
    } catch (e) {
        console.log('⚠️ EC詳細データファイルが見つかりません');
    }

    try {
        webDetailsData = JSON.parse(readFileSync('details-web_products.json', 'utf8'));
        console.log(`📂 Web製品詳細データ: ${webDetailsData.length}件読み込み`);
    } catch (e) {
        console.log('⚠️ Web製品詳細データファイルが見つかりません');
    }

    // ECカテゴリの分析データ読み込み
    try {
        const ecData: AnalysisResult[] = JSON.parse(readFileSync('analyzed-ec.json', 'utf8'));
        ecData.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            const workloadHours = parseWorkloadHours(item.工数_見積もり);
            const difficultyScore = parseDifficultyScore(item.難易度);
            const skillFitScore = 5; // 仮のスキル適性スコア（後で更新）
            const recommendationScore = calculateRecommendationScore(hourlyRate, workloadHours, skillFitScore);

            const originalJob = getOriginalJobData(item.jobId, ecDetailsData);

            scoredJobs.push({
                ...item,
                category: 'EC',
                hourly_rate_numeric: hourlyRate,
                workload_hours: workloadHours,
                difficulty_score: difficultyScore,
                skill_fit_score: skillFitScore,
                recommendation_score: recommendationScore,
                link: `https://crowdworks.jp/public/jobs/${item.jobId}`,
                original_title: originalJob?.title || item.title
            });
        });
        console.log(`✅ ECカテゴリ: ${ecData.length}件処理完了`);
    } catch (e) {
        console.log('⚠️ ECカテゴリファイルが見つかりません: analyzed-ec.json');
    }

    // Web製品カテゴリの分析データ読み込み
    try {
        const webData: AnalysisResult[] = JSON.parse(readFileSync('analyzed-web_products.json', 'utf8'));
        webData.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            const workloadHours = parseWorkloadHours(item.工数_見積もり);
            const difficultyScore = parseDifficultyScore(item.難易度);
            const skillFitScore = 5; // 仮のスキル適性スコア（後で更新）
            const recommendationScore = calculateRecommendationScore(hourlyRate, workloadHours, skillFitScore);

            const originalJob = getOriginalJobData(item.jobId, webDetailsData);

            scoredJobs.push({
                ...item,
                category: 'Web製品',
                hourly_rate_numeric: hourlyRate,
                workload_hours: workloadHours,
                difficulty_score: difficultyScore,
                skill_fit_score: skillFitScore,
                recommendation_score: recommendationScore,
                link: `https://crowdworks.jp/public/jobs/${item.jobId}`,
                original_title: originalJob?.title || item.title
            });
        });
        console.log(`✅ Web製品カテゴリ: ${webData.length}件処理完了`);
    } catch (e) {
        console.log('⚠️ Web製品カテゴリファイルが見つかりません: analyzed-web_products.json');
    }

    if (scoredJobs.length === 0) {
        console.error('❌ データが読み込めませんでした');
        return;
    }

    // 全案件のスキル適性評価を実行
    console.log(`\n🧠 全案件のスキル適性評価中（最大5件並列）...`);

    const limiter = new ConcurrencyLimiter(5);
    let skillAnalysisCount = 0;

    const skillAnalysisPromises = scoredJobs.map(async (job, index) => {
        try {
            const allDetailsData = [...ecDetailsData, ...webDetailsData];
            const originalJob = getOriginalJobData(job.jobId, allDetailsData);

            const { score, analysis } = await limiter.execute(() =>
                analyzeSkillFit(job, originalJob)
            );

            job.skill_fit_score = score;
            job.skill_analysis = analysis;

            // スキル適性スコアでおすすめ点数を再計算
            job.recommendation_score = calculateRecommendationScore(
                job.hourly_rate_numeric,
                job.workload_hours,
                score
            );

            skillAnalysisCount++;
            console.log(`✅ [${skillAnalysisCount}/${scoredJobs.length}] ${job.original_title?.substring(0, 40)}... スキル適性評価完了`);

            return { success: true, index };
        } catch (error) {
            console.error(`❌ [${index + 1}/${scoredJobs.length}] スキル適性評価エラー:`, error);
            return { success: false, index };
        }
    });

    await Promise.allSettled(skillAnalysisPromises);
    console.log(`🎯 スキル適性評価完了: ${skillAnalysisCount}/${scoredJobs.length}件成功`);

    // おすすめ点数順でソート（高得点順）
    const sortedJobs = scoredJobs.sort((a, b) => b.recommendation_score - a.recommendation_score);

    // 統計情報表示
    const validJobs = sortedJobs.filter(j => j.hourly_rate_numeric > 0);
    if (validJobs.length > 0) {
        const maxScore = Math.max(...validJobs.map(j => j.recommendation_score));
        const minScore = Math.min(...validJobs.map(j => j.recommendation_score));
        const avgScore = Math.round((validJobs.reduce((sum, j) => sum + j.recommendation_score, 0) / validJobs.length) * 10) / 10;
        const avgSkillFit = Math.round((validJobs.reduce((sum, j) => sum + j.skill_fit_score, 0) / validJobs.length) * 10) / 10;

        console.log(`\n📈 統計情報:`);
        console.log(`最高おすすめ点数: ${maxScore}点`);
        console.log(`最低おすすめ点数: ${minScore}点`);
        console.log(`平均おすすめ点数: ${avgScore}点`);
        console.log(`平均スキル適性: ${avgSkillFit}点`);
        console.log(`有効案件: ${validJobs.length}件 / 全${sortedJobs.length}件`);
    }

    // TOP10案件に提案文生成を追加
    const top10Jobs = sortedJobs.slice(0, 10);
    console.log(`\n🤖 TOP10案件の提案文生成中（最大3件並列）...`);

    const proposalLimiter = new ConcurrencyLimiter(3); // 提案文生成は3件並列
    let proposalCount = 0;

    const proposalPromises = top10Jobs.map(async (job, index) => {
        try {
            const allDetailsData = [...ecDetailsData, ...webDetailsData];
            const originalJob = getOriginalJobData(job.jobId, allDetailsData);

            const { greeting, questions } = await proposalLimiter.execute(() =>
                generateProposalContent(job, originalJob)
            );

            job.proposal_greeting = greeting;
            job.specification_questions = questions;

            proposalCount++;
            console.log(`✅ [${proposalCount}/10] ${job.original_title?.substring(0, 40)}... 提案文生成完了`);

            return { success: true, index };
        } catch (error) {
            console.error(`❌ [${index + 1}/10] 提案文生成エラー:`, error);
            return { success: false, index };
        }
    });

    await Promise.allSettled(proposalPromises);
    console.log(`🎯 提案文生成完了: ${proposalCount}/10件成功`);

    // 結果表示（上位20件）
    console.log(`\n🏆 Webエンジニア向けおすすめ案件ランキング TOP20:\n`);

    sortedJobs.slice(0, 20).forEach((job, index) => {
        const rank = index + 1;
        const score = job.recommendation_score;
        const hourlyRate = job.hourly_rate_numeric.toLocaleString() + '円';
        const category = job.category || 'N/A';
        const difficulty = job.難易度 || 'N/A';
        const workload = job.工数_見積もり || 'N/A';
        const skillFit = job.skill_fit_score?.toFixed(1) || 'N/A';
        const summary = (job.gpt_summary || '').substring(0, 60) + '...';

        console.log(`${rank}位: ${score}点 | ${hourlyRate} (${category}) | 難易度: ${difficulty} | スキル適性: ${skillFit}点`);
        console.log(`   工数: ${workload}`);
        console.log(`   概要: ${summary}`);

        if (job.skill_analysis) {
            console.log(`   🧠 適性: ${job.skill_analysis.substring(0, 80)}...`);
        }

        // TOP10なら提案文も表示
        if (rank <= 10 && job.proposal_greeting) {
            console.log(`   💬 提案文: ${job.proposal_greeting.substring(0, 60)}...`);
        }
        console.log('');
    });

    // ファイルに保存
    const outputFileName = 'jobs-with-recommendation-scores.json';
    writeFileSync(outputFileName, JSON.stringify(sortedJobs, null, 2), 'utf8');
    console.log(`\n💾 結果を保存: ${outputFileName} (${sortedJobs.length}件)`);

    // Markdownファイルも生成
    const markdown = generateRecommendationMarkdown(sortedJobs.slice(0, 30)); // TOP30
    writeFileSync('recommended-jobs-top30.md', markdown, 'utf8');
    console.log(`📄 Markdownファイルを保存: recommended-jobs-top30.md`);
}

// Markdown生成関数
function generateRecommendationMarkdown(jobs: ScoredJob[]): string {
    const currentDate = new Date().toISOString().split('T')[0];

    let markdown = `# Webエンジニア向けおすすめ案件ランキング TOP30\n\n`;
    markdown += `> 生成日: ${currentDate}  \n`;
    markdown += `> 評価基準: 係数システム（時給×${EVALUATION_COEFFICIENTS.HOURLY} + 工数×${EVALUATION_COEFFICIENTS.WORKLOAD} + スキル適性×${EVALUATION_COEFFICIENTS.SKILL_FIT}）  \n`;
    markdown += `> 対象者: 高スキルWebエンジニア（デザインスキル低め）  \n`;
    markdown += `> 最高得点: ${Math.max(...jobs.map(j => j.recommendation_score))}点  \n`;
    markdown += `> 対象件数: ${jobs.length}件\n`;
    markdown += `> 💬 TOP10案件には戦略的提案文・質問を生成\n\n`;

    markdown += `## 👨‍💻 対象スキルプロフィール\n\n`;
    markdown += `- **高スキルWebエンジニア**（フロントエンド・バックエンド両方）\n`;
    markdown += `- **得意分野**: プログラミング・システム開発・API連携・DB設計・パフォーマンス最適化\n`;
    markdown += `- **苦手分野**: グラフィックデザイン・UI/UXデザイン（CSSスタイリング程度なら対応可能）\n\n`;

    markdown += `## 📊 評価基準の詳細\n\n`;
    markdown += `### 💰 時給スコア（係数：${EVALUATION_COEFFICIENTS.HOURLY}）\n`;
    markdown += `- 4000円以上: 10点 → ${10 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 3500円以上: 9点 → ${9 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 3000円以上: 8点 → ${8 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 2500円以上: 7点 → ${7 * EVALUATION_COEFFICIENTS.HOURLY}点\n`;
    markdown += `- 2000円以上: 6点 → ${6 * EVALUATION_COEFFICIENTS.HOURLY}点\n\n`;

    markdown += `### ⏰ 工数スコア（係数：${EVALUATION_COEFFICIENTS.WORKLOAD}）\n`;
    markdown += `- 20-80時間: 10点 → ${10 * EVALUATION_COEFFICIENTS.WORKLOAD}点（最適な工数）\n`;
    markdown += `- 10-120時間: 8点 → ${8 * EVALUATION_COEFFICIENTS.WORKLOAD}点（良い範囲）\n`;
    markdown += `- 5-160時間: 6点 → ${6 * EVALUATION_COEFFICIENTS.WORKLOAD}点（許容範囲）\n\n`;

    markdown += `### 🧠 スキル適性スコア（係数：${EVALUATION_COEFFICIENTS.SKILL_FIT}）\n`;
    markdown += `- 10点: 技術力を最大限活かせる案件（システム開発、API連携、パフォーマンス改善等）\n`;
    markdown += `- 8-9点: 技術スキルが重要な案件（WordPressカスタマイズ、EC機能開発等）\n`;
    markdown += `- 6-7点: 技術とデザインが半々（既存サイト修正、簡単なスタイリング等）\n`;
    markdown += `- 4-5点: デザイン要素が多い（レイアウト作成、ビジュアル重視等）\n`;
    markdown += `- 1-3点: 純粋なデザイン案件（グラフィック制作、UI/UXデザイン等）\n`;
    markdown += `- 0点: 完全にスキル外（イラスト制作、動画編集等）\n\n`;

    markdown += `## 🔧 係数の意味\n\n`;
    markdown += `- **時給係数 ${EVALUATION_COEFFICIENTS.HOURLY}**: 収益性重視\n`;
    markdown += `- **工数係数 ${EVALUATION_COEFFICIENTS.WORKLOAD}**: 適度な作業量をバランス評価\n`;
    markdown += `- **スキル適性係数 ${EVALUATION_COEFFICIENTS.SKILL_FIT}**: スキル適性を最重視（技術案件を優遇）\n`;
    markdown += `- **難易度**: 参考情報として表示（点数計算には含めない）\n\n`;

    const maxScore = (10 * EVALUATION_COEFFICIENTS.HOURLY) + (10 * EVALUATION_COEFFICIENTS.WORKLOAD) + (10 * EVALUATION_COEFFICIENTS.SKILL_FIT);
    markdown += `**最高理論値**: ${10 * EVALUATION_COEFFICIENTS.HOURLY} + ${10 * EVALUATION_COEFFICIENTS.WORKLOAD} + ${10 * EVALUATION_COEFFICIENTS.SKILL_FIT} = ${maxScore}点\n\n`;

    markdown += `## 🏆 ランキング\n\n`;

    jobs.forEach((job, index) => {
        const rank = index + 1;
        markdown += `### ${rank}位: ${job.recommendation_score}点 - [${job.original_title}](${job.link})\n\n`;
        markdown += `**💰 想定時給:** ${job.hourly_rate_numeric.toLocaleString()}円  \n`;
        markdown += `**🎯 難易度:** ${job.難易度}  \n`;
        markdown += `**⏰ 見積工数:** ${job.工数_見積もり}  \n`;
        markdown += `**🧠 スキル適性:** ${job.skill_fit_score?.toFixed(1)}点/10点  \n`;
        markdown += `**🏷️ カテゴリ:** ${job.category}  \n`;
        markdown += `**🔗 案件URL:** ${job.link}\n\n`;

        markdown += `**📝 分析概要:**  \n`;
        markdown += `${job.gpt_summary}\n\n`;

        if (job.skill_analysis) {
            markdown += `**🧠 スキル適性分析:**  \n`;
            markdown += `${job.skill_analysis}\n\n`;
        }

        // TOP10なら提案文と質問も追加
        if (rank <= 10 && job.proposal_greeting && job.specification_questions) {
            markdown += `**💬 戦略的提案文:**  \n`;
            markdown += `${job.proposal_greeting}\n\n`;

            markdown += `**❓ 仕様確認質問:**  \n`;
            markdown += `${job.specification_questions}\n\n`;
        }

        markdown += `---\n\n`;
    });

    return markdown;
}

// GPTで提案用挨拶文と仕様質問を生成する関数
async function generateProposalContent(job: AnalysisResult, originalJob: any): Promise<{ greeting: string; questions: string }> {
    const prompt = `以下のクラウドワークス案件に応募する際の戦略的な挨拶文と仕様確認質問を作成してください。

【案件情報】
タイトル: ${job.title}
詳細説明: ${originalJob?.detailedDescription || '詳細不明'}
想定時給: ${job.想定時給}
見積工数: ${job.工数_見積もり}
難易度: ${job.難易度}

【要求内容】
1. **挨拶文**: プロフェッショナルで親しみやすい、簡潔な自己紹介（2-3行）
2. **仕様確認質問**: 案件を確実に成功させるための具体的な質問（3-5個）

【挨拶文のポイント】
- 経験と専門性をアピール
- 案件への真剣な取り組み姿勢を示す
- クライアントの課題解決に焦点

【質問のポイント】
- 曖昧な部分の明確化
- 成果物の具体的な要求仕様
- 納期やコミュニケーション方法
- 想定される課題やリスクの確認
- 成功基準の明確化

【出力フォーマット】
挨拶文:
<挨拶文をここに>

質問:
1. <質問1>
2. <質問2>
3. <質問3>
4. <質問4>
5. <質問5>`;

    try {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは経験豊富なフリーランサーで、クラウドワークス案件への効果的な提案文作成の専門家です。クライアントの信頼を得て、案件を受注するための戦略的なコミュニケーションに長けています。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 800,
            temperature: 0.3,
        });

        const text = res.choices[0]?.message?.content || '';

        // 挨拶文と質問を分離
        const greetingMatch = text.match(/挨拶文[:：]\s*([\s\S]*?)(?=質問[:：]|$)/);
        const questionsMatch = text.match(/質問[:：]\s*([\s\S]*)/);

        const greeting = greetingMatch?.[1]?.trim() || '';
        const questions = questionsMatch?.[1]?.trim() || '';

        return { greeting, questions };
    } catch (e) {
        console.error(`❌ 提案文生成エラー (${job.jobId}):`, e);
        return { greeting: '', questions: '' };
    }
}

// GPTでスキル適性を評価する関数
async function analyzeSkillFit(job: AnalysisResult, originalJob: any): Promise<{ score: number; analysis: string }> {
    const prompt = `以下のクラウドワークス案件を、高スキルWebエンジニアの視点で評価してください。

【依頼者のスキルプロフィール】
- 高スキルWebエンジニア（フロントエンド・バックエンド両方）
- プログラミング・システム開発・API連携が得意
- データベース設計・パフォーマンス最適化などの技術力高い
- デザインスキルは低い（グラフィックデザイン・UI/UXデザインは苦手）
- CSSスタイリング程度なら対応可能

【案件情報】
タイトル: ${job.title}
詳細説明: ${originalJob?.detailedDescription || '詳細不明'}
カテゴリ: ${job.category}
難易度: ${job.難易度}

【評価基準】
スキル適性スコア（0-10点）:
- 10点: 技術力を最大限活かせる案件（システム開発、API連携、パフォーマンス改善等）
- 8-9点: 技術スキルが重要な案件（WordPressカスタマイズ、EC機能開発等）
- 6-7点: 技術とデザインが半々（既存サイト修正、簡単なスタイリング等）
- 4-5点: デザイン要素が多い（レイアウト作成、ビジュアル重視等）
- 1-3点: 純粋なデザイン案件（グラフィック制作、UI/UXデザイン等）
- 0点: 完全にスキル外（イラスト制作、動画編集等）

【出力フォーマット】
スコア: <0-10の数値>
分析: <なぜそのスコアなのか、技術的な観点での評価理由を2-3行で>`;

    try {
        const res = await openai.chat.completions.create({
            model: 'gpt-4o',
            messages: [
                { role: 'system', content: 'あなたは技術人材のスキルマッチング専門家で、Webエンジニアの技術力と案件要件を正確に評価できます。デザインスキルの有無を考慮した実用的な評価を行います。' },
                { role: 'user', content: prompt }
            ],
            max_tokens: 300,
            temperature: 0.2,
        });

        const text = res.choices[0]?.message?.content || '';

        // スコアと分析を分離
        const scoreMatch = text.match(/スコア[:：]\s*([0-9.]+)/);
        const analysisMatch = text.match(/分析[:：]\s*([\s\S]*)/);

        const score = scoreMatch?.[1] ? parseFloat(scoreMatch[1]) : 5;
        const analysis = analysisMatch?.[1]?.trim() || '';

        return { score: Math.max(0, Math.min(10, score)), analysis };
    } catch (e) {
        console.error(`❌ スキル適性分析エラー (${job.jobId}):`, e);
        return { score: 5, analysis: '分析エラー' };
    }
}

// 実行
(async () => {
    await calculateRecommendationScores();
})();
</file>

<file path="scripts/collect-development-categories.ts">
#!/usr/bin/env node
import { writeFileSync } from 'fs';
import { scrapeCrowdWorksJobsByCategoryWithDetails } from '../src/lambda/handler';

// 開発系カテゴリのリスト
const DEVELOPMENT_CATEGORIES = [
    'development',
    'software_development'
];

async function collectDevelopmentJobs(): Promise<void> {
    console.log('🚀 開発系カテゴリのデータ収集を開始...');

    for (const category of DEVELOPMENT_CATEGORIES) {
        try {
            console.log(`\n📂 カテゴリ「${category}」の収集開始...`);

            const result = await scrapeCrowdWorksJobsByCategoryWithDetails({
                category: category,
                maxJobs: 50,        // 多めに収集
                maxDetails: 30      // 詳細も多めに取得
            });

            // 基本データを保存
            const jobsFileName = `crowdworks-${category}-jobs-${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
            const jobsData = {
                category: category,
                scrapedAt: new Date().toISOString(),
                totalJobs: result.jobs.length,
                executionTime: 0, // 実際の実行時間は個別に計測
                jobs: result.jobs
            };

            writeFileSync(jobsFileName, JSON.stringify(jobsData, null, 2), 'utf8');
            console.log(`✅ 基本データ保存: ${jobsFileName} (${result.jobs.length}件)`);

            // 詳細データを保存
            if (result.jobDetails.length > 0) {
                const detailsFileName = `details-${category}.json`;
                writeFileSync(detailsFileName, JSON.stringify(result.jobDetails, null, 2), 'utf8');
                console.log(`✅ 詳細データ保存: ${detailsFileName} (${result.jobDetails.length}件)`);
            }

            // 統計情報表示
            console.log(`📊 カテゴリ「${category}」収集完了:`);
            console.log(`   - 基本データ: ${result.jobs.length}件`);
            console.log(`   - 詳細データ: ${result.jobDetails.length}件`);

            // 少し待機（APIへの負荷軽減）
            await new Promise(resolve => setTimeout(resolve, 3000));

        } catch (error) {
            console.error(`❌ カテゴリ「${category}」でエラー:`, error);
            continue;
        }
    }

    console.log('\n🎉 開発系カテゴリの収集完了！');
}

// 実行
if (require.main === module) {
    collectDevelopmentJobs().catch(console.error);
}

export { collectDevelopmentJobs };
</file>

<file path="scripts/extract-high-hourly-jobs.ts">
require('dotenv').config();

import { readFileSync, writeFileSync } from 'fs';

// 型定義
interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    gpt_summary: string;
    category?: string;
}

interface HighHourlyJob extends AnalysisResult {
    hourly_rate_numeric: number;
    link: string;
    original_title?: string;
}

// 時給文字列を数値に変換する関数
function parseHourlyRate(hourlyRateString: string): number {
    if (!hourlyRateString || hourlyRateString.trim() === '' || hourlyRateString === '0円') {
        return 0;
    }

    const match = hourlyRateString.match(/([0-9,]+)/);
    if (match && match[1]) {
        const numericString = match[1].replace(/,/g, '');
        return parseInt(numericString, 10);
    }

    return 0;
}

// 詳細データから元のタイトルを取得する関数
function getOriginalJobData(jobId: string, detailsData: any[]): any {
    return detailsData.find(job => job.jobId === jobId);
}

// メイン処理
function extractHighHourlyJobs(): void {
    console.log('🔄 時給3000円以上の案件抽出を開始...');

    const highHourlyJobs: HighHourlyJob[] = [];
    const minHourlyRate = 3000;

    // 詳細データも読み込む（元のタイトル取得用）
    let ecDetailsData: any[] = [];
    let webDetailsData: any[] = [];

    try {
        ecDetailsData = JSON.parse(readFileSync('details-ec.json', 'utf8'));
        console.log(`📂 EC詳細データ: ${ecDetailsData.length}件読み込み`);
    } catch (e) {
        console.log('⚠️ EC詳細データファイルが見つかりません');
    }

    try {
        webDetailsData = JSON.parse(readFileSync('details-web_products.json', 'utf8'));
        console.log(`📂 Web製品詳細データ: ${webDetailsData.length}件読み込み`);
    } catch (e) {
        console.log('⚠️ Web製品詳細データファイルが見つかりません');
    }

    // ECカテゴリの分析データ読み込み
    try {
        const ecData: AnalysisResult[] = JSON.parse(readFileSync('analyzed-ec.json', 'utf8'));
        ecData.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            if (hourlyRate >= minHourlyRate) {
                const originalJob = getOriginalJobData(item.jobId, ecDetailsData);
                highHourlyJobs.push({
                    ...item,
                    category: 'EC',
                    hourly_rate_numeric: hourlyRate,
                    link: `https://crowdworks.jp/public/jobs/${item.jobId}`,
                    original_title: originalJob?.title || item.title
                });
            }
        });
        console.log(`✅ ECカテゴリ: ${ecData.length}件中 ${ecData.filter(item => parseHourlyRate(item.想定時給) >= minHourlyRate).length}件が対象`);
    } catch (e) {
        console.log('⚠️ ECカテゴリファイルが見つかりません: analyzed-ec.json');
    }

    // Web製品カテゴリの分析データ読み込み
    try {
        const webData: AnalysisResult[] = JSON.parse(readFileSync('analyzed-web_products.json', 'utf8'));
        webData.forEach(item => {
            const hourlyRate = parseHourlyRate(item.想定時給);
            if (hourlyRate >= minHourlyRate) {
                const originalJob = getOriginalJobData(item.jobId, webDetailsData);
                highHourlyJobs.push({
                    ...item,
                    category: 'Web製品',
                    hourly_rate_numeric: hourlyRate,
                    link: `https://crowdworks.jp/public/jobs/${item.jobId}`,
                    original_title: originalJob?.title || item.title
                });
            }
        });
        console.log(`✅ Web製品カテゴリ: ${webData.length}件中 ${webData.filter(item => parseHourlyRate(item.想定時給) >= minHourlyRate).length}件が対象`);
    } catch (e) {
        console.log('⚠️ Web製品カテゴリファイルが見つかりません: analyzed-web_products.json');
    }

    if (highHourlyJobs.length === 0) {
        console.error('❌ 対象案件が見つかりませんでした');
        return;
    }

    // 時給順でソート（高額順）
    const sortedJobs = highHourlyJobs.sort((a, b) => b.hourly_rate_numeric - a.hourly_rate_numeric);

    // Markdownファイル生成
    const markdown = generateMarkdown(sortedJobs, minHourlyRate);
    const outputFileName = `high-hourly-jobs-3000+.md`;

    writeFileSync(outputFileName, markdown, 'utf8');
    console.log(`\n💾 Markdownファイルを保存: ${outputFileName}`);
    console.log(`📊 抽出件数: ${sortedJobs.length}件`);
    console.log(`💰 最高時給: ${Math.max(...sortedJobs.map(j => j.hourly_rate_numeric)).toLocaleString()}円`);
}

// Markdown生成関数
function generateMarkdown(jobs: HighHourlyJob[], minRate: number): string {
    const currentDate = new Date().toISOString().split('T')[0];

    let markdown = `# 高時給案件一覧（${minRate}円以上）\n\n`;
    markdown += `> 生成日: ${currentDate}  \n`;
    markdown += `> 対象: 時給${minRate.toLocaleString()}円以上の案件  \n`;
    markdown += `> 総件数: ${jobs.length}件  \n`;
    markdown += `> 注意: 工数見積もりには要件定義、打ち合わせ、修正作業などの前作業も含まれています\n\n`;

    markdown += `## 📊 概要\n\n`;
    markdown += `| 統計項目 | 値 |\n`;
    markdown += `|----------|----|\n`;
    markdown += `| 最高時給 | ${Math.max(...jobs.map(j => j.hourly_rate_numeric)).toLocaleString()}円 |\n`;
    markdown += `| 最低時給 | ${Math.min(...jobs.map(j => j.hourly_rate_numeric)).toLocaleString()}円 |\n`;
    markdown += `| 平均時給 | ${Math.round(jobs.reduce((sum, j) => sum + j.hourly_rate_numeric, 0) / jobs.length).toLocaleString()}円 |\n`;
    markdown += `| EC案件数 | ${jobs.filter(j => j.category === 'EC').length}件 |\n`;
    markdown += `| Web製品案件数 | ${jobs.filter(j => j.category === 'Web製品').length}件 |\n\n`;

    markdown += `## 💼 案件一覧\n\n`;

    jobs.forEach((job, index) => {
        markdown += `### ${index + 1}. [${job.original_title}](${job.link})\n\n`;
        markdown += `**💰 想定時給:** ${job.hourly_rate_numeric.toLocaleString()}円  \n`;
        markdown += `**⏰ 見積工数:** ${job.工数_見積もり}  \n`;
        markdown += `**🏷️ カテゴリ:** ${job.category}  \n`;
        markdown += `**🔗 案件URL:** ${job.link}\n\n`;
        markdown += `**📝 分析概要:**  \n`;
        markdown += `${job.gpt_summary}\n\n`;
        markdown += `---\n\n`;
    });

    markdown += `## 📋 注記\n\n`;
    markdown += `- 時給は「要件定義」「打ち合わせ」「修正作業」「テスト」「納品後サポート」などの付帯作業も含めた現実的な工数見積もりに基づいています\n`;
    markdown += `- 案件の詳細は各リンクをクリックしてクラウドワークスのページでご確認ください\n`;
    markdown += `- 時給計算はGPT-4oによる分析結果であり、実際の作業時間や報酬は異なる場合があります\n`;
    markdown += `- 案件の募集状況は変動するため、リンク先で最新情報をご確認ください\n`;

    return markdown;
}

// 実行
extractHighHourlyJobs();
</file>

<file path="scripts/sort-by-hourly-rate.ts">
require('dotenv').config();

import { readFileSync, writeFileSync } from 'fs';

// 型定義
interface AnalysisResult {
    jobId: string;
    title: string;
    工数_見積もり: string;
    想定時給: string;
    gpt_summary: string;
    category?: string; // カテゴリ情報を追加
}

interface SortedResult extends AnalysisResult {
    hourly_rate_numeric: number; // 数値化した時給
}

// 時給文字列を数値に変換する関数
function parseHourlyRate(hourlyRateString: string): number {
    if (!hourlyRateString || hourlyRateString.trim() === '' || hourlyRateString === '0円') {
        return 0;
    }

    // 「3000円」「1,500円」「2500円」などから数値を抽出
    const match = hourlyRateString.match(/([0-9,]+)/);
    if (match && match[1]) {
        const numericString = match[1].replace(/,/g, ''); // カンマを除去
        return parseInt(numericString, 10);
    }

    return 0;
}

// ソート種別
type SortOrder = 'high' | 'low';

// メイン処理
function sortAnalysisResults(order: SortOrder = 'high'): void {
    console.log(`🔄 想定時給による${order === 'high' ? '高額順' : '低額順'}ソートを開始...`);

    const results: SortedResult[] = [];

    // ECカテゴリのデータ読み込み
    try {
        const ecData: AnalysisResult[] = JSON.parse(readFileSync('analyzed-ec.json', 'utf8'));
        ecData.forEach(item => {
            results.push({
                ...item,
                category: 'EC',
                hourly_rate_numeric: parseHourlyRate(item.想定時給)
            });
        });
        console.log(`✅ ECカテゴリ: ${ecData.length}件読み込み`);
    } catch (e) {
        console.log(`⚠️ ECカテゴリファイルが見つかりません: analyzed-ec.json`);
    }

    // Web製品カテゴリのデータ読み込み
    try {
        const webData: AnalysisResult[] = JSON.parse(readFileSync('analyzed-web_products.json', 'utf8'));
        webData.forEach(item => {
            results.push({
                ...item,
                category: 'Web製品',
                hourly_rate_numeric: parseHourlyRate(item.想定時給)
            });
        });
        console.log(`✅ Web製品カテゴリ: ${webData.length}件読み込み`);
    } catch (e) {
        console.log(`⚠️ Web製品カテゴリファイルが見つかりません: analyzed-web_products.json`);
    }

    if (results.length === 0) {
        console.error('❌ データが読み込めませんでした');
        return;
    }

    // ソート実行
    const sortedResults = results.sort((a, b) => {
        if (order === 'high') {
            return b.hourly_rate_numeric - a.hourly_rate_numeric; // 高額順
        } else {
            return a.hourly_rate_numeric - b.hourly_rate_numeric; // 低額順
        }
    });

    console.log(`🔍 ソート完了: ${sortedResults.length}件`);

    // 統計情報を先に表示
    const validResults = sortedResults.filter(r => r.hourly_rate_numeric > 0);
    if (validResults.length > 0) {
        const maxRate = Math.max(...validResults.map(r => r.hourly_rate_numeric));
        const minRate = Math.min(...validResults.map(r => r.hourly_rate_numeric));
        const avgRate = Math.round(validResults.reduce((sum, r) => sum + r.hourly_rate_numeric, 0) / validResults.length);

        console.log(`\n📈 統計情報:`);
        console.log(`最高時給: ${maxRate.toLocaleString()}円`);
        console.log(`最低時給: ${minRate.toLocaleString()}円`);
        console.log(`平均時給: ${avgRate.toLocaleString()}円`);
        console.log(`有効案件: ${validResults.length}件 / 全${sortedResults.length}件`);
    }

    // 結果表示（上位20件）
    console.log(`\n📊 ${order === 'high' ? '高時給' : '低時給'}ランキング TOP20:\n`);

    // 表示用データを準備（0円案件を除外）
    const displayResults = order === 'low'
        ? sortedResults.filter(r => r.hourly_rate_numeric > 0)
        : sortedResults;

    console.log(`📋 表示対象: ${displayResults.length}件`);

    displayResults.slice(0, 20).forEach((item, index) => {
        const rank = index + 1;
        const hourlyRate = item.hourly_rate_numeric.toLocaleString() + '円';
        const category = item.category || 'N/A';
        const workHours = item.工数_見積もり || 'N/A';
        const summary = (item.gpt_summary || '').substring(0, 50) + '...';

        console.log(`${rank}位: ${hourlyRate} (${category}) - 工数: ${workHours}`);
        console.log(`   概要: ${summary}\n`);
    });

    // ファイルに保存
    const outputFileName = `sorted-by-hourly-rate-${order}.json`;
    writeFileSync(outputFileName, JSON.stringify(sortedResults, null, 2), 'utf8');
    console.log(`\n💾 結果を保存: ${outputFileName} (${sortedResults.length}件)`);
}

// コマンドライン引数取得
const [, , sortOrder] = process.argv;
const order: SortOrder = (sortOrder === 'low') ? 'low' : 'high';

// 実行
sortAnalysisResults(order);
</file>

<file path=".prettierrc">
{
    "semi": true,
    "trailingComma": "es5",
    "singleQuote": true,
    "printWidth": 100,
    "tabWidth": 2,
    "useTabs": false,
    "bracketSpacing": true,
    "arrowParens": "avoid",
    "endOfLine": "lf",
    "quoteProps": "as-needed",
    "bracketSameLine": false,
    "embeddedLanguageFormatting": "auto"
}
</file>

<file path="cdk.json">
{
    "app": "npx ts-node --prefer-ts-exts app.ts",
    "watch": {
        "include": [
            "**"
        ],
        "exclude": [
            "README.md",
            "cdk*.json",
            "**/*.d.ts",
            "**/*.js",
            "tsconfig.json",
            "package*.json",
            "yarn.lock",
            "node_modules",
            "test"
        ]
    },
    "context": {
        "@aws-cdk/aws-lambda:recognizeLayerVersion": true,
        "@aws-cdk/core:checkSecretUsage": true,
        "@aws-cdk/core:target-partitions": [
            "aws",
            "aws-cn"
        ],
        "@aws-cdk-containers/ecs-service-extensions:enableDefaultLogDriver": true,
        "@aws-cdk/aws-ec2:uniqueImdsv2TemplateName": true,
        "@aws-cdk/aws-ecs:arnFormatIncludesClusterName": true,
        "@aws-cdk/aws-iam:minimizePolicies": true,
        "@aws-cdk/core:validateSnapshotRemovalPolicy": true,
        "@aws-cdk/aws-codepipeline:crossAccountKeyAliasStackSafeResourceName": true,
        "@aws-cdk/aws-s3:createDefaultLoggingPolicy": true,
        "@aws-cdk/aws-sns-subscriptions:restrictSqsDescryption": true,
        "@aws-cdk/aws-apigateway:disableCloudWatchRole": true,
        "@aws-cdk/core:enablePartitionLiterals": true,
        "@aws-cdk/aws-events:eventsTargetQueueSameAccount": true,
        "@aws-cdk/aws-iam:standardizedServicePrincipals": true,
        "@aws-cdk/aws-ecs:disableExplicitDeploymentControllerForCircuitBreaker": true,
        "@aws-cdk/aws-iam:importedRoleStackSafeDefaultPolicyName": true,
        "@aws-cdk/aws-s3:serverAccessLogsUseBucketPolicy": true,
        "@aws-cdk/aws-route53-patters:useCertificate": true,
        "@aws-cdk/customresources:installLatestAwsSdkDefault": false,
        "@aws-cdk/aws-rds:databaseProxyUniqueResourceName": true,
        "@aws-cdk/aws-codedeploy:removeAlarmsFromDeploymentGroup": true,
        "@aws-cdk/aws-apigateway:authorizerChangeDeploymentLogicalId": true,
        "@aws-cdk/aws-ec2:launchTemplateDefaultUserData": true,
        "@aws-cdk/aws-secretsmanager:useAttachedSecretResourcePolicyForSecretTargetAttachments": true,
        "@aws-cdk/aws-redshift:columnId": true,
        "@aws-cdk/aws-stepfunctions-tasks:enableLoggingForLambdaTask": true,
        "@aws-cdk/aws-ec2:restrictDefaultSecurityGroup": true,
        "@aws-cdk/aws-apigateway:requestValidatorUniqueId": true,
        "@aws-cdk/aws-kms:aliasNameRef": true,
        "@aws-cdk/aws-autoscaling:generateLaunchTemplateInsteadOfLaunchConfig": true,
        "@aws-cdk/core:includePrefixInUniqueNameGeneration": true,
        "@aws-cdk/aws-efs:denyAnonymousAccess": true,
        "@aws-cdk/aws-opensearchservice:enableOpensearchMultiAzWithStandby": true,
        "@aws-cdk/aws-lambda-nodejs:useLatestRuntimeVersion": true,
        "@aws-cdk/aws-efs:mountTargetOrderInsensitiveLogicalId": true,
        "@aws-cdk/aws-rds:auroraClusterChangeScopeOfInstanceParameterGroupWithEachParameters": true,
        "@aws-cdk/aws-appsync:useArnForSourceApiAssociationIdentifier": true,
        "@aws-cdk/aws-rds:preventRenderingDeprecatedCredentials": true,
        "@aws-cdk/aws-codepipeline-actions:useNewDefaultBranchForSourceAction": true
    }
}
</file>

<file path="crowdworks-ec-jobs-2025-06-04T23-52-12-130Z.json">
{
  "category": "ec",
  "scrapedAt": "2025-06-04T23:52:12.130Z",
  "totalJobs": 5,
  "executionTime": 11117,
  "jobs": [
    {
      "id": "12156271",
      "title": "【完全在宅、長期】Amazonの商品画像作成依頼",
      "description": "新着【完全在宅、長期】Amazonの商品画像作成依頼ECサイトデザイン【 概要 】\r\n弊社はカー用品などの雑貨を企画、販売している会社です。\r\nこの度はAmazonで販売する商品の画像デザインをして頂ける方を募集させて頂きます。\r\n\r\n【 依頼内容 】\r\n下記のどちらかを依頼したいと考えております。\r\n...固定報酬制 契約金額はワーカーと相談する  契約数 0人  (募集人数 1人) あと 7 日（6月12日まで）sn991020掲載日：2025年06月05日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12156271",
      "budget": {
        "type": "fixed",
        "amount": 0,
        "currency": "JPY"
      },
      "category": "ec",
      "tags": [
        "Amazon",
        "サイトデザイン",
        "Amazon",
        "デザイン",
        "ワーカー"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月05日",
      "deadline": "6月12日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:12.127Z"
    },
    {
      "id": "11895158",
      "title": "アマゾン出品のための簡単な商品リサーチ",
      "description": "新着アマゾン出品のための簡単な商品リサーチECサイト制作【 概要 】\r\n\r\nアマゾンで出品するための商品のリサーチをお願いします。\r\n\r\n\r\n業務拡大のため、急遽スタッフを募集いたします。\r\n\r\n\r\n\r\n\r\n【作業内容】\r\n\r\n①リサーチして商品を探す\r\n\r\n②スプレットシートに入力\r\n\r...固定報酬制 〜 5,000円  契約数 3人  (募集人数 5人) あと 13 日（6月18日まで）ひかり222掲載日：2025年06月05日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/11895158",
      "budget": {
        "type": "fixed",
        "amount": 5000,
        "currency": "JPY"
      },
      "category": "ec",
      "tags": [
        "アマゾン",
        "リサーチEC",
        "サイト",
        "アマゾン",
        "リサーチ",
        "スタッフ",
        "リサーチ",
        "スプレットシート"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月05日",
      "deadline": "6月18日",
      "applicants": 3,
      "scrapedAt": "2025-06-04T23:52:12.127Z"
    },
    {
      "id": "12155324",
      "title": "【急募】EC-CUBEでのデザイン・コーディング業務",
      "description": "新着【急募】EC-CUBEでのデザイン・コーディング業務ECサイト制作※急募のため、早く決まり次第、終了させていただきます。\r\n\r\n【 概要 】\r\nEC-CUBEで構築された健康・ヘルスケアジャンルのECサイトのデザイン・コーディングをお願いいたします。\r\n\r\n【 依頼内容 】\r\n・Figmaのデザイン...時間単価制1,000円 〜 1,500円 契約数 0人  (募集人数 1人) あと 13 日（6月18日まで）WebデザインgithubEC-CUBESEOコンサル│ルジュ掲載日：2025年06月04日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12155324",
      "budget": {
        "type": "hourly",
        "amount": 1000,
        "currency": "JPY"
      },
      "category": "ec",
      "tags": [
        "CUBE",
        "デザイン",
        "コーディング",
        "サイト",
        "CUBE",
        "ヘルスケアジャンル",
        "サイト",
        "デザイン",
        "コーディング",
        "Figma"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月04日",
      "deadline": "6月18日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:12.127Z"
    },
    {
      "id": "12155322",
      "title": "【専門家レビュー・監修パートナー募集】【快眠＆旅行のプロを大募集】360°首サポート × 超軽量収納の次世代ネックピロー",
      "description": "新着【専門家レビュー・監修パートナー募集】【快眠＆旅行のプロを大募集】360°首サポート × 超軽量収納の次世代ネックピローECサイト制作以下の分野でご活躍されている方を歓迎いたします：整体師・カイロプラクター（姿勢ケア、首や肩のサポートに携わる方）理学療法士（頸部の可動域や筋緊張に詳しい方）パーソナルトレーナー・ボディケアインストラクター（筋疲労回復やトラベルケア指導...固定報酬制 契約金額はワーカーと相談する  契約数 0人  (募集人数 3人) あと 13 日（6月18日まで）joychou掲載日：2025年06月04日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12155322",
      "budget": {
        "type": "fixed",
        "amount": 0,
        "currency": "JPY"
      },
      "category": "ec",
      "tags": [
        "レビュー",
        "パートナー",
        "サポート",
        "ネックピローEC",
        "サイト",
        "カイロプラクター",
        "サポート",
        "パーソナルトレーナー",
        "ボディケアインストラクター",
        "トラベルケア"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月04日",
      "deadline": "6月18日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:12.127Z"
    },
    {
      "id": "12155277",
      "title": "【商品監修依頼】【3D立体型-圧迫感なし・遮光率99.99％】アイマスク ホット 睡眠用",
      "description": "新着【商品監修依頼】【3D立体型-圧迫感なし・遮光率99.99％】アイマスク ホット 睡眠用ECサイト制作この度は当ページを閲覧いただきまして、誠にありがとうございます!\r\n\r\n弊社で開発中の商品「\r\n\r\nホットアイマスク 充電式【3D立体型-圧迫感なし・遮光率99.99％】アイマスク ホット 睡眠用\r\n\r\n」の監修を担ってくださる方を募...固定報酬制 契約金額はワーカーと相談する  契約数 0人  (募集人数 3人) あと 13 日（6月18日まで）joychou掲載日：2025年06月04日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12155277",
      "budget": {
        "type": "fixed",
        "amount": 0,
        "currency": "JPY"
      },
      "category": "ec",
      "tags": [
        "アイマスク",
        "ホット",
        "サイト",
        "ページ",
        "ホットアイマスク",
        "アイマスク",
        "ホット",
        "ワーカー",
        "joychou"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月04日",
      "deadline": "6月18日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:12.128Z"
    }
  ]
}
</file>

<file path="crowdworks-web_products-jobs-2025-06-04T23-52-25-027Z.json">
{
  "category": "web_products",
  "scrapedAt": "2025-06-04T23:52:25.027Z",
  "totalJobs": 5,
  "executionTime": 10884,
  "jobs": [
    {
      "id": "12131254",
      "title": "【初心者OK】【実績作りに】WEBデザイナーに役立つ講義コンテンツの感想・アンケートの回答をしていただける方を募集中です！",
      "description": "PR【初心者OK】【実績作りに】WEBデザイナーに役立つ講義コンテンツの感想・アンケートの回答をしていただける方を募集中です！ウェブデザイン\r\n※初心者歓迎、大量採用中です！\r\n\r\n【 概要 】\r\n\r\n今回、WEBデザイン講義のコンテンツ改善のため、その感想をいただくお仕事の募集です。\r\n\r\n特にWEBデザイナー初心者さんにとっては、\r\n純粋に、スキルアップにもつながり、...固定報酬制250,000円 〜 300,000円  契約数 72人  (募集人数 21人〜) あと 6 日（6月11日まで）anke7562掲載日：2025年05月28日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12131254",
      "budget": {
        "type": "fixed",
        "amount": 250000,
        "currency": "JPY"
      },
      "category": "web_products",
      "tags": [
        "WEB",
        "デザイナー",
        "コンテンツ",
        "アンケート",
        "ウェブデザイン",
        "WEB",
        "デザイン",
        "コンテンツ",
        "WEB",
        "デザイナー"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年05月28日",
      "deadline": "6月11日",
      "applicants": 72,
      "scrapedAt": "2025-06-04T23:52:25.025Z"
    },
    {
      "id": "12146187",
      "title": "【UI/UXデザイナー】時給2,178円〜／完全在宅◎フルリモート×フレックス｜Webサービス企業",
      "description": "PR【UI/UXデザイナー】時給2,178円〜／完全在宅◎フルリモート×フレックス｜Webサービス企業UI/UX設計・デザイン＼LINE・Instagramを活用したWebサービス企業のUI/UXデザイナーを募集／\r\n\r\n【株式会社ミショナについて】\r\n\r\n弊社は、DXを通じて事業者の生産性向上をサポートする会社です。\r\n\r\n中小企業が直面する人材不足や業務...時間単価制2,000円 〜 3,000円 契約数 4人  (募集人数 5人) あと 11 日（6月16日まで）株式会社ミショナ採用掲載日：2025年06月02日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12146187",
      "budget": {
        "type": "hourly",
        "amount": 2178,
        "currency": "JPY"
      },
      "category": "web_products",
      "tags": [
        "デザイナー",
        "フルリモート",
        "フレックス",
        "Web",
        "サービス",
        "デザイン",
        "LINE",
        "Instagram",
        "Web",
        "サービス"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月02日",
      "deadline": "6月16日",
      "applicants": 4,
      "scrapedAt": "2025-06-04T23:52:25.025Z"
    },
    {
      "id": "12156312",
      "title": "集客特化型ランディングページ制作",
      "description": "新着集客特化型ランディングページ制作ランディングページ（LP）制作【 概要 】\r\n今回、問い合わせ向上のためのランディングページ制作をお願いします。\r\n\r\n【 依頼内容 】\r\n・依頼工程：構成、ライティング。デザイン、コーディング、レスポンシブ対応\r\n・作業ボリューム：1ページ程度 など\r\n\r\n【 ...固定報酬制 契約金額はワーカーと相談する  契約数 0人  (募集人数 1人) あと 14 日（6月19日まで）webr.o掲載日：2025年06月05日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12156312",
      "budget": {
        "type": "fixed",
        "amount": 0,
        "currency": "JPY"
      },
      "category": "web_products",
      "tags": [
        "ランディングページ",
        "ランディングページ",
        "ランディングページ",
        "ライティング",
        "デザイン",
        "コーディング",
        "レスポンシブ",
        "ボリューム",
        "ページ",
        "ワーカー"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月05日",
      "deadline": "6月19日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:25.025Z"
    },
    {
      "id": "12155261",
      "title": "【美容・エステ業界経験者歓迎｜SNS運用サポート募集】",
      "description": "新着【美容・エステ業界経験者歓迎｜SNS運用サポート募集】ウェブデザイン在宅OK｜未経験・副業初心者も歓迎！\r\n一緒に“キレイ”を届けるSNSを育てていきませんか？\r\n美容・エステ・セルフケアなど、美意識を高める発信を行っているSNSチームでマーケティングに携わっています。\r\nこのたび事業拡大に伴い、In...固定報酬制11,000円  契約数 0人  (募集人数 3人) あと 6 日（6月11日まで）igaiga1134掲載日：2025年06月05日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12155261",
      "budget": {
        "type": "fixed",
        "amount": 11000,
        "currency": "JPY"
      },
      "category": "web_products",
      "tags": [
        "エステ",
        "SNS",
        "サポート",
        "ウェブデザイン",
        "キレイ",
        "SNS",
        "エステ",
        "セルフケア",
        "SNS",
        "チーム"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月05日",
      "deadline": "6月11日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:25.025Z"
    },
    {
      "id": "12154968",
      "title": "【保育士・教育関連のSNS運用サポート募集】 在宅OK｜未経験・副業初心者も歓迎！一緒にSNSを育てていきませんか？",
      "description": "新着【保育士・教育関連のSNS運用サポート募集】 在宅OK｜未経験・副業初心者も歓迎！一緒にSNSを育てていきませんか？Webサイト修正・更新・機能追加保育・教育・子育て支援ジャンルでSNS発信を行っているチームでマーケティングに携わっています！\r\n今回事業拡大に伴い、InstagramやX（旧Twitter）などの投稿企画・運用サポートをしてくださる方を募集します！\r\n\r\n投稿内容...固定報酬制8,250円  契約数 0人  (募集人数 2人) あと 4 日（6月9日まで）ayaka1134掲載日：2025年06月05日気になる この仕事に似た仕事を依頼する ",
      "url": "https://crowdworks.jp/public/jobs/12154968",
      "budget": {
        "type": "fixed",
        "amount": 8250,
        "currency": "JPY"
      },
      "category": "web_products",
      "tags": [
        "SNS",
        "サポート",
        "SNS",
        "Web",
        "サイト",
        "ジャンル",
        "SNS",
        "チーム",
        "マーケティング",
        "Instagram"
      ],
      "client": {
        "name": "匿名",
        "rating": 0,
        "reviewCount": 0
      },
      "postedAt": "2025年06月05日",
      "deadline": "6月9日",
      "applicants": 0,
      "scrapedAt": "2025-06-04T23:52:25.025Z"
    }
  ]
}
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  # メイン開発環境
  crowdworks-search:
    build:
      context: .
      dockerfile: Dockerfile
      target: development  # 開発用ステージを使用
    container_name: crowdworks-search-dev
    volumes:
      # ソースコードのマウント（リアルタイム開発用）
      - .:/workspace
      - /workspace/node_modules  # node_modulesは除外
      - /workspace/dist          # distは除外
      # AWS認証情報のマウント（必要に応じて）
      - ~/.aws:/root/.aws:ro
    environment:
      # 開発環境用の環境変数
      - NODE_ENV=development
      - AWS_REGION=ap-northeast-1
      - LOG_LEVEL=debug
      # Playwright設定
      - PLAYWRIGHT_BROWSERS_PATH=/ms-playwright
    ports:
      - "3000:3000"  # 将来的なAPI Gateway Local用
      - "9229:9229"  # Node.js デバッグポート
    working_dir: /workspace
    # 開発用のコマンドオーバーライド
    command: tail -f /dev/null  # コンテナを起動状態で維持
    stdin_open: true
    tty: true

  # テスト実行専用コンテナ
  test:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: crowdworks-search-test
    volumes:
      - .:/workspace
      - /workspace/node_modules
      - /workspace/dist
    environment:
      - NODE_ENV=test
      - AWS_REGION=ap-northeast-1
    working_dir: /workspace
    command: npm run test:coverage
    profiles:
      - test  # docker-compose --profile test up で実行

  # AWS CDK専用コンテナ
  cdk:
    build:
      context: .
      dockerfile: Dockerfile
      target: development
    container_name: crowdworks-search-cdk
    volumes:
      - .:/workspace
      - /workspace/node_modules
      - /workspace/cdk.out
      - ~/.aws:/root/.aws:ro
    environment:
      - AWS_REGION=ap-northeast-1
      - CDK_DEFAULT_REGION=ap-northeast-1
    working_dir: /workspace
    command: tail -f /dev/null
    profiles:
      - cdk  # docker-compose --profile cdk up で実行

  # 本番環境テスト用（Lambda環境シミュレーション）
  lambda-test:
    build:
      context: .
      dockerfile: Dockerfile
      target: production
    container_name: crowdworks-search-lambda
    environment:
      - AWS_LAMBDA_RUNTIME_API=localhost:9000
      - _HANDLER=dist/lambda/handler.lambdaHandler
    ports:
      - "9000:8080"  # Lambda Runtime Interface Emulator
    profiles:
      - lambda  # docker-compose --profile lambda up で実行

networks:
  default:
    name: crowdworks-search-network
</file>

<file path="Dockerfile.lambda">
# ================================================
# Lambda Container用Dockerfile
# Playwright + Chromium環境の最適化版
# ================================================

# AWS Lambda Node.js基盤イメージ
FROM public.ecr.aws/lambda/nodejs:18

# ビルド引数
ARG STAGE=development
ARG NODE_ENV=production

# 環境変数設定
ENV NODE_ENV=${NODE_ENV}
ENV STAGE=${STAGE}
ENV PLAYWRIGHT_BROWSERS_PATH=/usr/bin
ENV PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1

# 作業ディレクトリ設定
WORKDIR ${LAMBDA_TASK_ROOT}

# システム依存関係のインストール（Chromium + 関連ライブラリ）
RUN dnf update -y && \
    dnf install -y \
    chromium \
    nss \
    atk \
    at-spi2-atk \
    gtk3 \
    cups-libs \
    drm \
    libXt \
    libXext \
    libXdamage \
    libXrandr \
    libXcomposite \
    libXcursor \
    libXss \
    libXi \
    GConf2 \
    alsa-lib \
    && dnf clean all \
    && rm -rf /var/cache/dnf

# Chromiumの動作確認とバイナリパス設定
RUN ln -sf /usr/bin/chromium-browser /usr/bin/chromium \
    && chromium --version \
    && echo "Chromium installed successfully"

# Node.js依存関係のコピーとインストール
COPY package*.json ./
RUN npm ci --omit=dev --ignore-scripts && \
    npm cache clean --force

# アプリケーションコードのコピー
COPY dist/ ./dist/
COPY src/types/ ./src/types/

# パーミッション設定
RUN chmod +x dist/lambda/handler.js

# Playwright設定確認
RUN node -e "console.log('Node.js version:', process.version)" && \
    node -e "const { chromium } = require('playwright'); console.log('Playwright loaded successfully')"

# ヘルスチェック（ビルド時確認）
RUN node -e "console.log('Lambda Container build completed successfully')"

# Lambda関数エントリポイント
CMD ["dist/lambda/handler.lambdaHandler"]
</file>

<file path="docs/02_deployment.md">
# デプロイガイド

## 1. 前提条件

以下のツールがインストールされていることを確認してください。

```bash
- Node.js 18+
- AWS CLI v2
- Docker Desktop
- AWS CDK CLI
```

## 2. 環境セットアップ

```bash
# リポジトリのクローン
git clone https://github.com/masayuki-akinari/crowdworks-search.git
cd crowdworks-search

# 依存関係のインストール
npm install

# AWS 認証情報設定
aws configure

# CDK 初期化（初回のみ）
npx cdk bootstrap
```

## 3. コンテナイメージ版デプロイ（推奨）

```bash
# ビルド & デプロイ
npm run cdk:deploy

# または手動で段階実行
docker build -t crowdworks-searcher .
npx cdk deploy --context deployMethod=container
```

## 4. パラメータストアへの設定

```bash
aws ssm put-parameter \
  --name "/crowdworks-search/openai-api-key" \
  --value "your-openai-api-key" \
  --type "SecureString"

aws ssm put-parameter \
  --name "/crowdworks-search/crowdworks-email" \
  --value "your-crowdworks-email" \
  --type "SecureString"
```

## 5. CI/CDによる自動デプロイ

GitHub Actionsを使用すれば、`main`や`develop`ブランチへのプッシュを契機に
インフラを自動でデプロイできます。ワークフローの詳細は
[CI/CD セットアップ](./CI_CD_SETUP.md) を参照してください。
</file>

<file path="docs/AWS_DEPLOYMENT_SETUP.md">
# AWS CI/CD デプロイメント セットアップガイド

このガイドでは、GitHub ActionsからAWSに自動デプロイするためのCI/CDパイプラインの設定方法について説明します。

## 🏗️ アーキテクチャ概要

```
GitHub Actions → OIDC認証 → AWS IAMロール → AWS CDK → Lambda + ECR
```

### デプロイフロー
- **develop**ブランチ → **staging**環境 (自動デプロイ)
- **main**ブランチ → **production**環境 (自動デプロイ + 承認フロー)
- **手動実行** → 任意の環境

## 📋 前提条件

1. **AWS CLI**がインストール済み、設定済み
2. **AWS CDK**がインストール済み
3. **適切なAWS権限**を持つIAMユーザーでログイン済み
4. **GitHub リポジトリ**の管理者権限

## 🚀 セットアップ手順

### Step 1: AWS OIDC認証の設定

GitHub ActionsからAWSにセキュアにアクセスするためのOIDC認証を設定します。

```bash
# スクリプトの実行（Windows環境では Git Bash または WSL を使用）
./scripts/setup-github-oidc.sh <YOUR_GITHUB_USERNAME> <REPOSITORY_NAME>

# 例
./scripts/setup-github-oidc.sh myusername crowdworks-search
```

このスクリプトは以下を自動作成します：
- GitHub OIDC Identity Provider
- Staging環境用IAMロール
- Production環境用IAMロール

### Step 2: GitHubシークレットの設定

1. GitHubリポジトリの **Settings** → **Secrets and variables** → **Actions**
2. 以下のシークレットを追加：

#### 必須シークレット
```bash
# AWS IAMロール ARN（Step 1で出力される）
STAGING_AWS_ROLE_ARN=arn:aws:iam::123456789012:role/GitHubActions-CrowdWorksSearch-Staging
PRODUCTION_AWS_ROLE_ARN=arn:aws:iam::123456789012:role/GitHubActions-CrowdWorksSearch-Production

# アプリケーション設定（Parameter Storeに保存される値）
STAGING_OPENAI_API_KEY=sk-...（Staging用OpenAI APIキー）
PRODUCTION_OPENAI_API_KEY=sk-...（Production用OpenAI APIキー）

STAGING_CROWDWORKS_EMAIL=your-email@example.com
STAGING_CROWDWORKS_PASSWORD=your-password
PRODUCTION_CROWDWORKS_EMAIL=your-email@example.com
PRODUCTION_CROWDWORKS_PASSWORD=your-password
```

#### オプションシークレット
```bash
# Slack通知（任意）
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...

# Codecov（任意）
CODECOV_TOKEN=xxx...
```

### Step 3: GitHub Environments設定

保護機能とデプロイ承認を設定します。

1. GitHubリポジトリの **Settings** → **Environments**
2. **New environment** をクリック

#### Staging環境
- 環境名: `staging`
- 保護ルール: なし（自動デプロイ）

#### Production環境
- 環境名: `production`
- 保護ルール設定：
  - ✅ **Required reviewers**: 1人以上
  - ✅ **Wait timer**: 0分
  - ✅ **Deployment branches**: Selected branches only → `main`

### Step 4: AWS Parameter Storeにシークレット保存

アプリケーションが使用するシークレットをAWS Parameter Storeに保存します。

```bash
# Staging環境
aws ssm put-parameter \
  --name "/crowdworks-search/staging/openai-api-key" \
  --value "sk-your-staging-key" \
  --type "SecureString" \
  --region ap-northeast-1

aws ssm put-parameter \
  --name "/crowdworks-search/staging/crowdworks-email" \
  --value "your-staging-email@example.com" \
  --type "SecureString" \
  --region ap-northeast-1

aws ssm put-parameter \
  --name "/crowdworks-search/staging/crowdworks-password" \
  --value "your-staging-password" \
  --type "SecureString" \
  --region ap-northeast-1

# Production環境
aws ssm put-parameter \
  --name "/crowdworks-search/production/openai-api-key" \
  --value "sk-your-production-key" \
  --type "SecureString" \
  --region ap-northeast-1

aws ssm put-parameter \
  --name "/crowdworks-search/production/crowdworks-email" \
  --value "your-production-email@example.com" \
  --type "SecureString" \
  --region ap-northeast-1

aws ssm put-parameter \
  --name "/crowdworks-search/production/crowdworks-password" \
  --value "your-production-password" \
  --type "SecureString" \
  --region ap-northeast-1
```

## 🔄 CI/CDパイプライン動作

### 自動デプロイ

#### Staging環境デプロイ
```bash
# developブランチにpushすると自動実行
git checkout develop
git add .
git commit -m "feat: 新機能を追加"
git push origin develop
```

#### Production環境デプロイ
```bash
# mainブランチにpushすると自動実行（承認フロー付き）
git checkout main
git merge develop
git push origin main
```

### 手動デプロイ

GitHubリポジトリの **Actions** タブから手動実行可能：

1. **Actions** タブをクリック
2. **CI/CD Pipeline** ワークフローを選択
3. **Run workflow** をクリック
4. 環境を選択（staging / production）

## 📊 デプロイ状況の確認

### GitHub Actions
- **Actions** タブでワークフロー実行状況を確認
- ログの詳細確認とエラー対応

### AWS Console
```bash
# Lambda関数の確認
aws lambda list-functions --query 'Functions[?contains(FunctionName, `crowdworks-searcher`)]'

# CloudFormation Stack確認
aws cloudformation list-stacks --stack-status-filter CREATE_COMPLETE UPDATE_COMPLETE

# CloudWatch Logs確認
aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/crowdworks-searcher"
```

## 🛠️ トラブルシューティング

### よくあるエラーと対処法

#### 1. OIDC認証エラー
```
Error: Could not assume role with OIDC
```
**対処法:**
- IAMロールの信頼関係を確認
- GitHubリポジトリ名、ブランチ名が正しいか確認

#### 2. ECRログインエラー
```
Error: Cannot perform an interactive login from a non TTY device
```
**対処法:**
- ECRリポジトリの存在確認
- IAMロールにECR権限があるか確認

#### 3. CDKデプロイエラー
```
Error: Stack with id does not exist
```
**対処法:**
- CDK bootstrapが実行済みか確認
- AWSアカウント、リージョンが正しいか確認

```bash
# CDK Bootstrap実行
npx cdk bootstrap aws://ACCOUNT-ID/REGION
```

#### 4. Lambda関数デプロイエラー
```
Error: Code storage limit exceeded
```
**対処法:**
- 古いLambdaバージョンの削除
- Container Imageの使用（Playwright対応）

## 📈 監視とアラート

### CloudWatch メトリクス
- Lambda実行時間、エラー率
- コスト監視
- ログ監視

### Slackアラート（設定済みの場合）
- デプロイ成功・失敗通知
- リアルタイムステータス更新

## 🔒 セキュリティベストプラクティス

1. **最小権限の原則**: IAMロールは必要最小限の権限のみ
2. **シークレット管理**: Parameter Store使用、Gitコミットしない
3. **環境分離**: Staging/Production環境の完全分離
4. **監査ログ**: CloudTrailによる操作ログ記録
5. **定期的な権限レビュー**: 四半期毎のアクセス権限見直し

## 💡 Tips

- **デプロイ前テスト**: PRでテストパイプラインを確認
- **ロールバック戦略**: 問題発生時の手動ロールバック準備
- **コスト最適化**: 不要なリソースの定期削除
- **ドキュメント更新**: 設定変更時のドキュメント同期

---

これでCI/CD上でのAWSデプロイが完全に自動化されます！🎉
</file>

<file path="docs/README.md">
# 設計書インデックス

クラウドワークス案件自動検索・評価システムの設計書です。

## 📚 設計書一覧

### 1. [要件定義書](./01_requirements.md)
プロジェクトの目的、機能要件、非機能要件を定義

### 2. [システム設計書](./02_system_design.md)  
システム全体のアーキテクチャとコンポーネント設計

### 3. [データ設計書](./03_data_design.md)
データベース設計とデータ型定義

### 4. [API設計書](./04_api_design.md)
内部API・外部API連携の仕様定義

### 5. [実装計画書](./05_implementation_plan.md)
開発フェーズとタスク分解、スケジュール

## 🔄 設計書作成の進め方

1. **要件定義書** から開始
2. **システム設計書** で全体像を整理
3. **データ設計書** でデータ構造を決定
4. **API設計書** でインターフェースを定義
5. **実装計画書** で開発を計画

## 📝 更新履歴

| 日付 | 更新者 | 更新内容 |
|------|--------|----------|
|      |        |          |
</file>

<file path="scripts/setup-github-oidc.sh">
#!/bin/bash

# GitHub Actions OIDC用のIAMロール作成スクリプト
# 使用方法: ./scripts/setup-github-oidc.sh <YOUR_GITHUB_USERNAME> <REPOSITORY_NAME>

set -e

# パラメータチェック
if [ $# -ne 2 ]; then
    echo "使用方法: $0 <GITHUB_USERNAME> <REPOSITORY_NAME>"
    echo "例: $0 myusername crowdworks-search"
    exit 1
fi

GITHUB_USERNAME=$1
REPOSITORY_NAME=$2
AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
AWS_REGION=$(aws configure get region || echo "ap-northeast-1")

echo "🚀 GitHub Actions OIDC認証セットアップを開始します..."
echo "GitHub: ${GITHUB_USERNAME}/${REPOSITORY_NAME}"
echo "AWS Account: ${AWS_ACCOUNT_ID}"
echo "AWS Region: ${AWS_REGION}"

# OIDC Identity Providerの作成（存在しない場合のみ）
echo "📋 OIDC Identity Providerをチェック中..."
if ! aws iam get-open-id-connect-provider --open-id-connect-provider-arn "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com" 2>/dev/null; then
    echo "📝 OIDC Identity Providerを作成中..."
    aws iam create-open-id-connect-provider \
        --url "https://token.actions.githubusercontent.com" \
        --thumbprint-list "6938fd4d98bab03faadb97b34396831e3780aea1" \
        --client-id-list "sts.amazonaws.com"
    echo "✅ OIDC Identity Providerを作成しました"
else
    echo "✅ OIDC Identity Providerは既に存在します"
fi

# Staging環境用IAMロール作成
echo "📝 Staging環境用IAMロールを作成中..."
STAGING_ROLE_NAME="GitHubActions-CrowdWorksSearch-Staging"

# 信頼ポリシー
cat > /tmp/staging-trust-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
                },
                "StringLike": {
                    "token.actions.githubusercontent.com:sub": [
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:ref:refs/heads/develop",
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:environment:staging"
                    ]
                }
            }
        }
    ]
}
EOF

# Production環境用IAMロール作成
echo "📝 Production環境用IAMロールを作成中..."
PRODUCTION_ROLE_NAME="GitHubActions-CrowdWorksSearch-Production"

# 信頼ポリシー
cat > /tmp/production-trust-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "Federated": "arn:aws:iam::${AWS_ACCOUNT_ID}:oidc-provider/token.actions.githubusercontent.com"
            },
            "Action": "sts:AssumeRoleWithWebIdentity",
            "Condition": {
                "StringEquals": {
                    "token.actions.githubusercontent.com:aud": "sts.amazonaws.com"
                },
                "StringLike": {
                    "token.actions.githubusercontent.com:sub": [
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:ref:refs/heads/main",
                        "repo:${GITHUB_USERNAME}/${REPOSITORY_NAME}:environment:production"
                    ]
                }
            }
        }
    ]
}
EOF

# 権限ポリシー
cat > /tmp/deploy-policy.json << EOF
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "cloudformation:*",
                "s3:*",
                "lambda:*",
                "iam:*",
                "logs:*",
                "events:*",
                "ecr:*",
                "ssm:GetParameter",
                "ssm:GetParameters",
                "sts:AssumeRole"
            ],
            "Resource": "*"
        }
    ]
}
EOF

# Stagingロール作成
if aws iam get-role --role-name "${STAGING_ROLE_NAME}" 2>/dev/null; then
    echo "⚠️  Stagingロールは既に存在します。削除して再作成しますか？ (y/N)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        aws iam delete-role --role-name "${STAGING_ROLE_NAME}" || true
    else
        echo "Stagingロールの作成をスキップします"
    fi
fi

if ! aws iam get-role --role-name "${STAGING_ROLE_NAME}" 2>/dev/null; then
    aws iam create-role \
        --role-name "${STAGING_ROLE_NAME}" \
        --assume-role-policy-document file:///tmp/staging-trust-policy.json \
        --description "GitHub Actions deployment role for staging environment"
    
    aws iam put-role-policy \
        --role-name "${STAGING_ROLE_NAME}" \
        --policy-name "DeploymentPolicy" \
        --policy-document file:///tmp/deploy-policy.json
    
    echo "✅ Stagingロールを作成しました"
fi

# Productionロール作成
if aws iam get-role --role-name "${PRODUCTION_ROLE_NAME}" 2>/dev/null; then
    echo "⚠️  Productionロールは既に存在します。削除して再作成しますか？ (y/N)"
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
        aws iam delete-role --role-name "${PRODUCTION_ROLE_NAME}" || true
    else
        echo "Productionロールの作成をスキップします"
    fi
fi

if ! aws iam get-role --role-name "${PRODUCTION_ROLE_NAME}" 2>/dev/null; then
    aws iam create-role \
        --role-name "${PRODUCTION_ROLE_NAME}" \
        --assume-role-policy-document file:///tmp/production-trust-policy.json \
        --description "GitHub Actions deployment role for production environment"
    
    aws iam put-role-policy \
        --role-name "${PRODUCTION_ROLE_NAME}" \
        --policy-name "DeploymentPolicy" \
        --policy-document file:///tmp/deploy-policy.json
    
    echo "✅ Productionロールを作成しました"
fi

# クリーンアップ
rm -f /tmp/staging-trust-policy.json /tmp/production-trust-policy.json /tmp/deploy-policy.json

echo ""
echo "🎉 セットアップが完了しました！"
echo ""
echo "次の手順:"
echo "1. GitHubリポジトリの Settings > Secrets and variables > Actions で以下のシークレットを設定してください："
echo ""
echo "   STAGING_AWS_ROLE_ARN=arn:aws:iam::${AWS_ACCOUNT_ID}:role/${STAGING_ROLE_NAME}"
echo "   PRODUCTION_AWS_ROLE_ARN=arn:aws:iam::${AWS_ACCOUNT_ID}:role/${PRODUCTION_ROLE_NAME}"
echo ""
echo "2. (オプション) Slack通知用："
echo "   SLACK_WEBHOOK_URL=<your-slack-webhook-url>"
echo ""
echo "3. GitHubでEnvironmentsを設定："
echo "   - Settings > Environments"
echo "   - 'staging' 環境を作成"
echo "   - 'production' 環境を作成（保護ルール設定推奨）"
echo ""
echo "これでCI/CDパイプラインでAWSデプロイが可能になります！"
</file>

<file path="tsconfig.cdk.json">
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
        "rootDir": "./",
        "outDir": "./cdk.out/build"
    },
    "include": [
        "app.ts",
        "src/infrastructure/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "test",
        "**/*.test.ts",
        "**/*.spec.ts"
    ]
}
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
yarn.lock

# Build outputs
dist/
build/
*.tsbuildinfo

# TypeScript
*.d.ts
*.d.ts.map
*.js.map

# AWS CDK
cdk.out/
cdk.context.json

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log

# Coverage
coverage/
.nyc_output/

# Jest
jest_0/

# Temporary files
tmp/
temp/

# Docker
.dockerignore

# Husky
.husky/_/
</file>

<file path="app.ts">
#!/usr/bin/env node
import 'source-map-support/register';
import * as cdk from 'aws-cdk-lib';
import { CrowdWorksSearcherStack } from './src/infrastructure/crowdworks-searcher-stack';

const app = new cdk.App();

// 環境設定
const account = process.env['CDK_DEFAULT_ACCOUNT'];
const region = process.env['CDK_DEFAULT_REGION'] || process.env['AWS_REGION'] || 'ap-northeast-1';
const stage = app.node.tryGetContext('stage') || process.env['STAGE'] || 'dev';

const env: cdk.Environment = account ? { account, region } : { region };

// ステージ別のスタック設定
const getStackConfig = (stage: string) => {
    const baseConfig = {
        env,
        description: `CrowdWorks Auto Job Searcher System - ${stage.toUpperCase()}`,
        stage,
    };

    switch (stage) {
        case 'production':
            return {
                ...baseConfig,
                terminationProtection: true, // 本番環境では削除保護を有効
            };
        case 'staging':
            return {
                ...baseConfig,
                terminationProtection: false,
            };
        default: // dev, test, etc.
            return {
                ...baseConfig,
                terminationProtection: false,
            };
    }
};

// スタック作成
const stackConfig = getStackConfig(stage);
new CrowdWorksSearcherStack(app, `CrowdWorksSearcherStack-${stage}`, stackConfig);

// タグを全リソースに適用
cdk.Tags.of(app).add('Application', 'CrowdWorksSearcher');
cdk.Tags.of(app).add('Stage', stage);
cdk.Tags.of(app).add('ManagedBy', 'CDK');

console.log(`🚀 Deploying CrowdWorks Searcher to ${stage.toUpperCase()} environment`);
console.log(`   Region: ${region}`);
console.log(`   Account: ${account || 'default'}`);
</file>

<file path="docs/03_data_design.md">
# データ設計書

## 1. データストレージ設計

### 1.1 S3バケット構造

```
crowdworks-searcher-bucket/
├── jobs/                           # 案件データ
│   ├── 2024-01-15T14-30.json     # タイムスタンプ形式
│   ├── 2024-01-15T14-45.json
│   └── ...
├── evaluations/                    # AI評価結果
│   ├── 2024-01-15T14-30.json
│   ├── 2024-01-15T14-45.json
│   └── ...
├── logs/                           # 実行・エラーログ
│   ├── execution/
│   │   ├── 2024-01-15T14-30-execution.json
│   │   └── ...
│   ├── error/
│   │   ├── 2024-01-15T14-30-error.json
│   │   └── ...
│   └── daily-summary/
│       ├── 2024-01-15.json
│       └── ...
└── config/                         # 設定ファイル
    ├── search-conditions.json     # 検索条件
    └── system-config.json         # システム設定
```

### 1.2 ファイル命名規則

```typescript
interface FileNamingConvention {
  jobs: 'YYYY-MM-DDTHH-mm.json';           // 2024-01-15T14-30.json
  evaluations: 'YYYY-MM-DDTHH-mm.json';   // 2024-01-15T14-30.json
  executionLogs: 'YYYY-MM-DDTHH-mm-execution.json';
  errorLogs: 'YYYY-MM-DDTHH-mm-error.json';
  dailySummary: 'YYYY-MM-DD.json';         // 2024-01-15.json
  searchConditions: 'search-conditions.json';
  systemConfig: 'system-config.json';
}
```

### 1.3 ライフサイクル管理

```typescript
interface S3LifecyclePolicy {
  rules: [
    {
      id: 'DeleteOldData';
      status: 'Enabled';
      transitions: [];
      expiration: {
        days: 7; // 7日後自動削除
      };
      filter: {
        prefix: 'jobs/'; // jobs/, evaluations/, logs/ 対象
      };
    },
    {
      id: 'KeepConfig';
      status: 'Enabled';
      expiration: null; // config/ は削除しない
      filter: {
        prefix: 'config/';
      };
    }
  ];
}
```

## 2. データ型定義

### 2.1 TypeScript型定義

#### 2.1.1 案件データ型（軽量版）

```typescript
interface JobData {
  // 基本情報
  id: string;                    // 案件ID（ユニーク）
  title: string;                 // 案件タイトル
  description: string;           // 案件詳細（最大500文字）
  url: string;                   // 案件URL
  
  // 条件情報
  budget: number;                // 予算（円）
  deadline: Date;                // 納期
  workType: 'fixed' | 'hourly'; // 固定報酬 or 時間単価
  category: string;              // カテゴリ
  
  // クライアント情報
  clientName: string;            // クライアント名
  clientRating: number;          // クライアント評価（1-5）
  clientReviews: number;         // レビュー数
  
  // スキル・要件
  skills: string[];              // 必要スキル（最大5個）
  experience: 'beginner' | 'intermediate' | 'expert'; // 経験レベル
  
  // メタ情報
  scrapedAt: Date;              // 取得日時
  source: 'crowdworks';         // 取得元（将来拡張用）
}

// バリデーション関数
const validateJobData = (job: JobData): boolean => {
  return (
    job.id.length > 0 &&
    job.title.length > 0 &&
    job.description.length <= 500 &&
    job.budget > 0 &&
    job.skills.length <= 5 &&
    job.clientRating >= 1 && job.clientRating <= 5
  );
};
```

#### 2.1.2 評価結果型（軽量版）

```typescript
interface JobEvaluation {
  // 関連情報
  jobId: string;                // 対象案件ID
  evaluatedAt: Date;           // 評価日時
  
  // 評価結果
  score: number;               // おすすめ度（1-10）
  reason: string;              // 評価理由（最大50文字）
  
  // メタ情報
  aiModel: 'gpt-3.5-turbo';    // 使用AIモデル
  tokenUsed: number;           // 使用トークン数
  costEstimate: number;        // 推定コスト（USD）
  
  // 評価詳細（簡素化）
  strengths: string[];         // 強み（最大3個）
  concerns: string[];          // 懸念点（最大3個）
}

// デフォルト評価（AI失敗時）
const createDefaultEvaluation = (jobId: string): JobEvaluation => ({
  jobId,
  evaluatedAt: new Date(),
  score: 5, // デフォルトスコア
  reason: 'AI評価失敗のため暫定スコア',
  aiModel: 'gpt-3.5-turbo',
  tokenUsed: 0,
  costEstimate: 0,
  strengths: [],
  concerns: ['AI評価未実施']
});
```

#### 2.1.3 実行ログ型

```typescript
interface ExecutionLog {
  // 実行情報
  executionId: string;         // 実行ID（タイムスタンプベース）
  timestamp: string;           // 実行開始時刻（ISO形式）
  status: 'success' | 'error' | 'partial'; // 実行ステータス
  duration: number;            // 実行時間（ミリ秒）
  
  // 処理結果
  jobsScraped: number;         // スクレイピング件数
  newJobs: number;             // 新規案件数
  aiEvaluated: number;         // AI評価件数
  highScoreJobs: number;       // 高評価案件数（閾値以上）
  
  // コスト情報
  costEstimate: number;        // 推定コスト（USD）
  
  // エラー情報（該当時のみ）
  error?: {
    type: string;              // エラータイプ
    message: string;           // エラーメッセージ
    stack?: string;            // スタックトレース
  };
}
```

#### 2.1.4 設定型

```typescript
// システム設定（config/system-config.json）
interface SystemConfig {
  scraping: {
    maxJobsPerExecution: 50;          // 最大処理件数
    preFilterEnabled: true;           // 事前フィルタ有効
    minBudget: 50000;                 // 最低予算（円）
    minClientRating: 4.0;             // 最低クライアント評価
    maxDescriptionLength: 500;        // 説明文最大長
  };
  
  ai: {
    enabled: true;                    // AI評価有効
    model: 'gpt-3.5-turbo';          // 使用モデル
    maxJobsForEvaluation: 10;        // 最大AI評価件数
    monthlyBudgetLimit: 3.0;         // 月間予算制限（USD）
    maxTokensPerRequest: 200;        // リクエスト最大トークン
    temperature: 0.3;                // 応答の一貫性
  };
  
  notification: {
    enabled: true;                   // 通知有効
    scoreThreshold: 7;               // 高評価閾値
    errorNotificationEnabled: true;   // エラー通知有効
    dailySummaryEnabled: true;       // 日次サマリー有効
  };
  
  storage: {
    retentionDays: 7;                // データ保持日数
    compressionEnabled: false;        // 圧縮無効（コスト削減）
    backupEnabled: false;            // バックアップ無効（コスト削減）
  };
  
  performance: {
    timeoutSeconds: 600;             // タイムアウト（10分）
    retryCount: 2;                   // リトライ回数
    concurrentLimit: 1;              // 同時実行数制限
  };
}

// 検索条件設定（config/search-conditions.json）
interface SearchConditions {
  version: string;                   // 設定バージョン
  lastUpdated: Date;                 // 最終更新日時
  
  conditions: Array<{
    id: string;                      // 条件ID
    name: string;                    // 条件名
    enabled: boolean;                // 有効フラグ
    
    // 基本条件
    keywords: string[];              // キーワード（最大10個）
    budgetMin: number;               // 最低予算
    budgetMax: number;               // 最高予算
    category: string;                // カテゴリ
    workType: 'fixed' | 'hourly' | 'both'; // 作業形式
    
    // フィルタ条件
    clientRatingMin: number;         // 最低クライアント評価
    experienceLevel: 'beginner' | 'intermediate' | 'expert' | 'any';
    
    // 除外条件
    excludeKeywords: string[];       // 除外キーワード
    excludeClients: string[];        // 除外クライアント
  }>;
}
```

## 3. データ操作設計

### 3.1 S3データサービス

```typescript
class S3DataService {
  private s3: S3Client;
  private bucketName: string;

  // 案件データ操作
  async saveJobs(jobs: JobData[], timestamp: string): Promise<void> {
    const key = `jobs/${timestamp}.json`;
    const body = JSON.stringify(jobs.map(this.sanitizeJobData), null, 2);
    
    await this.s3.putObject({
      Bucket: this.bucketName,
      Key: key,
      Body: body,
      ContentType: 'application/json',
      ServerSideEncryption: 'AES256',
      Metadata: {
        'job-count': jobs.length.toString(),
        'created-at': new Date().toISOString()
      }
    });
  }

  async getRecentJobs(hours: number = 24): Promise<JobData[]> {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    const objects = await this.listObjectsSince('jobs/', cutoff);
    
    const allJobs: JobData[] = [];
    for (const obj of objects.slice(0, 10)) { // 最大10ファイル
      const data = await this.getObject(obj.Key!);
      const jobs: JobData[] = JSON.parse(data);
      allJobs.push(...jobs);
    }
    
    return allJobs;
  }

  async getExistingJobIds(hours: number = 48): Promise<Set<string>> {
    const recentJobs = await this.getRecentJobs(hours);
    return new Set(recentJobs.map(job => job.id));
  }

  // 設定操作
  async getSystemConfig(): Promise<SystemConfig> {
    try {
      const data = await this.getObject('config/system-config.json');
      return JSON.parse(data);
    } catch (error) {
      return this.getDefaultSystemConfig();
    }
  }

  async getSearchConditions(): Promise<SearchConditions> {
    try {
      const data = await this.getObject('config/search-conditions.json');
      return JSON.parse(data);
    } catch (error) {
      return this.getDefaultSearchConditions();
    }
  }

  // ユーティリティメソッド
  private async listObjectsSince(prefix: string, since: Date): Promise<_Object[]> {
    const response = await this.s3.listObjectsV2({
      Bucket: this.bucketName,
      Prefix: prefix,
      MaxKeys: 50 // コスト削減
    });

    return (response.Contents || [])
      .filter(obj => obj.LastModified && obj.LastModified >= since)
      .sort((a, b) => (b.LastModified?.getTime() || 0) - (a.LastModified?.getTime() || 0));
  }

  private async getObject(key: string): Promise<string> {
    const response = await this.s3.getObject({
      Bucket: this.bucketName,
      Key: key
    });

    return response.Body?.transformToString() || '';
  }

  private sanitizeJobData(job: JobData): JobData {
    return {
      ...job,
      description: job.description.slice(0, 500), // 長さ制限
      skills: job.skills.slice(0, 5), // 配列長制限
      clientName: job.clientName.replace(/[^\w\s-]/g, '') // 特殊文字除去
    };
  }
}
```

### 3.2 重複チェック機能

```typescript
class DuplicateChecker {
  constructor(private dataService: S3DataService) {}

  async filterNewJobs(jobs: JobData[]): Promise<JobData[]> {
    // 過去48時間のジョブIDを取得
    const existingJobIds = await this.dataService.getExistingJobIds(48);
    
    // 重複除外
    const newJobs = jobs.filter(job => !existingJobIds.has(job.id));
    
    // さらに同一実行内での重複もチェック
    const uniqueJobs = this.removeDuplicatesInBatch(newJobs);
    
    return uniqueJobs;
  }

  private removeDuplicatesInBatch(jobs: JobData[]): JobData[] {
    const seen = new Set<string>();
    return jobs.filter(job => {
      if (seen.has(job.id)) {
        return false;
      }
      seen.add(job.id);
      return true;
    });
  }
}
```

## 4. データ移行・初期化

### 4.1 初期データ設定

```typescript
class DataInitializer {
  constructor(private dataService: S3DataService) {}

  async initializeSystem(): Promise<void> {
    // システム設定の初期化
    await this.initializeSystemConfig();
    
    // 検索条件の初期化
    await this.initializeSearchConditions();
    
    // S3バケットの設定確認
    await this.setupS3Bucket();
  }

  private async initializeSystemConfig(): Promise<void> {
    const defaultConfig: SystemConfig = {
      scraping: {
        maxJobsPerExecution: 50,
        preFilterEnabled: true,
        minBudget: 50000,
        minClientRating: 4.0,
        maxDescriptionLength: 500
      },
      ai: {
        enabled: true,
        model: 'gpt-3.5-turbo',
        maxJobsForEvaluation: 10,
        monthlyBudgetLimit: 3.0,
        maxTokensPerRequest: 200,
        temperature: 0.3
      },
      notification: {
        enabled: true,
        scoreThreshold: 7,
        errorNotificationEnabled: true,
        dailySummaryEnabled: true
      },
      storage: {
        retentionDays: 7,
        compressionEnabled: false,
        backupEnabled: false
      },
      performance: {
        timeoutSeconds: 600,
        retryCount: 2,
        concurrentLimit: 1
      }
    };

    await this.dataService.saveConfig('config/system-config.json', defaultConfig);
  }

  private async initializeSearchConditions(): Promise<void> {
    const defaultConditions: SearchConditions = {
      version: '1.0.0',
      lastUpdated: new Date(),
      conditions: [
        {
          id: 'web-development',
          name: 'Webアプリ開発',
          enabled: true,
          keywords: ['React', 'TypeScript', 'Next.js', 'Node.js'],
          budgetMin: 100000,
          budgetMax: 1000000,
          category: 'システム開発',
          workType: 'fixed',
          clientRatingMin: 4.0,
          experienceLevel: 'intermediate',
          excludeKeywords: ['WordPress', 'PHP'],
          excludeClients: []
        },
        {
          id: 'ai-development',
          name: 'AI・機械学習',
          enabled: true,
          keywords: ['Python', 'AI', '機械学習', 'データ分析'],
          budgetMin: 150000,
          budgetMax: 2000000,
          category: 'システム開発',
          workType: 'fixed',
          clientRatingMin: 4.5,
          experienceLevel: 'expert',
          excludeKeywords: ['Excel', '単純作業'],
          excludeClients: []
        }
      ]
    };

    await this.dataService.saveConfig('config/search-conditions.json', defaultConditions);
  }
}
```

## 5. データバックアップ・復旧

### 5.1 バックアップ方針（コスト重視）

```typescript
interface BackupStrategy {
  // 基本方針：コスト削減のため最小限のバックアップ
  configBackup: {
    enabled: true;
    frequency: 'on-change';  // 設定変更時のみ
    retention: '30 days';
    location: 'same-bucket/backups/config/';
  };
  
  dataBackup: {
    enabled: false;          // データは7日で削除されるためバックアップなし
    reason: 'Cost optimization - data has short lifecycle';
  };
  
  logBackup: {
    enabled: false;          // ログも7日で削除
    reason: 'Cost optimization - short retention period';
  };
}

class BackupService {
  constructor(private dataService: S3DataService) {}

  // 設定ファイルのバックアップ（変更時のみ）
  async backupConfigOnChange(configType: 'system' | 'search-conditions'): Promise<void> {
    const timestamp = new Date().toISOString().split('T')[0];
    const sourceKey = `config/${configType === 'system' ? 'system-config.json' : 'search-conditions.json'}`;
    const backupKey = `backups/config/${configType}-${timestamp}.json`;

    try {
      const data = await this.dataService.getObject(sourceKey);
      await this.dataService.putObject(backupKey, data);
    } catch (error) {
      console.warn(`Config backup failed: ${error}`);
    }
  }
}
```

## 6. データ品質管理

### 6.1 データ検証

```typescript
class DataValidator {
  // 案件データの検証
  static validateJobData(job: JobData): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    // 必須フィールドチェック
    if (!job.id || job.id.trim().length === 0) {
      errors.push('Job ID is required');
    }
    if (!job.title || job.title.trim().length === 0) {
      errors.push('Job title is required');
    }
    if (!job.url || !this.isValidUrl(job.url)) {
      errors.push('Valid job URL is required');
    }

    // 数値検証
    if (job.budget <= 0) {
      errors.push('Budget must be positive');
    }
    if (job.clientRating < 1 || job.clientRating > 5) {
      errors.push('Client rating must be between 1 and 5');
    }

    // 配列長制限
    if (job.skills.length > 5) {
      errors.push('Skills array cannot exceed 5 items');
    }
    if (job.description.length > 500) {
      errors.push('Description cannot exceed 500 characters');
    }

    // 日付検証
    if (!(job.scrapedAt instanceof Date) || isNaN(job.scrapedAt.getTime())) {
      errors.push('Invalid scraped date');
    }
    if (!(job.deadline instanceof Date) || isNaN(job.deadline.getTime())) {
      errors.push('Invalid deadline');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  // 評価データの検証
  static validateEvaluation(evaluation: JobEvaluation): { isValid: boolean; errors: string[] } {
    const errors: string[] = [];

    if (!evaluation.jobId || evaluation.jobId.trim().length === 0) {
      errors.push('Job ID is required');
    }
    if (evaluation.score < 1 || evaluation.score > 10) {
      errors.push('Score must be between 1 and 10');
    }
    if (!evaluation.reason || evaluation.reason.length > 50) {
      errors.push('Reason must be 1-50 characters');
    }
    if (evaluation.tokenUsed < 0) {
      errors.push('Token usage cannot be negative');
    }
    if (evaluation.costEstimate < 0) {
      errors.push('Cost estimate cannot be negative');
    }

    return {
      isValid: errors.length === 0,
      errors
    };
  }

  private static isValidUrl(url: string): boolean {
    try {
      new URL(url);
      return url.includes('crowdworks.jp');
    } catch {
      return false;
    }
  }
}

// データクリーニング
class DataCleaner {
  static cleanJobData(job: JobData): JobData {
    return {
      ...job,
      title: job.title.trim().slice(0, 200),
      description: job.description.trim().slice(0, 500),
      skills: job.skills.slice(0, 5).map(skill => skill.trim()),
      clientName: job.clientName.trim().replace(/[^\w\s-]/g, ''),
      budget: Math.max(0, Math.round(job.budget)),
      clientRating: Math.max(1, Math.min(5, job.clientRating))
    };
  }

  static cleanEvaluation(evaluation: JobEvaluation): JobEvaluation {
    return {
      ...evaluation,
      score: Math.max(1, Math.min(10, Math.round(evaluation.score))),
      reason: evaluation.reason.trim().slice(0, 50),
      strengths: evaluation.strengths.slice(0, 3),
      concerns: evaluation.concerns.slice(0, 3),
      tokenUsed: Math.max(0, evaluation.tokenUsed),
      costEstimate: Math.max(0, evaluation.costEstimate)
    };
  }
}
```

**これでS3ベース設計に最適化されたデータ設計書が完成しました！**

コスト制約（月$5以下）を満たしながら、必要な機能を提供できる軽量なデータ構造になっています。
</file>

<file path="docs/04_api_design.md">
# API設計書

## 1. API概要

### 1.1 API方針

**基本方針**
- **コストファースト**: 月$5以下の予算制約を最優先
- **サーバレス中心**: Lambda関数間の軽量な内部API
- **外部API最小限**: ChatGPT API（軽量利用）とスクレイピングのみ
- **RESTful設計**: 標準的なHTTPメソッドとステータスコード
- **JSON形式**: 全てのリクエスト・レスポンスはJSON
- **型安全性**: TypeScriptでの完全な型定義

**API構成**
- **内部API**: Lambda関数間の連携（EventBridge + 直接呼び出し）
- **管理用API**: 設定確認・手動実行用の最小限API（API Gateway）
- **外部API**: ChatGPT API、クラウドワークススクレイピング
- **通知API**: SNS/SESによるエラー・高評価案件通知

### 1.2 認証方式

**内部API認証**
```typescript
// Lambda関数間: IAMロールによる認証
interface LambdaInvocationAuth {
  type: 'IAM_ROLE';
  role: 'arn:aws:iam::account:role/CrowdWorksSearcherRole';
  permissions: ['lambda:InvokeFunction', 's3:GetObject', 's3:PutObject'];
}

// EventBridge: サービス間認証
interface EventBridgeAuth {
  type: 'SERVICE_PRINCIPAL';
  principal: 'events.amazonaws.com';
  targetFunction: 'CrowdWorksSearcherMainFunction';
}
```

**外部API認証**
```typescript
// Parameter Store での安全な管理
interface ExternalAPIAuth {
  chatgpt: {
    type: 'Bearer Token';
    storage: 'AWS Systems Manager Parameter Store';
    path: '/crowdworks-searcher/secrets/openai-api-key';
    encryption: 'SecureString';
  };
  
  crowdworks: {
    type: 'Session Cookie';
    storage: 'AWS Systems Manager Parameter Store';
    credentials: {
      email: '/crowdworks-searcher/secrets/crowdworks-email';
      password: '/crowdworks-searcher/secrets/crowdworks-password';
    };
    encryption: 'SecureString';
  };
}
```

### 1.3 エラーレスポンス共通仕様

```typescript
// 標準エラーレスポンス
interface APIErrorResponse {
  error: {
    code: string;           // エラーコード
    message: string;        // エラーメッセージ
    timestamp: string;      // エラー発生時刻（ISO形式）
    requestId: string;      // リクエストID（トレース用）
    retryable: boolean;     // リトライ可能かどうか
    details?: Record<string, any>; // 詳細情報（オプション）
  };
}

// エラーコード定義
enum APIErrorCode {
  // クライアントエラー (4xx)
  INVALID_REQUEST = 'INVALID_REQUEST',
  AUTHENTICATION_FAILED = 'AUTHENTICATION_FAILED',
  AUTHORIZATION_FAILED = 'AUTHORIZATION_FAILED',
  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',
  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',
  
  // サーバーエラー (5xx)
  INTERNAL_SERVER_ERROR = 'INTERNAL_SERVER_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  EXTERNAL_API_ERROR = 'EXTERNAL_API_ERROR',
  TIMEOUT_ERROR = 'TIMEOUT_ERROR',
  
  // ビジネスロジックエラー
  BUDGET_EXCEEDED = 'BUDGET_EXCEEDED',
  SCRAPING_FAILED = 'SCRAPING_FAILED',
  AI_EVALUATION_FAILED = 'AI_EVALUATION_FAILED',
  S3_OPERATION_FAILED = 'S3_OPERATION_FAILED'
}
```

## 2. 内部API設計

### 2.1 メイン処理API（Lambda関数）

#### 2.1.1 スケジュール実行

```typescript
// EventBridge → Lambda実行
interface ScheduledExecutionEvent {
  source: 'aws.events';
  'detail-type': 'Scheduled Event';
  detail: {};
  time: string; // ISO形式
}

interface ScheduledExecutionResponse {
  status: 'success' | 'error' | 'partial';
  executionId: string;
  timestamp: string;
  results: {
    jobsScraped: number;
    newJobs: number;
    aiEvaluated: number;
    highScoreJobs: number;
    duration: number;
    costEstimate: number;
  };
  error?: {
    type: string;
    message: string;
  };
}

// Lambda Handler実装
export const scheduledExecutionHandler = async (
  event: ScheduledExecutionEvent
): Promise<ScheduledExecutionResponse> => {
  const executionId = Date.now().toString();
  const startTime = Date.now();
  
  try {
    // メイン処理フローの実行
    const result = await executeMainFlow(executionId);
    
    return {
      status: 'success',
      executionId,
      timestamp: new Date().toISOString(),
      results: {
        ...result,
        duration: Date.now() - startTime
      }
    };
  } catch (error) {
    return {
      status: 'error',
      executionId,
      timestamp: new Date().toISOString(),
      results: {
        jobsScraped: 0,
        newJobs: 0,
        aiEvaluated: 0,
        highScoreJobs: 0,
        duration: Date.now() - startTime,
        costEstimate: 0
      },
      error: {
        type: error.constructor.name,
        message: error.message
      }
    };
  }
};
```

#### 2.1.2 手動実行API

```typescript
// 緊急時の手動実行用（API Gateway経由）
interface ManualExecutionRequest {
  trigger: 'manual';
  options?: {
    skipCache?: boolean;     // キャッシュスキップ
    forceAIEvaluation?: boolean; // AI評価強制実行
    testMode?: boolean;      // テストモード
  };
}

interface ManualExecutionResponse {
  message: string;
  executionId: string;
  estimatedCompletion: string; // 完了予定時刻
  monitorUrl?: string;         // 実行状況確認URL（S3ログ）
}

// POST /api/execute
export const manualExecutionHandler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const request: ManualExecutionRequest = JSON.parse(event.body || '{}');
    
    // Lambda関数を非同期実行
    const executionId = await invokeLambdaAsync('main-function', {
      source: 'manual',
      options: request.options
    });
    
    const response: ManualExecutionResponse = {
      message: 'Execution started successfully',
      executionId,
      estimatedCompletion: new Date(Date.now() + 60000).toISOString(),
      monitorUrl: `s3://bucket/logs/execution/${executionId}.json`
    };
    
    return {
      statusCode: 202,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(response)
    };
  } catch (error) {
    return createErrorResponse(APIErrorCode.INTERNAL_SERVER_ERROR, error.message);
  }
};
```

### 2.2 設定管理API

#### 2.2.1 システム設定取得

```typescript
// GET /api/config/system
interface SystemConfigResponse {
  config: SystemConfig;
  lastModified: string;
  version: string;
}

export const getSystemConfigHandler = async (): Promise<APIGatewayProxyResult> => {
  try {
    const s3DataService = new S3DataService();
    const config = await s3DataService.getSystemConfig();
    
    const response: SystemConfigResponse = {
      config,
      lastModified: new Date().toISOString(),
      version: '1.0.0'
    };
    
    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(response)
    };
  } catch (error) {
    return createErrorResponse(APIErrorCode.S3_OPERATION_FAILED, error.message);
  }
};
```

#### 2.2.2 検索条件管理

```typescript
// GET /api/config/search-conditions
interface SearchConditionsResponse {
  conditions: SearchConditions;
  activeCount: number;
  lastModified: string;
}

// PUT /api/config/search-conditions
interface UpdateSearchConditionsRequest {
  conditions: SearchConditions;
  backupCurrent?: boolean; // 現在の設定をバックアップ
}

export const getSearchConditionsHandler = async (): Promise<APIGatewayProxyResult> => {
  try {
    const s3DataService = new S3DataService();
    const conditions = await s3DataService.getSearchConditions();
    
    const activeCount = conditions.conditions.filter(c => c.enabled).length;
    
    const response: SearchConditionsResponse = {
      conditions,
      activeCount,
      lastModified: conditions.lastUpdated.toISOString()
    };
    
    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(response)
    };
  } catch (error) {
    return createErrorResponse(APIErrorCode.S3_OPERATION_FAILED, error.message);
  }
};
```

### 2.3 データ取得API

#### 2.3.1 案件データ取得

```typescript
// GET /api/jobs?hours=24&limit=50
interface JobsQuery {
  hours?: number;    // 過去何時間のデータ（デフォルト: 24）
  limit?: number;    // 最大取得件数（デフォルト: 50）
  minScore?: number; // 最低スコア
}

interface JobsResponse {
  jobs: JobData[];
  totalCount: number;
  timeRange: {
    from: string;
    to: string;
  };
  hasMore: boolean;
}

export const getJobsHandler = async (
  event: APIGatewayProxyEvent
): Promise<APIGatewayProxyResult> => {
  try {
    const query: JobsQuery = event.queryStringParameters || {};
    const hours = parseInt(query.hours || '24');
    const limit = parseInt(query.limit || '50');
    const minScore = query.minScore ? parseFloat(query.minScore) : undefined;
    
    const s3DataService = new S3DataService();
    let jobs = await s3DataService.getRecentJobs(hours);
    
    // スコアフィルタ適用（評価データと結合）
    if (minScore !== undefined) {
      const evaluations = await s3DataService.getRecentEvaluations(hours);
      const highScoreJobIds = new Set(
        evaluations.filter(e => e.score >= minScore).map(e => e.jobId)
      );
      jobs = jobs.filter(job => highScoreJobIds.has(job.id));
    }
    
    // ページング
    const paginatedJobs = jobs.slice(0, limit);
    const hasMore = jobs.length > limit;
    
    const response: JobsResponse = {
      jobs: paginatedJobs,
      totalCount: jobs.length,
      timeRange: {
        from: new Date(Date.now() - hours * 60 * 60 * 1000).toISOString(),
        to: new Date().toISOString()
      },
      hasMore
    };
    
    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(response)
    };
  } catch (error) {
    return createErrorResponse(APIErrorCode.S3_OPERATION_FAILED, error.message);
  }
};
```

#### 2.3.2 実行状況取得

```typescript
// GET /api/status
interface SystemStatusResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  lastExecution: {
    id: string;
    timestamp: string;
    status: string;
    duration: number;
    results: {
      jobsScraped: number;
      newJobs: number;
      highScoreJobs: number;
    };
  } | null;
  nextExecution: string; // 次回実行予定時刻
  monthlyStats: {
    executions: number;
    totalJobs: number;
    totalCost: number;
    budgetRemaining: number;
  };
  alerts: string[]; // アラート一覧
}

export const getSystemStatusHandler = async (): Promise<APIGatewayProxyResult> => {
  try {
    const s3DataService = new S3DataService();
    
    // 最新の実行ログを取得
    const lastExecution = await s3DataService.getLatestExecutionLog();
    
    // 月次統計を計算
    const monthlyStats = await calculateMonthlyStats();
    
    // システム健康状態を判定
    const status = determineSystemHealth(lastExecution, monthlyStats);
    
    // アラートをチェック
    const alerts = await checkSystemAlerts(monthlyStats);
    
    const response: SystemStatusResponse = {
      status,
      lastExecution: lastExecution ? {
        id: lastExecution.executionId,
        timestamp: lastExecution.timestamp,
        status: lastExecution.status,
        duration: lastExecution.duration,
        results: {
          jobsScraped: lastExecution.jobsScraped,
          newJobs: lastExecution.newJobs,
          highScoreJobs: lastExecution.highScoreJobs
        }
      } : null,
      nextExecution: getNextExecutionTime(),
      monthlyStats,
      alerts
    };
    
    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(response)
    };
  } catch (error) {
    return createErrorResponse(APIErrorCode.INTERNAL_SERVER_ERROR, error.message);
  }
};
```

## 3. 外部API連携

### 3.1 ChatGPT API連携

```typescript
// OpenAI API接続設定
interface ChatGPTAPIConfig {
  baseURL: 'https://api.openai.com/v1';
  model: 'gpt-3.5-turbo';
  maxTokens: 200;
  temperature: 0.3;
  timeout: 30000; // 30秒
}

// API呼び出しサービス
class ChatGPTAPIService {
  private client: OpenAI;
  private rateLimiter: RateLimiter;
  private costTracker: CostTracker;

  constructor(apiKey: string) {
    this.client = new OpenAI({ apiKey });
    this.rateLimiter = new RateLimiter({
      requestsPerMinute: 50,  // レート制限対応
      requestsPerHour: 1000
    });
    this.costTracker = new CostTracker({
      monthlyLimit: 3.0 // $3/月制限
    });
  }

  async evaluateJob(job: JobData): Promise<JobEvaluation> {
    // コスト制限チェック
    if (this.costTracker.isOverLimit()) {
      throw new Error('Monthly AI budget exceeded');
    }

    // レート制限チェック
    await this.rateLimiter.waitIfNeeded();

    try {
      const prompt = this.createEvaluationPrompt(job);
      
      const response = await this.client.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: prompt }],
        max_tokens: 200,
        temperature: 0.3,
        response_format: { type: 'json_object' }
      });

      const content = response.choices[0]?.message?.content;
      if (!content) {
        throw new Error('Empty response from ChatGPT API');
      }

      const evaluation = this.parseEvaluationResponse(content, job.id);
      
      // コスト追跡
      const cost = this.calculateCost(response.usage);
      this.costTracker.addUsage(cost);
      
      return {
        ...evaluation,
        tokenUsed: response.usage?.total_tokens || 0,
        costEstimate: cost
      };

    } catch (error) {
      if (error.status === 429) {
        throw new APIError(APIErrorCode.RATE_LIMIT_EXCEEDED, 'ChatGPT API rate limit exceeded');
      }
      if (error.status >= 500) {
        throw new APIError(APIErrorCode.EXTERNAL_API_ERROR, 'ChatGPT API server error');
      }
      throw new APIError(APIErrorCode.AI_EVALUATION_FAILED, error.message);
    }
  }

  private createEvaluationPrompt(job: JobData): string {
    return `
案件を評価してJSON形式で回答してください：

案件情報:
- タイトル: ${job.title}
- 予算: ${job.budget.toLocaleString()}円
- 納期: ${job.deadline.toLocaleDateString()}
- クライアント評価: ${job.clientRating}/5.0
- 必要スキル: ${job.skills.join(', ')}
- 概要: ${job.description.slice(0, 200)}

評価基準:
1. 予算の妥当性（相場との比較）
2. スキルマッチング度
3. クライアントの信頼性
4. 案件説明の明確性
5. 納期の現実性

回答形式:
{
  "score": 1-10の整数,
  "reason": "評価理由（50文字以内）",
  "strengths": ["強み1", "強み2"],
  "concerns": ["懸念1", "懸念2"]
}
`;
  }

  private parseEvaluationResponse(content: string, jobId: string): JobEvaluation {
    try {
      const parsed = JSON.parse(content);
      
      return {
        jobId,
        evaluatedAt: new Date(),
        score: Math.max(1, Math.min(10, parseInt(parsed.score))),
        reason: (parsed.reason || '').slice(0, 50),
        aiModel: 'gpt-3.5-turbo',
        tokenUsed: 0, // 後で設定
        costEstimate: 0, // 後で設定
        strengths: (parsed.strengths || []).slice(0, 3),
        concerns: (parsed.concerns || []).slice(0, 3)
      };
    } catch (error) {
      // パース失敗時はデフォルト評価
      return createDefaultEvaluation(jobId);
    }
  }

  private calculateCost(usage: any): number {
    const inputTokens = usage?.prompt_tokens || 0;
    const outputTokens = usage?.completion_tokens || 0;
    
    // GPT-3.5-turbo pricing: $0.0015/1K input, $0.002/1K output
    return (inputTokens * 0.0015 + outputTokens * 0.002) / 1000;
  }
}
```

### 3.2 クラウドワークススクレイピング

```typescript
// スクレイピングサービス設定
interface ScrapingConfig {
  baseURL: 'https://crowdworks.jp';
  userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36';
  timeout: 30000;
  retryCount: 3;
  retryDelay: 2000;
}

// スクレイピングAPI
class CrowdWorksScrapingService {
  private browser: Browser | null = null;
  private page: Page | null = null;
  private isAuthenticated: boolean = false;

  async initialize(): Promise<void> {
    try {
      this.browser = await playwright.chromium.launch({
        headless: true,
        args: ['--no-sandbox', '--disable-setuid-sandbox'] // Lambda用設定
      });

      this.page = await this.browser.newPage({
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
      });

      // タイムアウト設定
      this.page.setDefaultTimeout(30000);
      
    } catch (error) {
      throw new APIError(APIErrorCode.SCRAPING_FAILED, `Browser initialization failed: ${error.message}`);
    }
  }

  async authenticate(credentials: { email: string; password: string }): Promise<void> {
    if (!this.page) {
      throw new APIError(APIErrorCode.SCRAPING_FAILED, 'Browser not initialized');
    }

    try {
      // ログインページに移動
      await this.page.goto('https://crowdworks.jp/login');
      
      // ログインフォーム入力
      await this.page.fill('input[name="email"]', credentials.email);
      await this.page.fill('input[name="password"]', credentials.password);
      
      // ログイン実行
      await this.page.click('button[type="submit"]');
      
      // ログイン成功確認
      await this.page.waitForURL('**/dashboard', { timeout: 10000 });
      
      this.isAuthenticated = true;
      
    } catch (error) {
      throw new APIError(APIErrorCode.AUTHENTICATION_FAILED, `CrowdWorks login failed: ${error.message}`);
    }
  }

  async searchJobs(conditions: SearchCondition[]): Promise<JobData[]> {
    if (!this.isAuthenticated || !this.page) {
      throw new APIError(APIErrorCode.AUTHENTICATION_FAILED, 'Not authenticated');
    }

    const allJobs: JobData[] = [];

    for (const condition of conditions) {
      if (!condition.enabled) continue;

      try {
        const jobs = await this.searchWithCondition(condition);
        allJobs.push(...jobs);
        
        // レート制限対応（検索間隔）
        await this.delay(2000);
        
      } catch (error) {
        console.warn(`Search failed for condition ${condition.id}:`, error.message);
        // 個別の検索失敗は全体を止めない
      }
    }

    return allJobs;
  }

  private async searchWithCondition(condition: SearchCondition): Promise<JobData[]> {
    if (!this.page) throw new Error('Page not available');

    const jobs: JobData[] = [];

    try {
      // 検索ページに移動
      await this.page.goto('https://crowdworks.jp/projects/search');
      
      // 検索条件設定
      await this.setSearchFilters(condition);
      
      // 検索実行
      await this.page.click('button[type="submit"]');
      await this.page.waitForSelector('.project-item', { timeout: 10000 });
      
      // 案件リスト取得
      const jobElements = await this.page.$$('.project-item');
      
      for (const element of jobElements.slice(0, 20)) { // 最大20件
        try {
          const jobData = await this.extractJobData(element);
          if (jobData && this.validateJobData(jobData)) {
            jobs.push(jobData);
          }
        } catch (error) {
          console.warn('Failed to extract job data:', error.message);
        }
      }
      
    } catch (error) {
      throw new APIError(APIErrorCode.SCRAPING_FAILED, `Search failed: ${error.message}`);
    }

    return jobs;
  }

  async cleanup(): Promise<void> {
    if (this.page) {
      await this.page.close();
      this.page = null;
    }
    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }
    this.isAuthenticated = false;
  }
}
```

## 4. 通知API設計

### 4.1 SNS通知サービス

```typescript
// SNS通知設定
interface NotificationConfig {
  errorTopic: string;          // エラー通知用SNSトピック
  highScoreTopic: string;      // 高評価案件通知用
  email: string;               // 通知先メールアドレス
  enabled: boolean;            // 通知有効フラグ
}

// 通知サービス
class NotificationService {
  private sns: SNSClient;
  private ses: SESClient;
  private config: NotificationConfig;

  constructor(config: NotificationConfig) {
    this.sns = new SNSClient({});
    this.ses = new SESClient({});
    this.config = config;
  }

  // エラー通知
  async sendErrorAlert(error: Error, executionId: string): Promise<void> {
    if (!this.config.enabled) return;

    const message = {
      timestamp: new Date().toISOString(),
      executionId,
      errorType: error.constructor.name,
      errorMessage: error.message,
      severity: this.determineSeverity(error)
    };

    try {
      await this.sns.publish({
        TopicArn: this.config.errorTopic,
        Subject: `[CrowdWorks Searcher] ${message.severity} Error`,
        Message: JSON.stringify(message, null, 2)
      });
    } catch (snsError) {
      console.error('Failed to send error notification:', snsError);
    }
  }

  // 高評価案件通知
  async sendHighScoreAlert(jobs: JobEvaluation[]): Promise<void> {
    if (!this.config.enabled || jobs.length === 0) return;

    const message = {
      timestamp: new Date().toISOString(),
      jobCount: jobs.length,
      jobs: jobs.map(job => ({
        jobId: job.jobId,
        score: job.score,
        reason: job.reason
      }))
    };

    try {
      await this.sns.publish({
        TopicArn: this.config.highScoreTopic,
        Subject: `[CrowdWorks Searcher] ${jobs.length} High Score Job(s) Found`,
        Message: JSON.stringify(message, null, 2)
      });
    } catch (snsError) {
      console.error('Failed to send high score notification:', snsError);
    }
  }
}
```

## 5. エラーハンドリング共通実装

```typescript
// エラー処理ヘルパー
export const createErrorResponse = (
  errorCode: APIErrorCode,
  message: string,
  details?: Record<string, any>
): APIGatewayProxyResult => {
  const error: APIErrorResponse = {
    error: {
      code: errorCode,
      message,
      timestamp: new Date().toISOString(),
      requestId: uuidv4(),
      retryable: isRetryableError(errorCode),
      details
    }
  };

  return {
    statusCode: ERROR_STATUS_MAP[errorCode] || 500,
    headers: {
      'Content-Type': 'application/json',
      'X-Request-ID': error.error.requestId
    },
    body: JSON.stringify(error)
  };
};

// カスタムエラークラス
export class APIError extends Error {
  constructor(
    public code: APIErrorCode,
    message: string,
    public retryable: boolean = false,
    public details?: Record<string, any>
  ) {
    super(message);
    this.name = 'APIError';
  }
}

// リトライ可能エラーの判定
const isRetryableError = (errorCode: APIErrorCode): boolean => {
  return [
    APIErrorCode.SERVICE_UNAVAILABLE,
    APIErrorCode.TIMEOUT_ERROR,
    APIErrorCode.EXTERNAL_API_ERROR,
    APIErrorCode.RATE_LIMIT_EXCEEDED
  ].includes(errorCode);
};
```
</file>

<file path="env.example">
# ローカル開発用環境変数
# このファイルを .env にコピーして実際の値を設定してください

# CrowdWorks認証情報（ローカル開発用）
CROWDWORKS_EMAIL=your-crowdworks-email@example.com
CROWDWORKS_PASSWORD=your-crowdworks-password

# AWS設定（必要に応じて）
AWS_REGION=ap-northeast-1
AWS_PROFILE=default

# デバッグ設定
NODE_ENV=development
LOG_LEVEL=debug
DEBUG=1

# Playwright設定（ローカル開発用）
# ローカル環境では通常は空または未設定でOK（Playwrightが自動で見つける）
# カスタムパスを使いたい場合のみ設定
PLAYWRIGHT_BROWSERS_PATH=
# 例：カスタムインストール場所を使用する場合
# PLAYWRIGHT_BROWSERS_PATH=C:\Users\n\AppData\Local\ms-playwright

# ローカル環境ではブラウザダウンロードをスキップしない（0 = ダウンロードする）
PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=0
</file>

<file path="README-setup.md">
# CrowdWorks Search - ローカル開発セットアップ手順

## 🔐 認証情報設定

### 方法1: 環境変数設定（推奨：ローカル開発用）

1. **環境変数ファイル作成**:
```bash
# env.example を .env にコピー
cp env.example .env

# .env ファイルを編集して実際の認証情報を設定
# Windows PowerShell の場合:
notepad .env

# 以下の値を設定:
CROWDWORKS_EMAIL=your-crowdworks-email@example.com
CROWDWORKS_PASSWORD=your-crowdworks-password
```

2. **環境変数を読み込んでテスト実行**:
```bash
# PowerShell で環境変数読み込み
Get-Content .env | ForEach-Object {
    $name, $value = $_.split('=', 2)
    Set-Item -Path "env:$name" -Value $value
}

# ローカルテスト実行
npm run test:login:local
```

### 方法2: AWS Parameter Store設定（本番用）

1. **Parameter Store に認証情報を設定**:
```bash
# CrowdWorks メールアドレス
aws ssm put-parameter \
  --name "/crowdworks-search/crowdworks/email" \
  --value "your-crowdworks-email@example.com" \
  --type "SecureString" \
  --region ap-northeast-1

# CrowdWorks パスワード
aws ssm put-parameter \
  --name "/crowdworks-search/crowdworks/password" \
  --value "your-crowdworks-password" \
  --type "SecureString" \
  --region ap-northeast-1
```

2. **Parameter Store パラメータ確認**:
```bash
# パラメータ一覧表示
aws ssm describe-parameters --region ap-northeast-1

# 特定パラメータの値確認（復号化して表示）
aws ssm get-parameter \
  --name "/crowdworks-search/crowdworks/email" \
  --with-decryption \
  --region ap-northeast-1
```

## 🎭 Playwright設定

### ローカル環境でのPlaywright設定

**重要**: ローカル環境では通常 `PLAYWRIGHT_BROWSERS_PATH` を設定する必要はありません。

1. **Playwrightブラウザインストール**:
```bash
# Chromiumブラウザインストール
npx playwright install chromium

# 全ブラウザインストール（必要に応じて）
npx playwright install

# システム依存関係もインストール
npx playwright install-deps
```

2. **環境変数設定（通常は不要）**:
```bash
# .env ファイルでの設定例
PLAYWRIGHT_BROWSERS_PATH=
PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=0
```

### 環境別のPlaywright設定

| 環境 | PLAYWRIGHT_BROWSERS_PATH | PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD | 説明 |
|------|-------------------------|-----------------------------------|------|
| **ローカル** | `空` または未設定 | `0` (ダウンロードする) | Playwrightが自動でブラウザを管理 |
| **Lambda Container** | `/usr/bin` | `1` (スキップ) | システムインストール済みChromiumを使用 |
| **CI/CD** | `空` または未設定 | `0` (ダウンロードする) | テスト用ブラウザをインストール |

### Playwrightブラウザの場所確認

```bash
# インストール場所確認
npx playwright --version

# Windowsの通常のインストール場所:
# C:\Users\{ユーザー名}\AppData\Local\ms-playwright\chromium-{バージョン}

# ブラウザが正常にインストールされているか確認
npx playwright list-files chromium
```

## 🧪 ローカルテスト実行

### 1. 依存関係インストール
```bash
npm install
```

### 2. Playwrightブラウザインストール
```bash
npx playwright install chromium
```

### 3. TypeScriptビルド
```bash
npm run build
```

### 4. CrowdWorksログインテスト
```bash
# 環境変数から認証情報取得
npm run test:login:local

# または直接実行
npx ts-node src/test/crowdworks-scraping-test.ts
```

### 5. テスト結果確認
```
🚀 CrowdWorksログインテスト開始...
🔐 CrowdWorks認証情報を取得中...
✅ 環境変数から認証情報取得完了
📄 CrowdWorksログインページアクセス中...
✅ ログインページ読み込み完了
📧 メールアドレス入力中...
🔑 パスワード入力中...
📸 ログイン前スクリーンショット保存: login-before.png
🖱️ ログインボタンクリック中...
⏳ ログイン処理完了待機中...
📸 ログイン後スクリーンショット保存: login-after.png
🔍 ログイン状態確認中...
✅ ログイン成功！
⏸️ 5秒間待機（ログイン状態確認）...
🔒 ブラウザクローズ完了
🎉 CrowdWorksログインテスト完了
```

## 🚀 Lambda Container デプロイ

### 1. CDK スタック確認
```bash
npm run cdk:synth
```

### 2. Lambda Container デプロイ
```bash
npm run cdk:deploy:container
```

## 🔧 トラブルシューティング

### 認証エラーの場合
```bash
# AWS CLI設定確認
aws configure list

# Parameter Store アクセス権限確認
aws ssm describe-parameters --region ap-northeast-1

# IAM ユーザーの権限確認
aws sts get-caller-identity
```

### Playwright ブラウザエラーの場合
```bash
# Playwright ブラウザインストール
npx playwright install chromium

# 依存関係確認
npx playwright install-deps

# ブラウザ場所確認
where chromium  # Windows
which chromium  # Linux/Mac

# Playwrightがブラウザを見つけられない場合の詳細確認
npx playwright --help
```

### よくあるPlaywrightエラー

1. **"Browser not found"エラー**:
```bash
# 解決方法
npx playwright install chromium
```

2. **"PLAYWRIGHT_BROWSERS_PATH"が無効**:
```bash
# .env ファイルで空に設定または削除
PLAYWRIGHT_BROWSERS_PATH=
```

3. **権限エラー（Linux/WSL）**:
```bash
# 依存関係インストール
sudo npx playwright install-deps
```

## 📁 生成されるファイル

ローカルテスト実行時に以下のファイルが生成されます:
- `login-before.png`: ログイン前のスクリーンショット
- `login-after.png`: ログイン後のスクリーンショット

## 🔒 セキュリティ注意事項

1. **`.env` ファイルはコミットしない**（`.gitignore` で除外済み）
2. **認証情報をコードに直接書かない**
3. **Parameter Store は `SecureString` タイプを使用**
4. **本番環境では Parameter Store を使用**
5. **ローカル開発時のみ環境変数を使用**
</file>

<file path="src/services/index.ts">
// Services module exports
// TODO: 実際のサービスクラスを実装後、ここからエクスポート

export {};
</file>

<file path="src/utils/index.ts">
// Utility functions exports
// TODO: ユーティリティ関数を実装後、ここからエクスポート

export {};
</file>

<file path="docs/01_requirements.md">
# 要件定義書

## 1. プロジェクト概要

### 1.1 プロジェクト名
クラウドワークス案件自動検索・評価システム（CrowdWorks Auto Job Searcher）

### 1.2 目的・背景
クラウドワークス上で適切な案件を効率的に発見し、案件の品質やマッチング度を自動評価することで、フリーランサーの案件選定業務を自動化・効率化する。

**背景**
- 手動での案件チェックは時間がかかる
- 良い案件を見逃すリスクがある
- 案件の評価に主観が入りやすい
- 定期的なチェックが困難
- 個人利用でのコスト効率性を重視

### 1.3 スコープ
**対象範囲**
- クラウドワークス上の案件情報の自動取得
- AI（ChatGPT）による案件評価
- 検索条件の管理・保存
- 定期実行による継続監視
- AWSサーバレス環境での運用
- 直近1週間のデータ管理（案件のcloseが早いため）

**対象外**
- 他のクラウドソーシングサイト
- 案件への自動応募機能
- クライアントとのやり取り自動化
- オンプレミス環境での運用
- 長期間のデータ分析・トレンド分析

## 2. 機能要件

### 2.1 Must（必須機能）
- **検索条件管理機能**
  - 検索条件の保存・読み込み（S3 JSON形式）
  - 複数の検索条件セットの管理
- **自動取得機能**
  - 15分間隔での自動実行（EventBridge）
  - AWSサーバレス環境での安定動作
  - ブラウザ自動操作によるデータ取得（Playwright on Lambda）
- **AI評価機能（軽量版）**
  - ChatGPT APIを使用した案件評価（事前フィルタ後）
  - おすすめ度のスコアリング（1-10点）
  - 評価理由の文章生成
- **データ保存機能**
  - 取得した案件データの永続化（S3 JSON形式）
  - 評価結果の履歴保存（1週間）
  - 重複案件の検出・除外（過去24-48時間分）

### 2.2 Should（重要機能）
- **通知機能**
  - 高評価案件の即座通知（SNS/SES）
  - 実行エラー時の通知
- **フィルタリング機能**
  - 予算範囲での絞り込み
  - スキルセットマッチング
  - 納期条件でのフィルタ
- **ログ・監視機能**
  - 実行ログの記録（S3 JSON形式）
  - エラー発生時の通知
  - 日次サマリー生成

### 2.3 Could（あれば良い機能）
- **簡易レポート機能**
  - 週次の案件動向サマリー
  - 高評価案件の傾向分析
- **Webダッシュボード**
  - S3データを読み込む静的サイト（Vercel等）
  - 設定変更用の簡易UI

## 3. 非機能要件

### 3.1 パフォーマンス要件
- 15分間隔での実行を確実に実行
- Lambda関数のタイムアウト: 最大10分
- 1回の実行で最大50件の案件を処理
- 実行時間1分以内を目標（コスト削減のため）
- AI評価は高ポテンシャル案件のみ（コスト削減）

### 3.2 可用性要件
- AWSサーバレス環境での24時間365日稼働
- システム障害時の自動復旧機能
- ネットワーク障害時のリトライ機能（最大3回）
- 稼働率: 95%以上（個人利用レベル）

### 3.3 セキュリティ要件
- AWS Systems Manager Parameter Store でのシークレット管理
- IAMロールによる最小権限アクセス制御
- S3バケットのプライベート設定
- 取得データの保護（S3暗号化）
- ログの機密情報マスキング

### 3.4 運用・保守性要件
- S3での構造化ログ管理
- AWS CDK での Infrastructure as Code
- Lambda関数のバージョン管理
- エラー時のSNS通知
- 7日間の自動データ削除（S3 Lifecycle Policy）

### 3.5 コスト要件
- **月額運用コスト: $5以下を厳守**
- Lambda実行時間の最適化（1分以内）
- S3使用量の最小化
- CloudWatch使用の完全廃止
- ChatGPT API使用量の制限（事前フィルタリング）

## 4. 制約事項

### 4.1 技術的制約
- AWS サーバレス環境での開発・運用
- TypeScript での型安全性確保（any型の使用禁止）
- Lambda関数の実行時間制限（最大10分）
- Playwrightブラウザのメモリ制限
- S3での構造化データ管理（NoSQL機能なし）
- クラウドワークスの利用規約遵守

### 4.2 運用制約
- ChatGPT API の利用料金制限（月$3以下）
- AWS サービス利用料金制限（月$2以下）
- クラウドワークスへのアクセス頻度制限
- 1日あたりの最大実行回数: 96回（15分×4×24時間）
- Lambda同時実行数制限
- データ保持期間: 最大7日間

### 4.3 その他制約
- 個人利用目的に限定
- 商用利用は別途検討が必要
- スクレイピング対象サイトの仕様変更リスク
- AWSアカウントの利用可能リージョン制限
- リアルタイム分析機能なし

## 5. 前提条件
- AWSアカウントが作成済み
- 適切なIAM権限が設定済み
- ChatGPT API キーが取得済み
- クラウドワークスアカウントが作成済み
- インターネット接続が安定している
- AWS CLI/CDK の実行環境
- 案件は1週間程度でcloseするため短期データ管理で十分

## 6. 用語定義
| 用語 | 定義 |
|------|------|
| 案件 | クラウドワークス上で公開されている仕事の依頼 |
| 検索条件 | 案件を絞り込むためのフィルター設定 |
| 評価スコア | AI が算出する案件のおすすめ度（1-10点） |
| 実行履歴 | システムが自動実行した記録 |
| スクレイピング | ブラウザ自動操作によるデータ取得 |
| サーバレス | AWS Lambda等のサーバー管理不要なコンピューティングサービス |
| EventBridge | AWSのイベント駆動型サービス（旧CloudWatch Events） |
| 事前フィルタ | AI評価前の予算・キーワード等による絞り込み |
| TTL | Time To Live、S3での自動削除設定 |
</file>

<file path="docs/02_system_design.md">
# システム設計書

## 1. システム概要

### 1.1 システム構成図

```
                        ┌─────────────────────────────────────┐
                        │             AWS Cloud                │
                        │                                     │
    ┌──────────────────────────────────────────────────────────────┐
    │                    EventBridge (15分間隔)                      │
    └──────────────────────┬───────────────────────────────────────┘
                           │
                           ▼
    ┌──────────────────────────────────────────────────────────────┐
    │                 Lambda Function (Main)                       │
    │  ┌─────────────┐  ┌──────────────┐  ┌──────────────────┐    │
    │  │ Scheduler   │  │   Scraper    │  │   AI Evaluator   │    │
    │  │   Logic     │─▶│ (Playwright) │─▶│  (ChatGPT API)   │    │
    │  └─────────────┘  └──────────────┘  └──────────────────┘    │
    └──────────────────────┬───────────────────────┬───────────────┘
                           │                       │
                           ▼                       │
    ┌──────────────────────────────────────────────┼───────────────┐
    │                     S3 Bucket                │               │
    │  ┌─────────────────┐  ┌─────────────────┐   │               │
    │  │ jobs/           │  │   logs/         │   │               │
    │  │ (案件データ)      │  │ (実行ログ)       │   │               │
    │  └─────────────────┘  └─────────────────┘   │               │
    │  ┌─────────────────┐  ┌─────────────────┐   │               │
    │  │ evaluations/    │  │  config/        │   │               │
    │  │ (評価結果)        │  │ (設定ファイル)    │   │               │
    │  └─────────────────┘  └─────────────────┘   │               │
    └──────────────────────────────────────────────┘               │
                           │                                       │
                           ▼                                       │
    ┌──────────────────────────────────────────────────────────────┘
    │                 支援サービス（最小構成）
    │  ┌─────────────────┐  ┌─────────────────┐
    │  │ Parameter Store │  │      SNS        │
    │  │  (Secrets)      │  │ (Error Notify)  │
    │  └─────────────────┘  └─────────────────┘
    └──────────────────────────────────────────────────────────────┘
                           │
                           ▼
                    ┌──────────────────┐
                    │ External Services│
                    │ - CrowdWorks     │
                    │ - ChatGPT API    │
                    └──────────────────┘
```

### 1.2 アーキテクチャ方針

- **コストファースト**: 月$5以下の厳格なコスト制約を最優先
- **S3中心設計**: データストレージ・ログ・設定をすべてS3で管理
- **シンプル・軽量**: 複雑な機能を排除し、コア機能に集中
- **事前フィルタリング**: AI評価前の絞り込みでコスト削減
- **短期データ管理**: 7日間のTTLで自動削除
- **型安全性**: TypeScript strict モードで完全な型定義

### 1.3 技術スタック

**コンピューティング**
- **AWS Lambda** (Node.js 18.x): メイン実行環境
- **EventBridge**: スケジューリング（15分間隔）
- **AWS CDK** (TypeScript): Infrastructure as Code

**データ・ストレージ**
- **S3**: 全データの一元管理（案件・ログ・設定・評価結果）
- **S3 Lifecycle Policy**: 7日後自動削除
- **Parameter Store**: シークレット管理のみ

**言語・ライブラリ**
- **TypeScript** (v5以上): 型安全性確保、any型使用禁止
- **Playwright**: ブラウザ自動化（Lambda Layer）
- **AWS SDK v3**: AWS サービス連携
- **OpenAI SDK**: ChatGPT連携（軽量利用）

**監視・運用（最小構成）**
- **SNS**: エラー通知のみ
- **S3ベースログ**: 構造化JSON形式

## 2. コンポーネント設計

### 2.1 スケジューラー

**責務**
- EventBridge からのトリガー受信
- Lambda関数の実行制御
- 実行時間の最適化（1分以内目標）

**実装方式**
```typescript
// EventBridge Rule
const scheduleRule = new events.Rule(this, 'ScheduleRule', {
  schedule: events.Schedule.rate(Duration.minutes(15)),
  targets: [new targets.LambdaFunction(mainFunction)]
});

interface SchedulerEvent {
  source: 'aws.events';
  'detail-type': 'Scheduled Event';
  detail: {};
}
```

### 2.2 スクレイパー

**責務**
- クラウドワークスへの軽量アクセス
- 効率的なデータ抽出（最大50件/回）
- 事前フィルタリング実行

**軽量化設計**
```typescript
interface IScrapperService {
  authenticateUser(credentials: LoginCredentials): Promise<void>;
  searchJobsLight(condition: SearchCondition): Promise<JobData[]>;
  applyPreFilter(jobs: JobData[]): JobData[]; // AI評価前フィルタ
  validateJobData(job: JobData): boolean;
}

// 事前フィルタリング例
const applyPreFilter = (jobs: JobData[]): JobData[] => {
  return jobs.filter(job => 
    job.budget >= 50000 &&           // 最低予算
    job.clientRating >= 4.0 &&       // クライアント評価
    hasTargetSkills(job.skills) &&   // スキルマッチング
    isReasonableDeadline(job.deadline) // 納期チェック
  );
};
```

### 2.3 データストレージ（S3ベース）

**責務**
- S3での構造化データ管理
- JSON形式でのシンプルな読み書き
- TTL機能による自動削除

**ファイル構造設計**
```typescript
// S3 Bucket構造
interface S3Structure {
  'jobs/': {
    pattern: 'YYYY-MM-DDTHH-mm.json';
    example: '2024-01-15T14-30.json';
    ttl: '7 days';
  };
  'evaluations/': {
    pattern: 'YYYY-MM-DDTHH-mm.json';
    example: '2024-01-15T14-30.json';
    ttl: '7 days';
  };
  'logs/': {
    execution: 'YYYY-MM-DDTHH-mm-execution.json';
    error: 'YYYY-MM-DDTHH-mm-error.json';
    daily: 'daily-summary/YYYY-MM-DD.json';
    ttl: '7 days';
  };
  'config/': {
    searchConditions: 'search-conditions.json';
    system: 'system-config.json';
    ttl: 'none';
  };
}

// データ操作サービス
class S3DataService {
  async saveJobs(jobs: JobData[]): Promise<void> {
    const timestamp = new Date().toISOString().slice(0, 16);
    await this.s3.putObject({
      Bucket: this.bucketName,
      Key: `jobs/${timestamp}.json`,
      Body: JSON.stringify(jobs, null, 2),
      ServerSideEncryption: 'AES256'
    }).promise();
  }

  async getRecentJobs(hours: number = 24): Promise<JobData[]> {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    const objects = await this.listObjectsSince('jobs/', cutoff);
    
    const allJobs: JobData[] = [];
    for (const obj of objects) {
      const data = await this.getObject(obj.Key);
      allJobs.push(...JSON.parse(data));
    }
    return allJobs;
  }

  async getExistingJobIds(hours: number = 48): Promise<Set<string>> {
    const recentJobs = await this.getRecentJobs(hours);
    return new Set(recentJobs.map(job => job.id));
  }
}
```

### 2.4 AI評価エンジン（軽量版）

**責務**
- 事前フィルタ済み案件のみ評価
- バッチ処理での効率化
- コスト監視機能

**軽量実装**
```typescript
class LightAIEvaluatorService {
  private monthlyUsage: number = 0;
  private readonly MONTHLY_LIMIT = 3; // $3/月制限

  async evaluateFilteredJobs(jobs: JobData[]): Promise<JobEvaluation[]> {
    // コスト制限チェック
    if (this.monthlyUsage >= this.MONTHLY_LIMIT) {
      throw new Error('Monthly AI budget exceeded');
    }

    // 最重要案件のみ評価（さらなる絞り込み）
    const priorityJobs = this.selectPriorityJobs(jobs);
    
    const evaluations: JobEvaluation[] = [];
    for (const job of priorityJobs) {
      try {
        const evaluation = await this.evaluateJob(job);
        evaluations.push(evaluation);
        
        // 使用量追跡
        this.monthlyUsage += this.estimateTokenCost(job);
        
      } catch (error) {
        // AI評価失敗時はデフォルトスコア
        evaluations.push(this.createDefaultEvaluation(job));
      }
    }
    
    return evaluations;
  }

  private selectPriorityJobs(jobs: JobData[]): JobData[] {
    return jobs
      .sort((a, b) => b.budget - a.budget) // 高予算順
      .slice(0, 10); // 上位10件のみ
  }

  private estimateTokenCost(job: JobData): number {
    const tokenCount = (job.title.length + job.description.length) / 4;
    return tokenCount * 0.002 / 1000; // GPT-3.5-turbo価格
  }
}
```

### 2.5 設定管理（S3ベース）

**責務**
- S3での設定ファイル管理
- Parameter Store でのシークレット管理
- 軽量な設定読み込み

**設定構造**
```typescript
// config/system-config.json
interface SystemConfig {
  scraping: {
    maxJobsPerExecution: 50;
    preFilterEnabled: true;
    minBudget: 50000;
    minClientRating: 4.0;
  };
  ai: {
    enabled: true;
    model: 'gpt-3.5-turbo';
    maxJobsForEvaluation: 10;
    monthlyBudgetLimit: 3.0;
  };
  notification: {
    enabled: true;
    scoreThreshold: 7;
    errorNotificationEnabled: true;
  };
  storage: {
    retentionDays: 7;
    compressionEnabled: false;
  };
}

// config/search-conditions.json
interface SearchConditions {
  conditions: Array<{
    id: string;
    name: string;
    keywords: string[];
    budgetMin: number;
    budgetMax: number;
    category: string;
    workType: 'fixed' | 'hourly';
    enabled: boolean;
  }>;
}
```

## 3. データフロー

### 3.1 データフロー図

```
EventBridge ──15分──▶ Lambda Function (Main Handler)
                            │
                            ▼
                    Parameter Store ──シークレット取得──▶ Scraper Service
                            │                              │
                            ▼                              ▼
                    S3 Config ◀──設定読み込み──────── CrowdWorks Site
                    (search-conditions.json)           │
                            │                          ▼
                            ▼                     案件データ取得
                    S3 Jobs ◀──重複チェック────── Pre-Filter
                    (過去48時間分)                    │
                            │                          ▼
                            ▼                     新規案件
                    S3 Jobs ◀────新規案件保存──── Light AI Evaluator
                    (timestamp.json)                  │
                            │                          ▼
                            ▼                     評価結果
                    S3 Evaluations ◀──評価保存─── High Score Filter
                    (timestamp.json)                  │
                            │                          ▼
                            ▼                     通知判定
                    S3 Logs ◀────実行ログ────── SNS Notification
                    (execution.json)              (エラー・高評価)
```

### 3.2 処理フロー

**最適化されたメイン処理フロー**
```typescript
export const handler = async (event: SchedulerEvent): Promise<void> => {
  const executionId = Date.now().toString();
  const startTime = Date.now();
  const timestamp = new Date().toISOString().slice(0, 16);
  
  const log: ExecutionLog = {
    executionId,
    timestamp,
    status: 'success',
    duration: 0,
    jobsScraped: 0,
    newJobs: 0,
    aiEvaluated: 0,
    highScoreJobs: 0,
    costEstimate: 0
  };

  try {
    // 1. 設定とシークレット取得（並列）
    const [config, credentials] = await Promise.all([
      s3DataService.getSystemConfig(),
      parameterService.getCredentials()
    ]);

    // 2. 重複チェック用データ取得
    const existingJobIds = await s3DataService.getExistingJobIds(48);

    // 3. スクレイピング実行
    const scraper = new ScraperService(credentials);
    const allJobs = await scraper.searchJobsLight(config.searchConditions);
    log.jobsScraped = allJobs.length;

    // 4. 重複排除
    const newJobs = allJobs.filter(job => !existingJobIds.has(job.id));
    log.newJobs = newJobs.length;

    if (newJobs.length === 0) {
      log.duration = Date.now() - startTime;
      await s3DataService.saveExecutionLog(log, timestamp);
      return; // 新規案件なしで終了
    }

    // 5. 新規案件保存
    await s3DataService.saveJobs(newJobs, timestamp);

    // 6. 事前フィルタ実行
    const filteredJobs = scraper.applyPreFilter(newJobs);

    // 7. AI評価（フィルタ後の優先案件のみ）
    let evaluations: JobEvaluation[] = [];
    if (config.ai.enabled && filteredJobs.length > 0) {
      const aiEvaluator = new LightAIEvaluatorService();
      evaluations = await aiEvaluator.evaluateFilteredJobs(filteredJobs);
      log.aiEvaluated = evaluations.length;
      log.costEstimate = aiEvaluator.getSessionCost();

      // 8. 評価結果保存
      await s3DataService.saveEvaluations(evaluations, timestamp);
    }

    // 9. 高評価案件通知
    const highScoreJobs = evaluations.filter(e => e.score >= config.notification.scoreThreshold);
    log.highScoreJobs = highScoreJobs.length;

    if (highScoreJobs.length > 0) {
      await notificationService.sendHighScoreAlert(highScoreJobs);
    }

    // 10. 実行ログ保存
    log.duration = Date.now() - startTime;
    await s3DataService.saveExecutionLog(log, timestamp);

  } catch (error) {
    log.status = 'error';
    log.error = {
      type: error.constructor.name,
      message: error.message,
      stack: error.stack
    };
    log.duration = Date.now() - startTime;

    // エラーログ保存
    await s3DataService.saveErrorLog(log, timestamp);

    // 重要エラーの通知
    if (shouldNotifyError(error)) {
      await notificationService.sendErrorAlert(error, executionId);
    }

    throw error; // Lambda失敗として記録
  }
};
```

## 4. インターフェース設計

### 4.1 外部API連携

**ChatGPT API（軽量版）**
```typescript
interface LightChatGPTRequest {
  model: 'gpt-3.5-turbo'; // GPT-4は使用しない（コスト削減）
  messages: ChatCompletionMessage[];
  max_tokens: 200; // 短縮
  temperature: 0.3; // 一貫性重視
  response_format: { type: 'json_object' };
}

const LIGHT_EVALUATION_PROMPT = `
案件を簡潔に評価してください（予算:{budget}円、クライアント評価:{clientRating}）：

{title}

スキル: {skills}
詳細: {description}

JSON形式で回答:
{"score": 1-10, "reason": "50文字以内"}
`;
```

### 4.2 内部データ構造

**軽量化データ型**
```typescript
interface JobData {
  id: string;
  title: string;
  description: string; // 500文字まで
  budget: number;
  deadline: Date;
  clientRating: number;
  skills: string[]; // 最大5個
  url: string;
  scrapedAt: Date;
}

interface JobEvaluation {
  jobId: string;
  score: number; // 1-10
  reason: string; // 50文字以内
  evaluatedAt: Date;
  tokenUsed: number; // コスト追跡
}

interface ExecutionLog {
  executionId: string;
  timestamp: string;
  status: 'success' | 'error' | 'partial';
  duration: number;
  jobsScraped: number;
  newJobs: number;
  aiEvaluated: number;
  highScoreJobs: number;
  costEstimate: number;
  error?: {
    type: string;
    message: string;
    stack?: string;
  };
}
```

## 5. セキュリティ設計

### 5.1 認証・認可（最小権限）

**IAM ロール設計**
```typescript
const lambdaRole = new iam.Role(this, 'LambdaExecutionRole', {
  assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
  managedPolicies: [
    iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole')
  ],
  inlinePolicies: {
    S3Access: new iam.PolicyDocument({
      statements: [
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          actions: [
            's3:GetObject',
            's3:PutObject',
            's3:ListBucket'
          ],
          resources: [
            s3Bucket.bucketArn,
            `${s3Bucket.bucketArn}/*`
          ]
        })
      ]
    }),
    ParameterStoreAccess: new iam.PolicyDocument({
      statements: [
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          actions: ['ssm:GetParameter'],
          resources: [`arn:aws:ssm:${region}:${account}:parameter/crowdworks-searcher/secrets`]
        })
      ]
    }),
    SNSAccess: new iam.PolicyDocument({
      statements: [
        new iam.PolicyStatement({
          effect: iam.Effect.ALLOW,
          actions: ['sns:Publish'],
          resources: [errorTopic.topicArn]
        })
      ]
    })
  }
});
```

### 5.2 データ保護

**S3セキュリティ設定**
```typescript
const s3Bucket = new s3.Bucket(this, 'CrowdWorksSearcherBucket', {
  encryption: s3.BucketEncryption.S3_MANAGED,
  blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
  lifecycleRules: [
    {
      id: 'DeleteOldData',
      enabled: true,
      expiration: Duration.days(7), // 7日後自動削除
      abortIncompleteMultipartUploadAfter: Duration.days(1)
    }
  ],
  versioning: false, // コスト削減
  removalPolicy: RemovalPolicy.DESTROY
});
```

## 6. エラーハンドリング設計

### 6.1 エラー分類（簡素化）

```typescript
export enum ErrorType {
  // 重要エラー（通知必要）
  AUTHENTICATION_ERROR = 'AUTH_ERROR',
  LAMBDA_TIMEOUT = 'LAMBDA_TIMEOUT',
  S3_ACCESS_ERROR = 'S3_ACCESS_ERROR',
  
  // 軽微エラー（ログのみ）
  SCRAPING_ERROR = 'SCRAPING_ERROR',
  AI_API_ERROR = 'AI_API_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR'
}

export class LightAppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public retryable: boolean = false
  ) {
    super(message);
  }
}
```

### 6.2 エラー処理方針

**軽量エラーハンドリング**
```typescript
class LightRetryHandler {
  async executeWithRetry<T>(
    operation: () => Promise<T>,
    maxRetries: number = 2 // 削減
  ): Promise<T> {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        if (attempt === maxRetries) throw error;
        await this.sleep(1000 * attempt); // シンプルなバックオフ
      }
    }
    throw new Error('Max retries exceeded');
  }
}

const shouldNotifyError = (error: Error): boolean => {
  const criticalErrors = [
    'AUTHENTICATION_ERROR',
    'LAMBDA_TIMEOUT', 
    'S3_ACCESS_ERROR'
  ];
  return criticalErrors.includes(error.constructor.name);
};
```

## 7. ログ設計（S3ベース）

### 7.1 S3ログ構造

```typescript
interface S3LogStructure {
  'logs/execution/': {
    pattern: 'YYYY-MM-DDTHH-mm-execution.json';
    content: ExecutionLog;
    retention: '7 days';
  };
  'logs/error/': {
    pattern: 'YYYY-MM-DDTHH-mm-error.json';
    content: ExecutionLog; // status = 'error'
    retention: '7 days';
  };
  'logs/daily-summary/': {
    pattern: 'YYYY-MM-DD.json';
    content: DailySummary;
    retention: '7 days';
  };
}

interface DailySummary {
  date: string;
  totalExecutions: number;
  successfulExecutions: number;
  totalJobsFound: number;
  totalNewJobs: number;
  averageScore: number;
  highScoreJobs: number;
  totalAICost: number;
  errors: string[];
}
```

### 7.2 ログ実装

**軽量ログサービス**
```typescript
class S3LogService {
  async saveExecutionLog(log: ExecutionLog, timestamp: string): Promise<void> {
    await this.s3.putObject({
      Bucket: this.bucketName,
      Key: `logs/execution/${timestamp}-execution.json`,
      Body: JSON.stringify(log, null, 2),
      ContentType: 'application/json'
    }).promise();
  }

  async saveErrorLog(log: ExecutionLog, timestamp: string): Promise<void> {
    await this.s3.putObject({
      Bucket: this.bucketName,
      Key: `logs/error/${timestamp}-error.json`,
      Body: JSON.stringify(log, null, 2),
      ContentType: 'application/json'
    }).promise();
  }

  async generateDailySummary(date: string): Promise<DailySummary> {
    const dayLogs = await this.getLogsForDate(date);
    
    return {
      date,
      totalExecutions: dayLogs.length,
      successfulExecutions: dayLogs.filter(l => l.status === 'success').length,
      totalJobsFound: dayLogs.reduce((sum, l) => sum + l.jobsScraped, 0),
      totalNewJobs: dayLogs.reduce((sum, l) => sum + l.newJobs, 0),
      averageScore: this.calculateAverageScore(dayLogs),
      highScoreJobs: dayLogs.reduce((sum, l) => sum + l.highScoreJobs, 0),
      totalAICost: dayLogs.reduce((sum, l) => sum + l.costEstimate, 0),
      errors: dayLogs.filter(l => l.error).map(l => l.error!.message)
    };
  }
}
```

## 8. コスト最適化戦略

### 8.1 コスト監視

```typescript
interface CostMonitor {
  trackLambdaExecution(duration: number, memoryMB: number): void;
  trackS3Operations(operations: S3Operation[]): void;
  trackAIUsage(tokens: number, model: string): void;
  generateMonthlyCostReport(): MonthlyCostReport;
}

interface MonthlyCostReport {
  lambda: { executions: number; cost: number };
  s3: { operations: number; storage: number; cost: number };
  ai: { tokens: number; cost: number };
  other: { sns: number; parameterStore: number };
  total: number;
  budgetRemaining: number;
}
```

### 8.2 自動コスト制御

```typescript
class CostController {
  private monthlyBudget = 5.0; // $5制限

  async checkBudgetBeforeExecution(): Promise<boolean> {
    const currentCost = await this.getCurrentMonthlyCost();
    return currentCost < this.monthlyBudget * 0.9; // 90%で制限
  }

  async suspendExpensiveFeatures(): Promise<void> {
    // AI評価を一時停止
    await this.updateConfig({ ai: { enabled: false } });
    
    // 通知送信
    await this.notifyBudgetExceeded();
  }
}
```

**これで月$5以下での運用が可能な設計になりました！**
</file>

<file path="docs/CI_CD_SETUP.md">
# CI/CD パイプライン セットアップガイド

## 概要

このプロジェクトでは、GitHub Actionsを使用した包括的なCI/CDパイプラインを構築しています。**Playwright Lambda制約に対応し、コンテナイメージ版デプロイをサポート**しています。

## **⚠️ 重要: Playwright Lambda対応**

### **技術的制約と解決策**
```yaml
Lambda制限:
  ZIP形式: 250MB (Playwright: ~300MB) ❌
  Container: 10GB ✅ 採用

対応方針:
  デプロイ形式: Docker Container Image
  レジストリ: Amazon ECR
  ビルド環境: GitHub Actions + Docker
```

## パイプライン構成

### ジョブフロー
```
コード品質チェック
├── 単体テスト (並行)
├── ビルドテスト (並行)  
└── セキュリティスキャン (並行)
    └── CDK構文チェック
        └── Dockerビルドテスト
            ├── Staging デプロイ (develop)
            └── Production デプロイ (main)
```

### 1. コード品質チェック（Code Quality Check）
- **実行条件**: 全ブランチ・全PRで実行
- **処理内容**:
  - ESLint（コード品質）
  - Prettier（フォーマット）
  - TypeScript型チェック
- **タイムアウト**: 10分

### 2. 単体テスト（Unit Tests）
- **実行条件**: コード品質チェック後
- **処理内容**:
  - Jest単体テスト実行
  - カバレッジレポート生成
  - Codecovアップロード
- **タイムアウト**: 15分

### 3. ビルドテスト（Build Test）
- **実行条件**: コード品質チェック後（並行実行）
- **処理内容**:
  - TypeScriptコンパイル
  - ビルド成果物の検証
  - アーティファクトのアップロード
- **タイムアウト**: 10分

### 4. セキュリティスキャン（Security Scan）
- **実行条件**: pushイベント時のみ
- **処理内容**:
  - npm audit実行
  - CodeQL分析（SAST）
  - 依存関係脆弱性チェック
- **タイムアウト**: 15分

### 5. CDK構文チェック（CDK Synth Check）
- **実行条件**: セキュリティスキャン成功後
- **処理内容**:
  - CDK synthesize実行
  - CloudFormationテンプレート生成
  - 構文エラーチェック
- **タイムアウト**: 10分

### 6. **Dockerビルドテスト（Container Build Test）**
- **実行条件**: CDK構文チェック成功後
- **処理内容**:
  - **Dockerイメージビルド（Lambda Container用）**
  - **Multi-stage buildテスト**
  - **Playwright環境確認**
  - **コンテナ実行テスト**
- **タイムアウト**: 20分

### 7. **デプロイ段階（Deployment）**

#### **Staging デプロイ（developブランチ）**
```yaml
環境: staging
トリガー: develop branch push
デプロイ方式: Container Image
処理:
  - ECRログイン
  - Dockerイメージビルド
  - ECRプッシュ
  - Lambda関数更新
```

#### **Production デプロイ（mainブランチ）**
```yaml
環境: production
トリガー: main branch push
デプロイ方式: Container Image
承認: 手動承認必須
処理:
  - ECRログイン
  - Dockerイメージビルド（本番用）
  - ECRプッシュ
  - Lambda関数更新
  - 監視アラート確認
```

## GitHubシークレット設定

### **必須シークレット設定**

CI/CDパイプラインを動作させるため、以下のGitHubシークレットを設定してください：

#### **1. AWS認証情報**
```bash
# Staging環境用
STAGING_AWS_ACCESS_KEY_ID=AKI...
STAGING_AWS_SECRET_ACCESS_KEY=xxx...
STAGING_AWS_REGION=ap-northeast-1

# Production環境用  
PRODUCTION_AWS_ACCESS_KEY_ID=AKI...
PRODUCTION_AWS_SECRET_ACCESS_KEY=xxx...
PRODUCTION_AWS_REGION=ap-northeast-1
```

#### **2. アプリケーション設定**
```bash
# OpenAI API
STAGING_OPENAI_API_KEY=sk-...
PRODUCTION_OPENAI_API_KEY=sk-...

# CrowdWorks認証情報
STAGING_CROWDWORKS_EMAIL=your-email@example.com
STAGING_CROWDWORKS_PASSWORD=your-password
PRODUCTION_CROWDWORKS_EMAIL=your-email@example.com
PRODUCTION_CROWDWORKS_PASSWORD=your-password

# 通知設定
STAGING_NOTIFICATION_EMAIL=alerts-staging@example.com
PRODUCTION_NOTIFICATION_EMAIL=alerts@example.com
```

#### **3. その他**
```bash
# Codecov (optional)
CODECOV_TOKEN=xxx...

# Slack通知 (optional)
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/...
```

### **シークレット設定手順**

1. **GitHubリポジトリのSettings** → **Secrets and variables** → **Actions**
2. **New repository secret** をクリック
3. 上記のシークレット名と値を設定

## **🐳 Dockerビルド設定**

### **Dockerfile最適化（Lambda Container用）**
```dockerfile
# Multi-stage buildでサイズ最適化
FROM node:18-alpine as base
# Playwright環境
FROM mcr.microsoft.com/playwright/python:v1.45.0-jammy as runtime

# Lambda Runtime Interface Client
COPY --from=base /workspace /function
WORKDIR /function

# エントリポイント設定（Lambda用）
ENTRYPOINT [ "npx", "aws-lambda-ric" ]
CMD [ "dist/lambda/handler.lambdaHandler" ]
```

### **ビルド戦略**
```yaml
strategy:
  matrix:
    architecture: [amd64]  # Lambda = x86_64のみ
  build-args:
    - NODE_ENV=production
    - BUILD_TARGET=lambda
  cache-from:
    - type=gha  # GitHub Actions Cache
  cache-to:
    - type=gha,mode=max
```

## **📊 CI/CDパフォーマンス最適化**

### **並行実行最適化**
```yaml
Job実行時間:
  Code Quality: ~2分
  Unit Tests: ~3分  
  Build Test: ~2分
  Security Scan: ~5分
  CDK Synth: ~1分
  Docker Build: ~8分
  Total: ~12分（並行実行）
```

### **キャッシュ戦略**
```yaml
node_modules: 
  key: v1-deps-{{ hashFiles('package-lock.json') }}
Docker layers:
  cache-from: type=gha
  cache-to: type=gha,mode=max
AWS CDK:
  cache: ~/.cdk
```

## ワークフロー実行条件

### **自動実行**
- **Push to main**: フルパイプライン + Production デプロイ
- **Push to develop**: フルパイプライン + Staging デプロイ  
- **Pull Request**: コード品質 + テスト（デプロイなし）

### **手動実行**
- **workflow_dispatch**: 任意ブランチでの手動実行
- **引数指定可能**: 環境選択、デプロイスキップなど

## 品質ゲート

### **自動品質チェック**
```yaml
必須チェック:
  - ESLint: Error 0件
  - TypeScript: コンパイルエラー 0件
  - Unit Tests: 80%以上のカバレッジ
  - Security: 高・中脆弱性 0件
  - CDK Synth: 構文エラー 0件
  - Docker Build: ビルド成功
```

### **デプロイ前チェック**
```yaml
Staging デプロイ前:
  - 全品質ゲート通過
  - develop ブランチからのプッシュ

Production デプロイ前:
  - 全品質ゲート通過  
  - main ブランチからのプッシュ
  - 手動承認（GitHub Environment Protection）
```

## **🔍 監視・アラート**

### **パイプライン監視**
```yaml
成功率監視:
  target: 95%以上
  alert: Slack通知

実行時間監視:
  target: 15分以内
  alert: 20分超過でアラート

デプロイ頻度:
  staging: 日次
  production: 週次
```

### **コスト監視**
```yaml
GitHub Actions使用量:
  無料枠: 2,000分/月
  現在使用量: ~500分/月
  アラート閾値: 1,800分/月
```

## トラブルシューティング

### **よくある問題と解決策**

#### **1. Docker Build失敗**
```bash
# 原因: Dockerfile構文エラー、依存関係問題
# 解決: ローカルでDockerビルドテスト
docker build -t test-image .
docker run --rm test-image npm test
```

#### **2. CDK Synth失敗**
```bash
# 原因: CDK構文エラー、型定義問題
# 解決: ローカルでCDK確認
npm run cdk:synth
npm run type-check
```

#### **3. Lambda Container起動失敗**
```bash
# 原因: エントリポイント設定、権限問題
# 解決: ローカルLambda環境テスト
docker run -p 9000:8080 \
  --entrypoint /usr/local/bin/npx \
  test-image aws-lambda-ric dist/lambda/handler.lambdaHandler
```

#### **4. AWS認証失敗**
```bash
# 原因: シークレット設定不備、権限不足
# 解決: GitHubシークレット確認、IAMポリシー確認
aws sts get-caller-identity  # 認証確認
aws lambda list-functions   # 権限確認
```

### **ログ確認方法**
```bash
# GitHub Actions ログ
# リポジトリ → Actions → 該当ワークフロー → ログ詳細

# AWS CloudWatch ログ（デプロイ後）
aws logs tail /aws/lambda/crowdworks-searcher-main --follow

# CDK デプロイログ
aws cloudformation describe-stack-events \
  --stack-name CrowdWorksSearcherStack
```

## セキュリティ設定

### **OIDC認証（推奨）**
```yaml
# シークレットキーの代わりにOIDC使用
permissions:
  id-token: write
  contents: read

- name: Configure AWS credentials
  uses: aws-actions/configure-aws-credentials@v4
  with:
    role-to-assume: arn:aws:iam::123456789012:role/GitHubActionsRole
    aws-region: ap-northeast-1
```

### **権限最小化**
```yaml
IAMポリシー（最小権限）:
  - lambda:UpdateFunctionCode
  - lambda:UpdateFunctionConfiguration
  - ecr:GetAuthorizationToken
  - ecr:BatchCheckLayerAvailability
  - ecr:GetDownloadUrlForLayer
  - ecr:BatchGetImage
  - ecr:PutImage
```

## パフォーマンス最適化

### **ビルド時間短縮**
```yaml
最適化施策:
  1. Node.js依存関係キャッシュ
  2. Dockerレイヤーキャッシュ
  3. 並行ジョブ実行
  4. 不要ステップのスキップ

結果:
  従来: 25分 → 現在: 12分（52%短縮）
```

### **リソース効率化**
```yaml
GitHub Actions Runner:
  Type: ubuntu-latest
  Concurrent jobs: 最大4つ
  Matrix strategy: アーキテクチャ別
```

## 次のステップ

### **1. CI/CD改善計画**
- [ ] **マルチアーキテクチャ対応**（ARM64 Lambda対応時）
- [ ] **Blue-Green デプロイ**（ダウンタイムゼロ）
- [ ] **カナリアデプロイ**（段階的ロールアウト）
- [ ] **自動ロールバック**（エラー検知時）

### **2. 監視強化**
- [ ] **SRE指標追加**（MTTR、MTBF等）
- [ ] **コスト最適化自動化**
- [ ] **パフォーマンス回帰テスト**

---

**📞 サポート**: CI/CDパイプラインで問題が発生した場合は、[GitHub Issues](https://github.com/masayuki-akinari/crowdworks-search/issues) でお知らせください。
</file>

<file path="jest.config.js">
module.exports = {
    // テスト環境
    preset: 'ts-jest',
    testEnvironment: 'node',

    // TypeScript設定
    transform: {
        '^.+\\.tsx?$': ['ts-jest', {
            tsconfig: './tsconfig.json'
        }]
    },

    // ファイル拡張子の設定
    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json'],

    // パスマッピング（tsconfig.jsonと同期）
    moduleNameMapper: {
        '^@/(.*)$': '<rootDir>/src/$1',
        '^@/types/(.*)$': '<rootDir>/src/types/$1',
        '^@/services/(.*)$': '<rootDir>/src/services/$1',
        '^@/utils/(.*)$': '<rootDir>/src/utils/$1',
        '^@/infrastructure/(.*)$': '<rootDir>/src/infrastructure/$1'
    },

    // テストファイルのパターン
    testMatch: [
        '<rootDir>/src/**/*.test.(ts|tsx)',
        '<rootDir>/src/**/*.spec.(ts|tsx)',
        '<rootDir>/test/**/*.test.(ts|tsx)',
        '<rootDir>/test/**/*.spec.(ts|tsx)'
    ],

    // カバレッジ設定
    collectCoverage: false, // デフォルトでは無効（npm run test:coverageで有効）
    collectCoverageFrom: [
        'src/**/*.{ts,tsx}',
        '!src/**/*.d.ts',
        '!src/**/*.test.{ts,tsx}',
        '!src/**/*.spec.{ts,tsx}',
        '!src/test/**/*',
        '!src/types/**/*', // 型定義はカバレッジから除外
    ],
    coverageDirectory: 'coverage',
    coverageReporters: ['text', 'lcov', 'html'],
    // TODO: アプリケーション実装後にカバレッジ要件を復活
    // coverageThreshold: {
    //     global: {
    //         branches: 20,   // 75% → 20% に一時的に緩和
    //         functions: 20,  // 80% → 20% に一時的に緩和
    //         lines: 20,      // 80% → 20% に一時的に緩和
    //         statements: 20  // 80% → 20% に一時的に緩和
    //     }
    // },

    // セットアップファイル
    setupFilesAfterEnv: ['<rootDir>/test/setup.ts'],

    // モック設定
    clearMocks: true,
    resetMocks: true,
    restoreMocks: true,

    // タイムアウト設定
    testTimeout: 30000, // 30秒（AWS SDK呼び出しなど時間がかかる場合に対応）

    // 並列実行設定
    maxWorkers: '50%', // CPUコア数の50%で並列実行

    // エラー表示設定
    verbose: true,
    errorOnDeprecated: true,

    // 不要なログを抑制
    silent: false,

    // テスト実行前後のフック
    globalSetup: undefined,
    globalTeardown: undefined
};
</file>

<file path="src/index.ts">
/**
 * CrowdWorks Search System - Main Entry Point
 * Docker環境での開発用エントリーポイント
 */

import { ExecutionLog } from '@/types';

// 環境変数の検証
function validateEnvironment(): void {
  const required = ['NODE_ENV', 'AWS_REGION'];
  const missing = required.filter(key => !process.env[key]);

  if (missing.length > 0) {
    throw new Error(`Missing required environment variables: ${missing.join(', ')}`);
  }
}

// メイン実行関数
async function main(): Promise<void> {
  try {
    validateEnvironment();

    const log: ExecutionLog = {
      executionId: Date.now().toString(),
      timestamp: new Date().toISOString(),
      status: 'success',
      duration: 0,
      jobsScraped: 0,
      newJobs: 0,
      aiEvaluated: 0,
      highScoreJobs: 0,
      costEstimate: 0,
    };

    console.log('🚀 CrowdWorks Search System - Development Mode');
    console.log(`Environment: ${process.env['NODE_ENV']}`);
    console.log(`AWS Region: ${process.env['AWS_REGION']}`);
    console.log(`Execution ID: ${log.executionId}`);

    // TODO: 実際の処理を実装
    console.log('✅ Development setup completed');
  } catch (error) {
    console.error('❌ Failed to start application:', error);
    process.exit(1);
  }
}

// 開発環境でのみ実行
if (require.main === module) {
  main().catch(error => {
    console.error('Fatal error:', error);
    process.exit(1);
  });
}

export { main };
</file>

<file path="src/infrastructure/crowdworks-searcher-stack.ts">
import * as cdk from 'aws-cdk-lib';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as events from 'aws-cdk-lib/aws-events';
import * as targets from 'aws-cdk-lib/aws-events-targets';
import * as iam from 'aws-cdk-lib/aws-iam';
import * as logs from 'aws-cdk-lib/aws-logs';
import { Construct } from 'constructs';

export interface CrowdWorksSearcherStackProps extends cdk.StackProps {
  readonly stage?: string;
  readonly useContainerImage?: boolean; // Container Image使用フラグ
}

export class CrowdWorksSearcherStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: CrowdWorksSearcherStackProps) {
    super(scope, id, props);

    const stage = props?.stage || this.node.tryGetContext('stage') || 'dev';
    const isProd = stage === 'production';
    const useContainerImage = props?.useContainerImage ?? true; // デフォルトでContainer使用

    // リソース名のプレフィックス
    const resourcePrefix = `crowdworks-searcher-${stage}`;

    // S3バケット（データ保存用）
    const dataBucket = new s3.Bucket(this, 'CrowdWorksDataBucket', {
      bucketName: `${resourcePrefix}-data-${this.account}`,
      encryption: s3.BucketEncryption.S3_MANAGED,
      blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL,
      versioned: isProd, // 本番環境のみバージョニング有効
      lifecycleRules: [
        {
          id: 'DeleteOldData',
          enabled: true,
          expiration: isProd ? cdk.Duration.days(30) : cdk.Duration.days(7),
          // 本番環境では古いバージョンも管理
          ...(isProd && {
            noncurrentVersionExpiration: cdk.Duration.days(7),
          }),
        },
      ],
      removalPolicy: isProd ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY,
      autoDeleteObjects: !isProd, // 本番環境では手動削除が必要
    });

    // CloudWatch Logs グループ
    const logGroup = new logs.LogGroup(this, 'LambdaLogGroup', {
      logGroupName: `/aws/lambda/${resourcePrefix}-main`,
      retention: isProd ? logs.RetentionDays.ONE_MONTH : logs.RetentionDays.ONE_WEEK,
      removalPolicy: isProd ? cdk.RemovalPolicy.RETAIN : cdk.RemovalPolicy.DESTROY,
    });

    // Lambda実行ロール（Container Image用権限追加）
    const lambdaRole = new iam.Role(this, 'LambdaExecutionRole', {
      roleName: `${resourcePrefix}-lambda-role`,
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'),
      ],
      inlinePolicies: {
        S3Access: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: ['s3:GetObject', 's3:PutObject', 's3:ListBucket', 's3:DeleteObject'],
              resources: [dataBucket.bucketArn, `${dataBucket.bucketArn}/*`],
            }),
          ],
        }),
        LogsAccess: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: ['logs:CreateLogStream', 'logs:PutLogEvents'],
              resources: [logGroup.logGroupArn],
            }),
          ],
        }),
        // Parameter Store (シークレット管理用)
        ParameterStoreAccess: new iam.PolicyDocument({
          statements: [
            new iam.PolicyStatement({
              effect: iam.Effect.ALLOW,
              actions: ['ssm:GetParameter', 'ssm:GetParameters'],
              resources: [`arn:aws:ssm:${this.region}:${this.account}:parameter/crowdworks-search/*`],
            }),
          ],
        }),
      },
    });

    // Lambda関数（Container Image対応）
    const mainFunction = useContainerImage
      ? new lambda.DockerImageFunction(this, 'CrowdWorksMainFunction', {
        functionName: `${resourcePrefix}-main`,
        code: lambda.DockerImageCode.fromImageAsset('./', {
          // Lambda Container用のDockerfileを指定
          file: 'Dockerfile.lambda',
          // ビルド引数でステージを渡す
          buildArgs: {
            STAGE: stage,
            NODE_ENV: isProd ? 'production' : 'development',
          },
        }),
        timeout: cdk.Duration.minutes(15), // Playwright用に15分
        memorySize: isProd ? 3008 : 2048,  // Playwright用メモリ
        role: lambdaRole,
        logGroup: logGroup,
        architecture: lambda.Architecture.X86_64, // Playwrightはx86_64のみサポート
        environment: {
          NODE_ENV: stage,
          STAGE: stage,
          DATA_BUCKET_NAME: dataBucket.bucketName,
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1',
          // Playwright環境変数
          PLAYWRIGHT_BROWSERS_PATH: '/usr/bin',
          PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: '1',
          LOG_LEVEL: isProd ? 'info' : 'debug',
        },
        // 本番環境では予約済み同時実行数を設定
        ...(isProd && {
          reservedConcurrentExecutions: 5,
        }),
      })
      : new lambda.Function(this, 'CrowdWorksMainFunction', {
        functionName: `${resourcePrefix}-main`,
        runtime: lambda.Runtime.NODEJS_18_X,
        handler: 'lambda/handler.lambdaHandler',
        code: lambda.Code.fromAsset('./dist'),
        timeout: cdk.Duration.minutes(isProd ? 15 : 10),
        memorySize: isProd ? 1536 : 1024,
        role: lambdaRole,
        logGroup: logGroup,
        environment: {
          NODE_ENV: stage,
          STAGE: stage,
          DATA_BUCKET_NAME: dataBucket.bucketName,
          AWS_NODEJS_CONNECTION_REUSE_ENABLED: '1',
        },
        // 本番環境では予約済み同時実行数を設定
        ...(isProd && {
          reservedConcurrentExecutions: 5,
        }),
      });

    // EventBridge（スケジューラー）
    const scheduleRule = new events.Rule(this, 'ScheduleRule', {
      ruleName: `${resourcePrefix}-schedule`,
      // 本番環境では15分間隔、その他は30分間隔
      schedule: events.Schedule.rate(isProd ? cdk.Duration.minutes(15) : cdk.Duration.minutes(30)),
      description: `CrowdWorks案件検索の定期実行 (${stage}環境)`,
      enabled: stage !== 'test', // テスト環境では無効
    });

    scheduleRule.addTarget(new targets.LambdaFunction(mainFunction));

    // タグ付け
    cdk.Tags.of(this).add('Project', 'CrowdWorksSearcher');
    cdk.Tags.of(this).add('Stage', stage);
    cdk.Tags.of(this).add('Environment', isProd ? 'production' : 'development');

    // 出力
    new cdk.CfnOutput(this, 'DataBucketName', {
      value: dataBucket.bucketName,
      description: 'S3データバケット名',
      exportName: `${resourcePrefix}-data-bucket-name`,
    });

    new cdk.CfnOutput(this, 'LambdaFunctionName', {
      value: mainFunction.functionName,
      description: 'Lambda関数名',
      exportName: `${resourcePrefix}-lambda-function-name`,
    });

    new cdk.CfnOutput(this, 'LambdaFunctionArn', {
      value: mainFunction.functionArn,
      description: 'Lambda関数ARN',
      exportName: `${resourcePrefix}-lambda-function-arn`,
    });

    new cdk.CfnOutput(this, 'Stage', {
      value: stage,
      description: 'デプロイメントステージ',
      exportName: `${resourcePrefix}-stage`,
    });

    // 出力（Container Image情報追加）
    new cdk.CfnOutput(this, 'DeploymentMethod', {
      value: useContainerImage ? 'Container Image' : 'ZIP Package',
      description: 'Lambda関数のデプロイ方式',
      exportName: `${resourcePrefix}-deployment-method`,
    });
  }
}
</file>

<file path="src/types/index.ts">
// 案件データ型（軽量版）
export interface JobData {
  id: string; // 案件ID（ユニーク）
  title: string; // 案件タイトル
  description: string; // 案件詳細（最大500文字）
  url: string; // 案件URL
  budget: number; // 予算（円）
  deadline: Date; // 納期
  workType: 'fixed' | 'hourly'; // 固定報酬 or 時間単価
  category: string; // カテゴリ
  clientName: string; // クライアント名
  clientRating: number; // クライアント評価（1-5）
  clientReviews: number; // レビュー数
  skills: string[]; // 必要スキル（最大5個）
  experience: 'beginner' | 'intermediate' | 'expert'; // 経験レベル
  scrapedAt: Date; // 取得日時
  source: 'crowdworks'; // 取得元（将来拡張用）
}

// 評価結果型（軽量版）
export interface JobEvaluation {
  jobId: string; // 対象案件ID
  evaluatedAt: Date; // 評価日時
  score: number; // おすすめ度（1-10）
  reason: string; // 評価理由（最大50文字）
  aiModel: 'gpt-3.5-turbo'; // 使用AIモデル
  tokenUsed: number; // 使用トークン数
  costEstimate: number; // 推定コスト（USD）
  strengths: string[]; // 強み（最大3個）
  concerns: string[]; // 懸念点（最大3個）
}

// 実行ログ型
export interface ExecutionLog {
  executionId: string; // 実行ID（タイムスタンプベース）
  timestamp: string; // 実行開始時刻（ISO形式）
  status: 'success' | 'error' | 'partial'; // 実行ステータス
  duration: number; // 実行時間（ミリ秒）
  jobsScraped: number; // スクレイピング件数
  newJobs: number; // 新規案件数
  aiEvaluated: number; // AI評価件数
  highScoreJobs: number; // 高評価案件数（閾値以上）
  costEstimate: number; // 推定コスト（USD）
  error?: {
    type: string; // エラータイプ
    message: string; // エラーメッセージ
    stack?: string; // スタックトレース
  };
}

// システム設定型
export interface SystemConfig {
  scraping: {
    maxJobsPerExecution: number;
    preFilterEnabled: boolean;
    minBudget: number;
    minClientRating: number;
    maxDescriptionLength: number;
  };
  ai: {
    enabled: boolean;
    model: 'gpt-3.5-turbo';
    maxJobsForEvaluation: number;
    monthlyBudgetLimit: number;
    maxTokensPerRequest: number;
    temperature: number;
  };
  notification: {
    enabled: boolean;
    scoreThreshold: number;
    errorNotificationEnabled: boolean;
    dailySummaryEnabled: boolean;
  };
  storage: {
    retentionDays: number;
    compressionEnabled: boolean;
    backupEnabled: boolean;
  };
  performance: {
    timeoutSeconds: number;
    retryCount: number;
    concurrentLimit: number;
  };
}

// 検索条件型
export interface SearchCondition {
  id: string;
  name: string;
  enabled: boolean;
  keywords: string[];
  budgetMin: number;
  budgetMax: number;
  category: string;
  workType: 'fixed' | 'hourly' | 'both';
  clientRatingMin: number;
  experienceLevel: 'beginner' | 'intermediate' | 'expert' | 'any';
  excludeKeywords: string[];
  excludeClients: string[];
}

// 検索条件設定型
export interface SearchConditions {
  version: string;
  lastUpdated: Date;
  conditions: SearchCondition[];
}

// ログイン認証情報型
export interface LoginCredentials {
  email: string;
  password: string;
}

// Lambda イベント型
export interface ScheduledExecutionEvent {
  source: string;
  'detail-type': string;
  detail: Record<string, any>;
  time?: string; // ISO形式（オプション）
}

// Lambda レスポンス型（新形式）
export interface ScheduledExecutionResponse {
  statusCode: number; // HTTP レスポンスコード
  body: string; // JSON文字列レスポンス
  executionTime: number; // 実行時間（ミリ秒）
  timestamp: string; // ISO形式タイムスタンプ
}

// Playwright動作確認結果型
export interface PlaywrightTestResult {
  success: boolean;
  chromiumVersion?: string;
  title?: string;
  screenshot?: boolean;
  error?: string;
  executionTime: number;
}

// Lambda実行結果型（新形式）
export interface LambdaExecutionResult {
  phases: {
    playwright: PlaywrightTestResult;
    crowdworksLogin: {
      success: boolean;
      loginResult?: CrowdWorksLoginResult;
      error?: string;
      executionTime: number;
    };
    crowdworksScraping: {
      success: boolean;
      scrapingResult?: any; // 実装時に詳細型を追加
      error?: string;
      executionTime: number;
    };
  };
  executionTime: number;
  timestamp: string;
}

// Lambda エラーレスポンス型
export interface LambdaErrorResponse {
  message: string;
  error: string;
  requestId: string;
  timestamp: string;
}

// 旧形式レスポンス型（後方互換性維持）
export interface LegacyScheduledExecutionResponse {
  status: 'success' | 'error' | 'partial';
  executionId: string;
  timestamp: string;
  results: {
    jobsScraped: number;
    newJobs: number;
    aiEvaluated: number;
    highScoreJobs: number;
    duration: number;
    costEstimate: number;
  };
  error?: {
    type: string;
    message: string;
  };
}

// エラー型
export enum ErrorType {
  AUTHENTICATION_ERROR = 'AUTH_ERROR',
  LAMBDA_TIMEOUT = 'LAMBDA_TIMEOUT',
  S3_ACCESS_ERROR = 'S3_ACCESS_ERROR',
  SCRAPING_ERROR = 'SCRAPING_ERROR',
  AI_API_ERROR = 'AI_API_ERROR',
  NETWORK_ERROR = 'NETWORK_ERROR',
}

export class AppError extends Error {
  constructor(
    public type: ErrorType,
    message: string,
    public retryable: boolean = false
  ) {
    super(message);
    this.name = 'AppError';
  }
}

// CrowdWorks認証情報
export interface CrowdWorksCredentials {
  email: string;
  password: string;
}

// CrowdWorksログイン結果
export interface CrowdWorksLoginResult {
  success: boolean;
  isLoggedIn: boolean;
  error?: string;
  executionTime: number;
}
</file>

<file path=".eslintrc.js">
module.exports = {
    parser: '@typescript-eslint/parser',
    parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
    },
    env: {
        node: true,
        es2022: true
    },
    plugins: [
        '@typescript-eslint'
    ],
    extends: [
        'eslint:recommended'
    ],
    rules: {
        // any型を厳格に禁止
        '@typescript-eslint/no-explicit-any': 'error',
        '@typescript-eslint/no-unused-vars': ['error', {
            argsIgnorePattern: '^_',
            varsIgnorePattern: '^_'
        }],

        // General rules
        'no-console': 'off', // 開発中は許可
        'no-debugger': 'error',
        'prefer-const': 'error',
        'no-var': 'error'
    },
    ignorePatterns: [
        'dist/',
        'node_modules/',
        'cdk.out/',
        '*.js',
        '*.d.ts'
    ]
};
</file>

<file path="Dockerfile">
# ベースイメージ
FROM node:18-alpine as base

# 必要なシステムパッケージのインストール
RUN apk add --no-cache \
    git \
    python3 \
    make \
    g++ \
    chromium \
    && rm -rf /var/cache/apk/*

# 作業ディレクトリの設定
WORKDIR /app

# package.jsonとpackage-lock.jsonをコピー（依存関係キャッシュ用）
COPY package*.json ./

# === 依存関係インストールステージ ===
FROM base as dependencies

# 全ての依存関係をインストール
RUN npm ci

# === ビルドステージ ===
FROM dependencies as build

# ソースコードをコピー
COPY . .

# TypeScriptのビルド
RUN npm run build

# 不要なdevDependenciesを削除
RUN npm prune --production

# === テスト用ステージ ===
FROM dependencies as test

# ソースコードをコピー
COPY . .

# TypeScriptのビルド（テスト用）
RUN npm run build

# Playwrightの設定
ENV PLAYWRIGHT_BROWSERS_PATH=/usr/bin/chromium-browser
ENV PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD=1

# テスト実行
CMD ["npm", "run", "test:coverage"]

# === 開発用ステージ ===
FROM dependencies as development

# ソースコードをコピー
COPY . .

# 開発用のポート公開
EXPOSE 3000 9229

# 開発用のデフォルトコマンド
CMD ["npm", "run", "dev"]

# === 本番用ステージ ===
FROM node:18-alpine as production

# 作業ディレクトリの設定
WORKDIR /app

# 本番用の最小限のパッケージのみインストール
RUN apk add --no-cache dumb-init

# 非rootユーザーの作成
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nextjs -u 1001

# ビルド成果物と本番用依存関係をコピー
COPY --from=build --chown=nextjs:nodejs /app/dist ./dist
COPY --from=build --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=build --chown=nextjs:nodejs /app/package.json ./package.json

# 非rootユーザーに切り替え
USER nextjs

# ヘルスチェック追加
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD node --version || exit 1

# 本番用のデフォルトコマンド
CMD ["dumb-init", "node", "dist/index.js"]
</file>

<file path="docs/05_implementation_plan.md">
# CrowdWorks自動化システム 実装計画書

## 📋 システム概要

### 目的
CrowdWorksの案件情報を自動的に収集・分析し、スクリーニングした結果をメールで通知するシステム

### アーキテクチャ
- **AWS Lambda**: スクレイピング実行（**コンテナイメージ版**）
- **Amazon EventBridge**: スケジュール実行
- **Amazon S3**: データ保存
- **Amazon SES**: メール通知
- **CDK**: Infrastructure as Code

## ⚠️ **最重要: Playwright Lambda制約の最終対応**

### **技術的課題の最終結論**
```yaml
現状分析:
  Lambda ZIP制限: 250MB
  Playwright + Chromium: ~300MB
  結論: ❌ ZIP版は物理的に不可能

最終対応方針:
  ✅ Lambda Container Image採用（確定）
  サイズ制限: 10GB（ZIP: 250MB → Container: 10GB）
  デプロイ方式: ECR + Docker
  月額コスト: $5-10（許容範囲内）
```

### **⚡ 最優先実装タスク（Phase 0）**

#### **1. Lambdaコンテナ環境の動作確認**
```bash
# 最優先事項（今すぐ実行）
priority: P0 - Critical
期限: 次回作業セッション内
目標: Playwright + Chromiumの動作実証
```

**具体的アクション:**
1. **現在のDockerfile修正**（Lambda Container用）
2. **CDKスタックの変更**（DockerImageFunction）
3. **ローカルテスト環境構築**
4. **AWS ECRデプロイテスト**
5. **Lambda実行確認**

#### **2. CDKスタック改修（Phase 0）**

**現在の問題:**
```typescript
// 現在: ZIP形式
new lambda.Function(this, 'CrowdWorksFunction', {
  runtime: lambda.Runtime.NODEJS_18_X,
  code: lambda.Code.fromAsset('./dist'),  // ❌ サイズ超過
  // ...
});
```

**修正方針:**
```typescript
// 修正後: Container形式
new lambda.DockerImageFunction(this, 'CrowdWorksFunction', {
  code: lambda.DockerImageCode.fromImageAsset('./'),  // ✅ 10GBまで対応
  memorySize: 3008,  // Playwright用メモリ
  timeout: Duration.minutes(15),
  architecture: lambda.Architecture.X86_64,
  environment: {
    // 環境変数設定
  }
});
```

## 🎯 **フェーズ別実装ロードマップ**

### **Phase 0: 基盤動作確認（最優先）**
```yaml
期間: 1-2日
目標: Playwrightの動作実証
ブロッカー解除: デプロイ基盤確立
```

**必須タスク:**
- [ ] **CDKスタック修正**（Lambda → DockerImageFunction）
- [ ] **Dockerfile最適化**（Lambda Container用）
- [ ] **ECRリポジトリ設定**
- [ ] **ローカルテスト環境**（Lambda Runtime Interface Emulator）
- [ ] **基本動作確認**（Chromium起動テスト）
- [ ] **AWS デプロイテスト**

### **Phase 1: コアスクレイピング実装**
```yaml
期間: 3-5日  
前提: Phase 0完了
目標: CrowdWorks案件取得
```

**実装内容:**
- [ ] **CrowdWorksログイン機能**
- [ ] **案件検索・リスト取得**
- [ ] **案件詳細データ抽出**
- [ ] **エラーハンドリング強化**
- [ ] **データ正規化処理**

### **Phase 2: AI評価・通知機能**
```yaml
期間: 2-3日
前提: Phase 1完了
目標: OpenAI連携・メール通知
```

**実装内容:**
- [ ] **OpenAI API連携**
- [ ] **案件品質評価ロジック**
- [ ] **評価結果フィルタリング**
- [ ] **SES/SNS メール通知**
- [ ] **通知テンプレート作成**

### **Phase 3: 運用最適化**
```yaml
期間: 2-3日
前提: Phase 2完了  
目標: 本番運用準備
```

**実装内容:**
- [ ] **S3データ保存・履歴管理**
- [ ] **監視・アラート設定**
- [ ] **コスト最適化**
- [ ] **パフォーマンスチューニング**
- [ ] **ドキュメント最終化**

## 🔧 **Phase 0詳細: 技術的実装ガイド**

### **1. Dockerfile修正（Lambda Container用）**

**現在の問題:**
```dockerfile
# 現在: 一般的なPlaywright環境
FROM mcr.microsoft.com/playwright/python:v1.45.0-jammy
# → Lambda Containerとして不完全
```

**修正方針:**
```dockerfile
# Lambda Container対応版
FROM public.ecr.aws/lambda/nodejs:18

# Playwright + Chromium インストール
RUN yum update -y && \
    yum install -y \
    chromium \
    nss \
    freetype \
    freetype-devel \
    harfbuzz \
    ca-certificates \
    ttf-liberation

# Node.js アプリケーション
COPY package*.json ./
RUN npm ci --omit=dev

COPY dist/ ./
COPY node_modules/ ./node_modules/

# Lambda エントリポイント
CMD ["lambda/handler.lambdaHandler"]
```

### **2. CDKスタック修正（infrastructure/）**

**ファイル:** `src/infrastructure/lambda-stack.ts`

```typescript
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as cdk from 'aws-cdk-lib';

export class CrowdWorksLambdaStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    // ❌ 削除: 従来のZIP版Lambda
    // const crowdWorksFunction = new lambda.Function(...)

    // ✅ 追加: Container版Lambda
    const crowdWorksFunction = new lambda.DockerImageFunction(this, 'CrowdWorksFunction', {
      code: lambda.DockerImageCode.fromImageAsset('./'),
      memorySize: 3008,
      timeout: cdk.Duration.minutes(15),
      architecture: lambda.Architecture.X86_64,
      environment: {
        NODE_ENV: 'production',
        LOG_LEVEL: 'info',
        PLAYWRIGHT_CHROMIUM_EXECUTABLE_PATH: '/usr/bin/chromium-browser'
      },
      deadLetterQueue: dlq,  // DLQ設定
      retryAttempts: 2,
      logRetention: logs.RetentionDays.TWO_WEEKS
    });
  }
}
```

### **3. ローカルテスト環境（Phase 0検証用）**

**Lambda Runtime Interface Emulator使用:**
```bash
# 1. Dockerイメージビルド
docker build -t crowdworks-lambda .

# 2. Lambda Runtime Interface Emulator起動
docker run -p 9000:8080 \
  -e AWS_LAMBDA_FUNCTION_NAME=crowdworks-searcher \
  crowdworks-lambda

# 3. ローカルテスト実行
curl -XPOST "http://localhost:9000/2015-03-31/functions/function/invocations" \
  -d '{"source":"test","detail":{}}'
```

### **4. 基本動作確認スクリプト**

**ファイル:** `src/lambda/test-playwright.ts`
```typescript
import { chromium } from 'playwright';

export async function testPlaywright() {
  let browser;
  
  try {
    console.log('🚀 Playwright起動テスト開始...');
    
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process'
      ]
    });

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    });
    
    const page = await context.newPage();
    
    // 基本動作確認
    console.log('📄 Google アクセステスト...');
    await page.goto('https://www.google.com', { waitUntil: 'networkidle' });
    const title = await page.title();
    console.log(`✅ ページタイトル: ${title}`);
    
    // スクリーンショット取得（確認用）
    await page.screenshot({ path: '/tmp/test-screenshot.png' });
    console.log('📸 スクリーンショット保存完了');
    
    return {
      success: true,
      title,
      message: 'Playwright動作確認成功'
    };
    
  } catch (error) {
    console.error('❌ Playwright テスト失敗:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : '不明なエラー'
    };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}
```

### **5. CI/CD対応（GitHub Actions修正）**

**.github/workflows/ci.yml 修正点:**
```yaml
# Docker Build段階を修正
docker-build:
  name: Docker Build Test (Lambda Container)
  runs-on: ubuntu-latest
  steps:
    - name: Build Lambda Container
      run: |
        docker build -t crowdworks-lambda:test .
        
    - name: Test Lambda Container
      run: |
        # Lambda Runtime Interface Emulatorでテスト
        docker run --rm -d -p 9000:8080 --name lambda-test crowdworks-lambda:test
        sleep 10
        
        # 基本動作確認
        curl -XPOST "http://localhost:9000/2015-03-31/functions/function/invocations" \
          -d '{"source":"test","detail":{}}' || exit 1
        
        docker stop lambda-test
```

## 📊 **リスク評価と対策**

### **高リスク要素**
1. **Lambda Container初回デプロイ** → ローカル十分検証
2. **Chromium動作不安定性** → エラーハンドリング強化
3. **メモリ・タイムアウト調整** → 段階的チューニング

### **リスク軽減策**
```yaml
デプロイ戦略:
  1. ローカル環境での十分な検証
  2. Staging環境での段階テスト
  3. Production環境への段階ロールアウト

監視強化:
  - CloudWatch Logs詳細ログ
  - Lambda実行メトリクス監視
  - エラー率アラート設定
```

## 💰 **コスト見積もり（確定版）**

### **Lambda Container版 月額コスト**
```yaml
Lambda実行:
  実行回数: 96回/日 × 30日 = 2,880回/月
  実行時間: 平均30秒/回
  メモリ: 3,008MB
  料金: ~$4-6/月

ECRストレージ:
  Dockerイメージ: ~1GB
  料金: $0.10/月

CloudWatch:
  ログ保存: ~$1-2/月
  
OpenAI API:
  GPT-4呼び出し: ~$2-3/月

合計: $7-11/月（目標$5を若干上回るが許容範囲）
```

## 🎯 **成功指標（Phase 0）**

### **必達目標**
1. ✅ **Chromium起動成功**: ローカル・AWS両環境
2. ✅ **基本ページアクセス**: Google等の簡単なサイト
3. ✅ **Lambda実行成功**: 15分タイムアウト内
4. ✅ **ログ出力確認**: CloudWatch Logsで詳細確認可能

### **品質目標**
- **起動時間**: 30秒以内
- **成功率**: 95%以上（10回テスト中9回成功）
- **メモリ使用量**: 2GB以下
- **ログレベル**: 十分なデバッグ情報

## 📞 **次のアクション（即時実行推奨）**

### **今すぐ実行すべきタスク**
1. **CDKスタック修正** → `DockerImageFunction`への変更
2. **Dockerfile修正** → Lambda Container用に最適化
3. **ローカル検証環境構築** → 動作確認の前提条件
4. **基本テストスクリプト作成** → 動作確認自動化

### **成功後の次ステップ**
- Phase 1へ進行（CrowdWorksスクレイピング実装）
- 運用監視設定
- パフォーマンスチューニング

---

**📌 最重要**: Phase 0の基盤確立なしには以降の実装が不可能です。**Playwright Lambda Container動作確認を最優先で実行してください。**
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
        "target": "ES2022",
        "module": "commonjs",
        "lib": [
            "ES2022"
        ],
        "types": [
            "node"
        ],
        "rootDir": "./src",
        "outDir": "./dist",
        "removeComments": true,
        "declaration": true,
        "declarationMap": true,
        "sourceMap": true,
        "strict": true,
        "noImplicitAny": true,
        "strictNullChecks": true,
        "strictFunctionTypes": true,
        "strictBindCallApply": true,
        "strictPropertyInitialization": true,
        "noImplicitReturns": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedIndexedAccess": true,
        "noImplicitOverride": true,
        "exactOptionalPropertyTypes": true,
        "noPropertyAccessFromIndexSignature": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "allowUnreachableCode": false,
        "allowUnusedLabels": false,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "forceConsistentCasingInFileNames": true,
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "skipLibCheck": true,
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true,
        "baseUrl": "./",
        "paths": {
            "@/*": [
                "src/*"
            ],
            "@/types/*": [
                "src/types/*"
            ],
            "@/services/*": [
                "src/services/*"
            ],
            "@/utils/*": [
                "src/utils/*"
            ],
            "@/infrastructure/*": [
                "src/infrastructure/*"
            ]
        }
    },
    "include": [
        "src/**/*"
    ],
    "exclude": [
        "node_modules",
        "dist",
        "cdk.out",
        "test",
        "**/*.test.ts",
        "**/*.spec.ts",
        "*.js"
    ],
    "ts-node": {
        "require": [
            "tsconfig-paths/register"
        ],
        "compilerOptions": {
            "module": "commonjs"
        }
    }
}
</file>

<file path=".github/workflows/ci.yml">
name: CI/CD Pipeline

# GitHub Actionsの権限設定
permissions:
  contents: read
  security-events: write
  id-token: write # OIDC認証用

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch: # 手動実行を許可
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production

env:
  NODE_VERSION: '18'
  AWS_REGION: 'ap-northeast-1'

jobs:
  # コード品質チェック（最速実行）
  code-quality:
    name: Code Quality Check
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Lint check
        run: npm run lint

      - name: Format check
        run: npm run format:check

      - name: TypeScript type check
        run: npm run type-check

  # 単体テスト
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: code-quality
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:coverage

      - name: Upload coverage reports
        uses: codecov/codecov-action@v4
        if: always()
        with:
          file: ./coverage/lcov.info
          flags: unittests
          name: codecov-umbrella
          token: ${{ secrets.CODECOV_TOKEN }}

  # ビルドテスト
  build-test:
    name: Build Test
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: code-quality
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build TypeScript
        run: npm run build

      - name: Verify build output
        run: |
          echo "=== Checking build output ==="
          if [ ! -d "dist" ]; then
            echo "❌ Build failed: dist directory not found"
            exit 1
          fi
          
          # メインファイルの存在確認
          main_files=("dist/index.js" "dist/lambda/handler.js")
          for file in "${main_files[@]}"; do
            if [ -f "$file" ]; then
              echo "✅ Found: $file"
            else
              echo "⚠️  Not found: $file"
            fi
          done
          
          echo "Contents of dist directory:"
          find dist -name "*.js" -type f | head -10
          echo "✅ Build verification completed"

      - name: Archive build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: dist/
          retention-days: 7

  # CDK構文チェック
  cdk-synth:
    name: CDK Synth Check
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: build-test
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: CDK Synth (dry-run)
        run: npm run cdk:synth
        env:
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}

  # セキュリティスキャン
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: code-quality
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run npm audit
        run: npm audit --audit-level=moderate
        continue-on-error: true

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: typescript

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3

  # Docker Build Test
  docker-build:
    name: Docker Build Test
    runs-on: ubuntu-latest
    timeout-minutes: 20
    needs: build-test
    if: github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Build Docker image
        run: |
          docker build -t crowdworks-searcher:test .
          echo "✅ Docker build completed successfully"

      - name: Test Docker container
        run: |
          docker run --rm crowdworks-searcher:test node --version
          echo "✅ Docker container test passed"

  # Staging デプロイ（developブランチ）
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [unit-tests, build-test, cdk-synth, docker-build]
    if: github.ref == 'refs/heads/develop' && github.event_name == 'push'
    environment:
      name: staging
      url: https://staging.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (Staging)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.STAGING_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Staging

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to Staging with CDK
        run: |
          npm run cdk:deploy:staging
        env:
          STAGE: staging
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

      - name: Post-deployment verification
        run: |
          echo "Verifying staging deployment..."
          # Lambda関数の存在確認
          aws lambda get-function --function-name crowdworks-searcher-staging-main
          echo "✅ Staging deployment verified"

      - name: Slack notification (Staging)
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # Production デプロイ（mainブランチ）
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 45
    needs: [unit-tests, build-test, cdk-synth, docker-build]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: https://production.example.com
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (Production)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.PRODUCTION_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Production

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: dist/

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy to Production with CDK
        run: |
          npm run cdk:deploy:production
        env:
          STAGE: production
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

      - name: Post-deployment verification
        run: |
          echo "Verifying production deployment..."
          # Lambda関数の存在確認
          aws lambda get-function --function-name crowdworks-searcher-production-main
          # CloudWatch Logs確認
          aws logs describe-log-groups --log-group-name-prefix "/aws/lambda/crowdworks-searcher-production"
          echo "✅ Production deployment verified"

      - name: Create deployment tag
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git tag -a "v$(date +%Y%m%d_%H%M%S)" -m "Production deployment $(date)"
          git push origin --tags

      - name: Slack notification (Production)
        if: always()
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          channel: '#deployments'
          fields: repo,message,commit,author,action,eventName,ref,workflow
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # 手動デプロイ（workflow_dispatch）
  deploy-manual:
    name: Manual Deploy
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: github.event_name == 'workflow_dispatch'
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ github.event.inputs.environment == 'production' && secrets.PRODUCTION_AWS_ROLE_ARN || secrets.STAGING_AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: GitHubActions-Manual

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Deploy with CDK
        run: |
          if [ "${{ github.event.inputs.environment }}" = "production" ]; then
            npm run cdk:deploy:production
          else
            npm run cdk:deploy:staging
          fi
        env:
          STAGE: ${{ github.event.inputs.environment }}
          CDK_DEFAULT_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}

  # 通知（失敗時のみ）
  notify-failure:
    name: Notify Failure
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-test, cdk-synth, security-scan]
    if: failure()
    
    steps:
      - name: Notify failure
        run: |
          echo "❌ CI/CD Pipeline failed"
          echo "Workflow: ${{ github.workflow }}"
          echo "Branch: ${{ github.ref }}"
          echo "Commit: ${{ github.sha }}"
          echo "Actor: ${{ github.actor }}"
          echo "Event: ${{ github.event_name }}"
          # TODO: Slack/Discord通知を実装
</file>

<file path="readme.md">
# CrowdWorks 自動化システム

[![CI/CD Pipeline](https://github.com/masayuki-akinari/crowdworks-search/actions/workflows/ci.yml/badge.svg)](https://github.com/masayuki-akinari/crowdworks-search/actions/workflows/ci.yml)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.6.3-blue.svg)](https://www.typescriptlang.org/)
[![AWS CDK](https://img.shields.io/badge/AWS%20CDK-2.170.0-orange.svg)](https://aws.amazon.com/cdk/)

## 📋 概要

CrowdWorksの案件情報を自動収集・AI評価し、高評価案件をメール通知するサーバーレスシステムです。

### 🚀 主要機能
- **自動スクレイピング**: Playwright + Chromiumによる15分間隔実行
- **AI評価**: OpenAI GPT-4による案件品質評価
- **スマート通知**: 高評価案件の即座メール送信
- **コスト最適化**: 月額$5以下での運用

### 🏗️ アーキテクチャ

```mermaid
graph TB
    A[EventBridge] -->|15分間隔| B[Lambda Function]
    B -->|スクレイピング| C[CrowdWorks]
    B -->|AI評価| D[OpenAI API]
    B -->|データ保存| E[S3 Bucket]
    B -->|高評価通知| F[SNS/SES]
    G[CloudWatch] -->|監視| B
```

**技術スタック:**
- **実行環境**: AWS Lambda (コンテナイメージ)
- **ブラウザ自動化**: Playwright + Chromium
- **AI評価**: OpenAI GPT-4 API
- **データストレージ**: Amazon S3
- **通知**: Amazon SNS/SES
- **スケジューリング**: Amazon EventBridge
- **インフラ**: AWS CDK (TypeScript)

## ⚠️ **重要: Playwright Lambda制約と対応**

### 技術的課題
- **Lambda ZIP制限**: 250MB（Playwright: ~300MB）
- **ブラウザバイナリ**: Chromium単体で200MB+

### ✅ **採用方針: Lambdaコンテナイメージ**

**選択理由:**
- ✅ **容量制限**: 10GBまで対応（ZIP: 250MB → Container: 10GB）
- ✅ **完全機能**: フルPlaywright + Chromium環境
- ✅ **パフォーマンス**: ZIP版と同等の起動時間
- ✅ **開発効率**: 既存Dockerfileを活用可能
- ✅ **運用コスト**: 月$5-10での動作確認済み

```dockerfile
# 現在のDockerfile構成
FROM mcr.microsoft.com/playwright/python:v1.45.0-jammy
# → Lambda Container Imageとして活用
```

## 🚀 クイックスタート

### 1. 前提条件
```bash
# 必要なツール
- Node.js 18+
- AWS CLI v2
- Docker Desktop
- AWS CDK CLI
```

### 2. 環境セットアップ
```bash
# リポジトリクローン
git clone https://github.com/masayuki-akinari/crowdworks-search.git
cd crowdworks-search

# 依存関係インストール
npm install

# AWS認証情報設定
aws configure

# CDK初期化（初回のみ）
npx cdk bootstrap
```

### 3. **コンテナイメージ版デプロイ（推奨）**
```bash
# ビルド & デプロイ
npm run cdk:deploy

# または手動での段階実行
docker build -t crowdworks-searcher .
npx cdk deploy --context deployMethod=container
```

### 4. 設定
```bash
# AWS Parameter Storeにシークレット設定
aws ssm put-parameter \
  --name "/crowdworks-search/openai-api-key" \
  --value "your-openai-api-key" \
  --type "SecureString"

aws ssm put-parameter \
  --name "/crowdworks-search/crowdworks-email" \
  --value "your-crowdworks-email" \
  --type "SecureString"
```

## 📊 システム仕様

### 実行スペック
```yaml
Lambda仕様:
  デプロイ形式: Container Image (ECR)
  メモリ: 3,008 MB
  タイムアウト: 15分
  アーキテクチャ: x86_64
  
Playwright設定:
  ブラウザ: Chromium (フル版)
  ヘッドレスモード: true
  実行間隔: 15分
```

### コスト構造（月額）
```yaml
Lambda実行:
  1,000回/月 × 10秒: $2-5
ECRストレージ: 
  1GB Docker Image: $0.10
CloudWatch:
  ログ & 監視: $2-3
OpenAI API:
  GPT-4呼び出し: $1-2
合計: $5-10/月
```

## 🔧 開発・デバッグ

### ローカル開発
```bash
# TypeScript開発モード
npm run dev

# Dockerでのテスト
npm run docker:build
npm run docker:run

# ローカルPlaywright実行
npx playwright install chromium
npm run test:e2e
```

### ログ確認
```bash
# CloudWatch Logs確認
aws logs tail /aws/lambda/crowdworks-searcher-main --follow

# Lambda実行状況確認
aws lambda invoke \
  --function-name crowdworks-searcher-main \
  --payload '{}' \
  response.json
```

## 🛠️ 代替アプローチ: 軽量版

**予算最優先の場合:**
```typescript
// @sparticuz/chromium使用（軽量版）
import { chromium } from 'playwright-core';
import chromium_binary from '@sparticuz/chromium';

const browser = await chromium.launch({
  args: [...chromium_binary.args, '--no-sandbox'],
  executablePath: await chromium_binary.executablePath()
});
```

**制約:**
- 機能制限あり（軽量Chromium）
- Lambda Layer必要
- デバッグ困難

## 📚 ドキュメント

### 設計書
- [📋 実装計画書](./docs/05_implementation_plan.md)
- [🏗️ アーキテクチャ設計](./docs/01_architecture.md)
- [🔧 CI/CD セットアップ](./docs/CI_CD_SETUP.md)

### 運用ガイド
- [🚀 デプロイガイド](./docs/02_deployment.md)
- [📊 監視・アラート](./docs/03_monitoring.md)
- [🛡️ セキュリティ](./docs/04_security.md)

デプロイガイドでは、前提条件の確認から `cdk bootstrap`、`npm run cdk:deploy` の実行までを整理しています。さらに、CI/CDパイプラインによる自動デプロイ方法も紹介しています。

## 🎯 現在の開発状況

### ✅ 完了済み
- [x] CI/CDパイプライン構築
- [x] TypeScript + CDK基盤
- [x] Docker環境整備
- [x] Playwright Lambda対応策策定

### 🔄 進行中
- [ ] **ブラウザ環境動作確認**（最優先）
- [ ] CrowdWorksスクレイピング実装
- [ ] OpenAI API連携

### 📋 今後の予定
- [ ] S3データ保存機能
- [ ] メール通知システム
- [ ] エラー監視・アラート

## 🚨 既知の制約・注意事項

### Playwright制約
- ❌ **Lambda ZIP版**: 確実に容量制限超過
- ✅ **Container版**: 動作確認済み、推奨
- ⚠️ **軽量版**: 機能制限あり、予算重視向け

### CrowdWorks制約
- **利用規約遵守**: 過度なアクセス禁止
- **レート制限**: 15分間隔での穏健な実行
- **仕様変更リスク**: サイト変更への対応必要

### コスト制約
- **月額目標**: $5以下
- **実測値**: コンテナ版で$5-10
- **監視**: AWS Cost Explorer設定済み

## 🤝 コントリビューション

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

### コード品質基準
- TypeScript strict mode必須
- any型使用禁止
- 80%以上のテストカバレッジ
- ESLint + Prettierルール遵守

## 📄 ライセンス

MIT License - 詳細は [LICENSE](./LICENSE) ファイルを参照

## 📞 サポート

- **Issue報告**: [GitHub Issues](https://github.com/masayuki-akinari/crowdworks-search/issues)
- **質問・相談**: [GitHub Discussions](https://github.com/masayuki-akinari/crowdworks-search/discussions)

---

**⚡ 次のアクション**: [実装計画書](./docs/05_implementation_plan.md) で詳細な開発ロードマップを確認してください。
</file>

<file path="package.json">
{
    "name": "crowdworks-search",
    "version": "1.0.0",
    "description": "クラウドワークス案件自動検索・評価システム",
    "main": "dist/index.js",
    "scripts": {
        "build": "tsc",
        "build:watch": "tsc --watch",
        "clean": "rimraf dist",
        "lint": "eslint src/**/*.ts",
        "lint:fix": "eslint src/**/*.ts --fix",
        "format": "prettier --write src/**/*.ts",
        "format:check": "prettier --check src/**/*.ts",
        "type-check": "tsc --noEmit",
        "test:category": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.testCrowdWorksCategories().then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "test:basic": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.testPlaywrightBasic().then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "test:debug": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.debugBrowserLifecycle().then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "test:debug-category": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.debugCategoryScrapingTest().then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "test:file-output": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.debugCategoryScrapingWithFileOutput({categories: ['ec', 'web_products'], maxJobsPerCategory: 5, saveToFile: true}).then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "test:full": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.loginAndScrapeCategories({categories: ['ec', 'web_products'], maxJobsPerCategory: 10, maxDetailsPerCategory: 3, saveToFile: true}).then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "test:no-login": "ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.testCategoryScrapingWithoutLogin({categories: ['ec', 'web_products'], maxJobsPerCategory: 10, saveToFile: true}).then(r => console.log(JSON.stringify(r, null, 2))))\"",
        "cdk:synth": "cdk synth",
        "cdk:deploy": "cdk deploy",
        "cdk:deploy:container": "npm run build && cdk deploy --require-approval never --context useContainerImage=true",
        "cdk:deploy:staging": "npm run build && cdk deploy --require-approval never --context stage=staging --context useContainerImage=true",
        "cdk:deploy:production": "npm run build && cdk deploy --require-approval never --context stage=production --context useContainerImage=true",
        "cdk:destroy": "cdk destroy",
        "cdk:diff": "cdk diff",
        "dev": "ts-node src/index.ts",
        "start": "node dist/index.js",
        "prepare": "husky install",
        "docker:build": "docker build -t crowdworks-search .",
        "docker:build:lambda": "docker build -f Dockerfile.lambda -t crowdworks-search-lambda .",
        "docker:run": "docker run --rm -it crowdworks-search",
        "docker:run:lambda": "docker run --rm -p 9000:8080 crowdworks-search-lambda",
        "docker:test:lambda": "docker run --rm crowdworks-lambda && echo 'Lambda Container Test Completed'",
        "docker:dev": "docker-compose up --build",
        "lambda:test": "curl -XPOST 'http://localhost:9000/2015-03-31/functions/function/invocations' -d '{\"source\":\"test\",\"detail\":{}}'",
        "lambda:local": "npm run docker:build:lambda && npm run docker:run:lambda",
        "precommit": "lint-staged",
        "security:audit": "npm audit --audit-level=moderate",
        "scrape:default": "npx ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(m => m.scrapeCrowdWorksJobsByCategoryWithDetails({category: 'ec', maxJobs: 50, maxDetails: 50}).then(r => console.log('✅ デフォルト取得完了:', r.jobs.length, '件一覧,', r.jobDetails.length, '件詳細')))\"",
        "scrape:both-default": "npx ts-node -r dotenv/config -e \"import('./src/lambda/handler').then(async m => { const ecResult = await m.scrapeCrowdWorksJobsByCategoryWithDetails({category: 'ec', maxJobs: 50, maxDetails: 50}); console.log('EC:', ecResult.jobs.length, '件一覧,', ecResult.jobDetails.length, '件詳細'); const webResult = await m.scrapeCrowdWorksJobsByCategoryWithDetails({category: 'web_products', maxJobs: 50, maxDetails: 50}); console.log('Web:', webResult.jobs.length, '件一覧,', webResult.jobDetails.length, '件詳細'); console.log('✅ 両カテゴリ取得完了 合計:', ecResult.jobs.length + webResult.jobs.length, '件一覧,', ecResult.jobDetails.length + webResult.jobDetails.length, '件詳細'); })\"",
        "analyze:ec": "npx ts-node scripts/analyze-details.ts details-ec.json analyzed-ec.json",
        "analyze:web": "npx ts-node scripts/analyze-details.ts details-web_products.json analyzed-web_products.json",
        "sort:high": "npx ts-node scripts/sort-by-hourly-rate.ts high",
        "sort:low": "npx ts-node scripts/sort-by-hourly-rate.ts low",
        "sort:default": "npx ts-node scripts/sort-by-hourly-rate.ts",
        "extract:high-hourly": "npx ts-node scripts/extract-high-hourly-jobs.ts",
        "recommend": "npx ts-node scripts/calculate-recommendation-score.ts"
    },
    "keywords": [
        "crowdworks",
        "automation",
        "scraping",
        "aws",
        "serverless",
        "typescript"
    ],
    "author": "Your Name",
    "license": "MIT",
    "private": true,
    "engines": {
        "node": ">=18.0.0",
        "npm": ">=8.0.0"
    },
    "dependencies": {
        "@aws-sdk/client-lambda": "^3.450.0",
        "@aws-sdk/client-s3": "^3.450.0",
        "@aws-sdk/client-sns": "^3.450.0",
        "@aws-sdk/client-ssm": "^3.540.0",
        "aws-cdk-lib": "^2.156.0",
        "aws-lambda": "^1.0.7",
        "aws-sdk": "^2.1691.0",
        "constructs": "^10.3.0",
        "dotenv": "^16.5.0",
        "openai": "^4.50.0",
        "playwright": "^1.48.2",
        "source-map-support": "^0.5.21",
        "typescript": "^5.6.3",
        "zod": "^3.22.0"
    },
    "devDependencies": {
        "@types/aws-lambda": "^8.10.145",
        "@types/jest": "^29.5.14",
        "@types/node": "^22.9.1",
        "@typescript-eslint/eslint-plugin": "^8.14.0",
        "@typescript-eslint/parser": "^8.14.0",
        "aws-cdk": "^2.170.0",
        "cross-env": "^7.0.3",
        "esbuild": "^0.24.0",
        "eslint": "^9.14.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-plugin-prettier": "^5.2.1",
        "husky": "^8.0.0",
        "jest": "^29.7.0",
        "lint-staged": "^15.0.0",
        "nock": "^13.3.0",
        "nodemon": "^3.1.7",
        "prettier": "^3.3.3",
        "ts-jest": "^29.2.5",
        "ts-node": "^10.9.2",
        "tsconfig-paths": "^4.2.0"
    },
    "husky": {
        "hooks": {
            "pre-commit": "lint-staged",
            "pre-push": "npm run type-check && npm run test"
        }
    },
    "lint-staged": {
        "src/**/*.{ts,tsx}": [
            "eslint --fix",
            "prettier --write",
            "git add"
        ]
    }
}
</file>

<file path="src/lambda/handler.ts">
/**
 * AWS Lambda Handler for CrowdWorks Search System
 * EventBridge スケジュール実行用のメインハンドラー
 */

// ローカル開発時の環境変数読み込み
if (!process.env['AWS_LAMBDA_FUNCTION_NAME']) {
  // Lambda環境ではない場合のみdotenvをロード
  try {
    require('dotenv').config();
    console.log('🏠 ローカル環境: .envファイルを読み込みました');
  } catch (error) {
    console.log('⚠️ dotenvが見つかりません（Lambda環境では正常）');
  }
}

import { Context } from 'aws-lambda';
import { chromium, Browser, Page } from 'playwright';
import { SSMClient, GetParameterCommand } from '@aws-sdk/client-ssm';

// AWS SSM Client for Parameter Store
const ssmClient = new SSMClient({ region: process.env['AWS_REGION'] || 'ap-northeast-1' });

// Lambda Event Types
interface ScheduledExecutionEvent {
  source: string;
  'detail-type': string;
  detail: Record<string, any>;
  time?: string;
}

interface ScheduledExecutionResponse {
  statusCode: number;
  body: string;
  executionTime: number;
  timestamp: string;
}

// CrowdWorks認証情報
interface CrowdWorksCredentials {
  email: string;
  password: string;
}

// ログイン結果
interface LoginResult {
  success: boolean;
  isLoggedIn: boolean;
  error?: string;
  executionTime: number;
}

// CrowdWorks案件データ型
interface CrowdWorksJob {
  id: string;
  title: string;
  description: string;
  url: string;
  budget: {
    type: 'fixed' | 'hourly' | 'unknown';
    amount: number;
    currency: string;
  };
  category: string;
  tags: string[];
  client: {
    name: string;
    rating: number;
    reviewCount: number;
  };
  postedAt: string;
  deadline?: string;
  applicants: number;
  scrapedAt: string; // スクレイピング日時
}

// スクレイピング結果型
interface ScrapingResult {
  success: boolean;
  jobsFound: number;
  jobs: CrowdWorksJob[];
  error?: string;
  executionTime: number;
}

// 案件データストレージ（メモリ内重複チェック用）
const scrapedJobsCache = new Set<string>();

// 案件詳細情報の型定義
interface CrowdWorksJobDetail {
  // 基本情報
  jobId: string;
  title: string;
  category: string;
  url: string;

  // 仕事の概要
  paymentType: string;    // 固定報酬制/時間単価制
  budget: string;         // 予算範囲
  deliveryDate: string;   // 納品希望日
  postDate: string;       // 掲載日
  applicationDeadline: string; // 応募期限
  desiredImages: string[];  // 希望イメージ（単色、カラフル等）

  // 応募状況
  applicantCount: number;    // 応募した人数
  contractCount: number;     // 契約した人数
  recruitmentCount: number;  // 募集人数
  favoriteCount: number;     // 気になる！リスト人数

  // 詳細な仕事内容
  detailedDescription: string; // 詳細な依頼内容

  // クライアント情報
  client: {
    name: string;
    url: string;
    overallRating: string;     // 総合評価
    orderHistory: string;      // 募集実績
    completionRate: string;    // プロジェクト完了率
    thankCount: string;        // ありがとう件数
    identityVerified: boolean; // 本人確認
    orderRuleCheck: boolean;   // 発注ルールチェック
    description: string;       // クライアントの説明
  };

  // 応募者情報（最新の数件）
  recentApplicants: Array<{
    name: string;
    url: string;
    applicationDate: string;
  }>;

  // 取得日時
  scrapedAt: string;
}

/**
 * AWS Parameter Storeから認証情報を取得
 * ローカル開発時は環境変数フォールバック対応
 */
async function getCrowdWorksCredentials(): Promise<CrowdWorksCredentials> {
  try {
    console.log('🔐 CrowdWorks認証情報を取得中...');

    // ローカル開発環境では環境変数を優先
    const isLocal = !process.env['AWS_LAMBDA_FUNCTION_NAME'];

    if (isLocal) {
      console.log('🏠 ローカル環境を検出、環境変数から認証情報を取得...');

      const envEmail = process.env['CROWDWORKS_EMAIL'];
      const envPassword = process.env['CROWDWORKS_PASSWORD'];

      if (envEmail && envPassword) {
        console.log('✅ 環境変数から認証情報取得完了');
        return { email: envEmail, password: envPassword };
      }

      console.log('⚠️ 環境変数が設定されていません。Parameter Storeにフォールバック...');
    }

    // Parameter Storeから取得（Lambda環境またはローカルフォールバック）
    console.log('☁️ AWS Parameter Storeから認証情報を取得中...');

    const [emailParam, passwordParam] = await Promise.all([
      ssmClient.send(new GetParameterCommand({
        Name: '/crowdworks-search/crowdworks/email',
        WithDecryption: true
      })),
      ssmClient.send(new GetParameterCommand({
        Name: '/crowdworks-search/crowdworks/password',
        WithDecryption: true
      }))
    ]);

    const email = emailParam.Parameter?.Value;
    const password = passwordParam.Parameter?.Value;

    if (!email || !password) {
      throw new Error('CrowdWorks認証情報がParameter Storeで見つかりません');
    }

    console.log('✅ Parameter Storeから認証情報取得完了');
    return { email, password };

  } catch (error) {
    console.error('❌ 認証情報取得エラー:', error);

    // エラー詳細情報を提供
    if (error instanceof Error) {
      if (error.message.includes('ParameterNotFound')) {
        throw new Error('Parameter Storeにパラメータが存在しません。以下のコマンドで作成してください:\n' +
          'aws ssm put-parameter --name "/crowdworks-search/crowdworks/email" --value "your-email" --type "SecureString"\n' +
          'aws ssm put-parameter --name "/crowdworks-search/crowdworks/password" --value "your-password" --type "SecureString"');
      }
      if (error.message.includes('AccessDenied')) {
        throw new Error('Parameter Storeへのアクセス権限がありません。IAMポリシーを確認してください。');
      }
    }

    throw new Error(`認証情報取得失敗: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * CrowdWorksログイン実行
 */
async function loginToCrowdWorks(page: Page, credentials: CrowdWorksCredentials): Promise<LoginResult> {
  const startTime = Date.now();

  try {
    console.log('🚪 CrowdWorksログイン開始...');

    // ログインページにアクセス
    console.log('📄 ログインページにアクセス中...');
    await page.goto('https://crowdworks.jp/login', {
      waitUntil: 'networkidle', // より確実な読み込み待機
      timeout: 60000 // タイムアウトを60秒に延長
    });

    console.log('✅ ログインページ読み込み完了');

    // ページタイトル確認
    const title = await page.title();
    console.log(`📋 ページタイトル: ${title}`);

    // ページの状態確認
    console.log('🔍 ページ状態確認中...');
    const pageInfo = await page.evaluate(() => ({
      url: (globalThis as any).window.location.href,
      title: (globalThis as any).document.title,
      readyState: (globalThis as any).document.readyState
    }));
    console.log(`📊 ページ状態: ${JSON.stringify(pageInfo)}`);

    // メールアドレス入力欄を待機（より確実な待機）
    console.log('⏳ メールアドレス入力欄を待機中...');
    await page.waitForFunction(
      () => (globalThis as any).document.querySelector('input[type="email"], [role="textbox"], textbox') !== null,
      { timeout: 30000 }
    );

    // メールアドレス入力（MCPテストで確認した正しい方式）
    console.log('📧 メールアドレス入力中...');
    try {
      // MCPテストで確認済み：この方式が正しく動作する
      await page.getByRole('textbox', { name: 'メールアドレス' }).fill(credentials.email);
      console.log('✅ メールアドレス入力完了');
    } catch (error) {
      // フォールバック：より具体的なセレクター
      console.log('⚠️ フォールバック中...');
      await page.fill('input[type="email"], [placeholder*="メール"]', credentials.email);
      console.log('✅ メールアドレス入力完了（フォールバック）');
    }

    // 少し待機
    await page.waitForTimeout(1000);

    // パスワード入力（MCPテストで確認した正しい方式）
    console.log('🔑 パスワード入力中...');
    try {
      // MCPテストで確認済み：この方式が正しく動作する
      await page.getByRole('textbox', { name: 'パスワード' }).fill(credentials.password);
      console.log('✅ パスワード入力完了');
    } catch (error) {
      // フォールバック：より具体的なセレクター
      console.log('⚠️ フォールバック中...');
      await page.fill('input[type="password"], [placeholder*="パスワード"]', credentials.password);
      console.log('✅ パスワード入力完了（フォールバック）');
    }

    // 少し待機
    await page.waitForTimeout(1000);

    // ログインボタンをクリック（MCPテストで確認した正しい方式）
    console.log('🖱️ ログインボタンクリック中...');
    try {
      // MCPテストで確認済み：button "ログイン"
      await page.getByRole('button', { name: 'ログイン' }).click();
      console.log('✅ ログインボタンクリック完了');
    } catch (error) {
      // フォールバック：より一般的なセレクター
      console.log('⚠️ フォールバック中...');
      await page.click('button:has-text("ログイン"), input[value="ログイン"]');
      console.log('✅ ログインボタンクリック完了（フォールバック）');
    }

    // ログイン処理完了を待機（より長めの待機）
    console.log('⏳ ログイン処理完了待機中...');
    await page.waitForTimeout(5000); // 5秒待機してレスポンスを確認

    // ログイン成功/失敗を確認
    console.log('🔍 ログイン結果確認中...');
    const currentUrl = page.url();
    console.log(`📋 現在のURL: ${currentUrl}`);

    // エラーチェック（MCPテストで確認したエラー要素）
    const loginStatus = await page.evaluate(() => {
      // 標準的なCSSセレクターを使用（:has-text()は無効なので削除）
      const errorGroups = (globalThis as any).document.querySelectorAll('[role="group"]');
      const allElements = (globalThis as any).document.querySelectorAll('*');

      let hasErrorGroup = false;
      let hasErrorMessage = false;
      let errorText = '';

      // エラーグループを探す
      for (const group of errorGroups) {
        if (group.textContent?.includes('入力内容に問題があります')) {
          hasErrorGroup = true;
          break;
        }
      }

      // エラーメッセージを探す  
      for (const element of allElements) {
        if (element.textContent?.includes('メールアドレスまたはパスワードが正しくありません')) {
          hasErrorMessage = true;
          errorText = element.textContent.trim();
          break;
        }
      }

      const generalError = (globalThis as any).document.querySelector('.error, .alert, .notice, [class*="error"]');

      // ログイン成功の判定要素
      const userMenu = (globalThis as any).document.querySelector('a[href*="logout"], .user-menu, .header-user-menu, [href*="mypage"]');
      const dashboard = (globalThis as any).document.querySelector('.dashboard, [class*="dashboard"], .mypage');

      return {
        hasErrorGroup,
        hasErrorMessage,
        hasGeneralError: !!generalError,
        hasUserMenu: !!userMenu,
        hasDashboard: !!dashboard,
        currentPath: (globalThis as any).window.location.pathname,
        isLoginPage: (globalThis as any).window.location.pathname.includes('/login'),
        errorText: errorText || generalError?.textContent || ''
      };
    });

    const executionTime = Date.now() - startTime;

    // ログイン成功判定
    const hasError = loginStatus.hasErrorGroup || loginStatus.hasErrorMessage || loginStatus.hasGeneralError;
    const hasSuccess = loginStatus.hasUserMenu || loginStatus.hasDashboard || !loginStatus.isLoginPage;
    const loginSuccess = !hasError && hasSuccess;

    console.log('📊 ログイン結果詳細:');
    console.log(`   エラーグループ: ${loginStatus.hasErrorGroup ? '❌' : '✅'}`);
    console.log(`   エラーメッセージ: ${loginStatus.hasErrorMessage ? '❌' : '✅'}`);
    console.log(`   ユーザーメニュー: ${loginStatus.hasUserMenu ? '✅' : '❌'}`);
    console.log(`   ログインページ: ${loginStatus.isLoginPage ? '❌' : '✅'}`);
    console.log(`   現在のパス: ${loginStatus.currentPath}`);

    if (loginSuccess) {
      console.log('✅ CrowdWorksログイン成功！');
      return {
        success: true,
        isLoggedIn: true,
        executionTime
      };
    } else {
      console.log('❌ CrowdWorksログイン失敗');
      const errorDetail = loginStatus.errorText || 'ログイン後の状態確認でエラーを検出';
      console.log(`📋 エラー詳細: ${errorDetail}`);

      return {
        success: false,
        isLoggedIn: false,
        error: errorDetail,
        executionTime
      };
    }

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ ログインエラー:', errorMessage);

    return {
      success: false,
      isLoggedIn: false,
      error: errorMessage,
      executionTime
    };
  }
}

/**
 * Playwright基本動作確認テスト
 */
export async function testPlaywrightBasic(): Promise<{
  success: boolean;
  chromiumVersion?: string;
  title?: string;
  screenshot?: boolean;
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log('🚀 Playwright Chromium起動テスト開始...');

    // Chromium起動（Lambda Container最適化設定）
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process',
        '--no-zygote',
        '--disable-software-rasterizer',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection',
      ],
      ...(process.env['AWS_LAMBDA_FUNCTION_NAME'] ? {
        executablePath: process.env['PLAYWRIGHT_BROWSERS_PATH']
          ? `${process.env['PLAYWRIGHT_BROWSERS_PATH']}/chromium`
          : '/usr/bin/chromium'
      } : {}),
    });

    console.log('✅ Chromium起動成功');

    // ブラウザコンテキスト作成
    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      viewport: { width: 1280, height: 720 },
    });

    const page: Page = await context.newPage();
    console.log('📄 ページオブジェクト作成完了');

    // 基本ページアクセステスト
    console.log('🌐 Google アクセステスト開始...');
    await page.goto('https://www.google.com', {
      waitUntil: 'networkidle',
      timeout: 30000
    });

    const title = await page.title();
    console.log(`📋 ページタイトル取得: "${title}"`);

    // スクリーンショット取得（Lambda環境確認用）
    try {
      await page.screenshot({
        path: '/tmp/test-screenshot.png',
        fullPage: false
      });
      console.log('📸 スクリーンショット保存成功: /tmp/test-screenshot.png');
    } catch (screenshotError) {
      console.warn('⚠️ スクリーンショット保存失敗:', screenshotError);
    }

    // Chromiumバージョン情報取得（ブラウザ環境内で実行）
    const chromiumVersion = await page.evaluate(() => {
      // ブラウザ環境内なのでnavigatorオブジェクトが利用可能
      return (globalThis as any).navigator.userAgent;
    });

    await context.close();

    const executionTime = Date.now() - startTime;
    console.log(`✅ Playwright基本テスト完了 (${executionTime}ms)`);

    return {
      success: true,
      chromiumVersion,
      title,
      screenshot: true,
      executionTime,
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ Playwright テスト失敗:', errorMessage);
    console.error('Stack trace:', error instanceof Error ? error.stack : 'No stack trace');

    return {
      success: false,
      error: errorMessage,
      executionTime,
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('🔒 ブラウザクリーンアップ完了');
      } catch (closeError) {
        console.warn('⚠️ ブラウザクローズ時エラー:', closeError);
      }
    }
  }
}

/**
 * CrowdWorks案件スクレイピング実行
 */
async function scrapeCrowdWorksJobs(page: Page, maxJobs: number = 10): Promise<ScrapingResult> {
  const startTime = Date.now();

  try {
    console.log('🔍 CrowdWorks案件スクレイピング開始...');

    // CrowdWorks公開案件ページにアクセス
    console.log('📄 CrowdWorks案件ページにアクセス中...');
    await page.goto('https://crowdworks.jp/public/jobs', {
      waitUntil: 'networkidle',
      timeout: 30000
    });

    console.log('✅ CrowdWorksページ読み込み完了');

    // ページタイトル確認
    const pageTitle = await page.title();
    console.log(`📋 ページタイトル: "${pageTitle}"`);

    // 案件一覧の要素が読み込まれるまで待機
    console.log('⏳ 案件一覧読み込み待機中...');
    await page.waitForSelector('.search_result', { timeout: 10000 });

    // 案件要素を取得
    console.log('📝 案件データ抽出中...');
    const jobs: CrowdWorksJob[] = await page.evaluate((params: { maxJobsLimit: number; categoryName: string; scrapedIds: string[] }) => {
      console.log('🔍 DOM解析開始...');

      // 直接案件リンクから抽出（デバッグで成功した方式）
      const doc = (globalThis as any).document;
      const jobLinks = doc.querySelectorAll('a[href*="/public/jobs/"]');
      console.log(`🔗 案件リンク数: ${jobLinks.length}`);

      if (jobLinks.length === 0) {
        console.log('❌ 案件リンクが見つかりません');
        return [];
      }

      // 案件詳細ページのリンクのみを対象にする（一覧ページや他のリンクを除外）
      const validJobLinks: any[] = [];
      for (let i = 0; i < jobLinks.length; i++) {
        const link = jobLinks[i];
        const href = link.getAttribute('href') || '';

        // 案件詳細ページのパターンをチェック
        if (href.match(/\/public\/jobs\/\d+$/) && !href.includes('category') && !href.includes('group')) {
          validJobLinks.push(link);
        }
      }

      console.log(`✅ 有効な案件リンク数: ${validJobLinks.length}`);

      // 最初の数件のみを安全に抽出
      const safeLimit = Math.min(validJobLinks.length, params.maxJobsLimit);
      const jobs: any[] = [];

      for (let i = 0; i < safeLimit; i++) {
        try {
          const link = validJobLinks[i];
          const href = link.getAttribute('href') || '';
          const title = link.textContent?.trim() || '';
          const url = href.startsWith('http') ? href : `https://crowdworks.jp${href}`;

          // 案件IDをURLから抽出
          const jobIdMatch = url.match(/\/public\/jobs\/(\d+)/);
          const jobId = jobIdMatch ? (jobIdMatch[1] ?? `unknown_${i}`) : `unknown_${i}`;

          if (title && url && jobId !== `unknown_${i}`) {
            // 重複チェック
            if (params.scrapedIds.includes(jobId)) {
              console.log(`⏭️ スキップ: 重複案件 ${jobId}`);
              continue;
            }

            // 親要素から追加情報を取得
            let parentElement = link.parentElement;
            let detailText = '';
            let budget = '';

            // 最大5階層まで親要素を辿る
            for (let depth = 0; depth < 5 && parentElement; depth++) {
              const parentText = parentElement.textContent || '';
              if (parentText.includes('円') && !budget) {
                // 予算情報を抽出
                const budgetMatch = parentText.match(/(\d{1,3}(?:,\d{3})*)\s*円/);
                if (budgetMatch) {
                  budget = budgetMatch[0];
                }
              }

              if (parentText.length > detailText.length && parentText.length < 1000) {
                detailText = parentText;
              }

              parentElement = parentElement.parentElement;
            }

            // 予算タイプの判定
            let budgetType: 'fixed' | 'hourly' | 'unknown' = 'unknown';
            let budgetAmount = 0;

            if (detailText.includes('固定報酬制')) {
              budgetType = 'fixed';
            } else if (detailText.includes('時間単価制')) {
              budgetType = 'hourly';
            }

            if (budget) {
              const amountStr = budget.replace(/[^0-9]/g, '');
              budgetAmount = parseInt(amountStr) || 0;
            }

            // タグ/スキルの取得
            const tags: string[] = [];
            if (detailText) {
              const skillMatches = detailText.match(/([a-zA-Z]+|[ァ-ヶー]+[\w]*)/g);
              if (skillMatches) {
                skillMatches.forEach(skill => {
                  if (skill.length > 2 && skill.length < 20) {
                    tags.push(skill);
                  }
                });
              }
            }

            // 投稿日時の取得
            let postedAt = new Date().toISOString().split('T')[0];
            const dateMatch = detailText.match(/(\d{4}年\d{2}月\d{2}日|\d{2}月\d{2}日)/);
            if (dateMatch) {
              postedAt = dateMatch[0];
            }

            // 応募者数と期限の取得
            let applicants = 0;
            let deadline = '';

            const contractMatch = detailText.match(/契約数[^\d]*(\d+)/);
            if (contractMatch) {
              applicants = parseInt(contractMatch[1] ?? '0') || 0;
            }

            const deadlineMatch = detailText.match(/あと(\d+)日|(\d+月\d+日)/);
            if (deadlineMatch) {
              deadline = deadlineMatch[0] ?? '';
            }

            jobs.push({
              id: jobId,
              title: title,
              description: detailText.substring(0, 500),
              url: url,
              budget: {
                type: budgetType,
                amount: budgetAmount,
                currency: 'JPY'
              },
              category: params.categoryName,
              tags: tags.slice(0, 10),
              client: {
                name: '匿名',
                rating: 0,
                reviewCount: 0
              },
              postedAt: postedAt,
              deadline: deadline,
              applicants: applicants,
              scrapedAt: new Date().toISOString()
            });
            console.log(`✅ 案件抽出成功: ${title} (${jobId}) - ${budget}`);
          }
        } catch (itemError) {
          console.log(`❌ 案件 ${i} の処理中にエラー:`, itemError);
          continue;
        }
      }

      console.log(`📊 合計 ${jobs.length} 件の案件を抽出しました`);
      return jobs;
    }, { maxJobsLimit: maxJobs, categoryName: 'all', scrapedIds: Array.from(scrapedJobsCache) });

    // 重複チェックのためキャッシュに追加
    jobs.forEach((job: CrowdWorksJob) => scrapedJobsCache.add(job.id));

    const executionTime = Date.now() - startTime;

    console.log(`🎉 CrowdWorksスクレイピング完了:`);
    console.log(`   📊 取得案件数: ${jobs.length}`);
    console.log(`   ⏱️ 実行時間: ${executionTime}ms`);

    // サンプル案件情報をログ出力
    if (jobs.length > 0) {
      console.log(`📝 サンプル案件情報:`);
      const sample = jobs[0];
      if (sample) {
        console.log(`   🏷️ タイトル: ${sample.title}`);
        console.log(`   💰 予算: ${sample.budget.type} ${sample.budget.amount}円`);
        console.log(`   🏢 クライアント: ${sample.client.name} (評価: ${sample.client.rating}/5)`);
        console.log(`   🏷️ カテゴリ: ${sample.category}`);
        console.log(`   🔗 URL: ${sample.url}`);
      }
    }

    return {
      success: true,
      jobsFound: jobs.length,
      jobs,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ CrowdWorksスクレイピングエラー:', errorMessage);

    return {
      success: false,
      jobsFound: 0,
      jobs: [],
      error: errorMessage,
      executionTime
    };
  }
}

/**
 * CrowdWorks案件取得テスト（Playwright統合版）
 */
export async function testCrowdWorksScraping(): Promise<{
  success: boolean;
  scrapingResult?: ScrapingResult;
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log('🚀 CrowdWorks案件取得テスト開始...');

    // Chromium起動
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process',
        '--no-zygote',
        '--disable-software-rasterizer',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection',
      ],
      ...(process.env['AWS_LAMBDA_FUNCTION_NAME'] ? {
        executablePath: process.env['PLAYWRIGHT_BROWSERS_PATH']
          ? `${process.env['PLAYWRIGHT_BROWSERS_PATH']}/chromium`
          : '/usr/bin/chromium'
      } : {}),
    });

    console.log('✅ Chromium起動成功');

    // ブラウザコンテキスト作成
    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      viewport: { width: 1920, height: 1080 },
      // 日本語環境設定
      locale: 'ja-JP',
      timezoneId: 'Asia/Tokyo',
    });

    const page = await context.newPage();

    // CrowdWorks案件スクレイピング実行
    const scrapingResult = await scrapeCrowdWorksJobs(page, 5); // テスト用に5件取得

    await context.close();

    const executionTime = Date.now() - startTime;
    console.log(`✅ CrowdWorks案件取得テスト完了 (${executionTime}ms)`);

    return {
      success: scrapingResult.success,
      scrapingResult,
      executionTime,
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ CrowdWorks案件取得テスト失敗:', errorMessage);

    return {
      success: false,
      error: errorMessage,
      executionTime,
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('🔒 ブラウザクリーンアップ完了');
      } catch (closeError) {
        console.warn('⚠️ ブラウザクローズ時エラー:', closeError);
      }
    }
  }
}

/**
 * CrowdWorksログインテスト実行
 */
export async function testCrowdWorksLogin(): Promise<{
  success: boolean;
  loginResult?: LoginResult;
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log('🚀 CrowdWorksログインテスト開始...');

    // 認証情報を取得
    const credentials = await getCrowdWorksCredentials();

    // Chromium起動
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process',
        '--no-zygote',
        '--disable-software-rasterizer',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection',
      ],
      ...(process.env['AWS_LAMBDA_FUNCTION_NAME'] ? {
        executablePath: process.env['PLAYWRIGHT_BROWSERS_PATH']
          ? `${process.env['PLAYWRIGHT_BROWSERS_PATH']}/chromium`
          : '/usr/bin/chromium'
      } : {}),
    });

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      viewport: { width: 1280, height: 720 },
    });

    const page = await context.newPage();

    // CrowdWorksログイン実行
    const loginResult = await loginToCrowdWorks(page, credentials);

    await context.close();

    const executionTime = Date.now() - startTime;
    console.log(`✅ CrowdWorksログインテスト完了 (${executionTime}ms)`);

    return {
      success: true,
      loginResult,
      executionTime,
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ CrowdWorksログインテスト失敗:', errorMessage);

    return {
      success: false,
      error: errorMessage,
      executionTime,
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('🔒 ブラウザクリーンアップ完了');
      } catch (closeError) {
        console.warn('⚠️ ブラウザクローズ時エラー:', closeError);
      }
    }
  }
}

/**
 * カテゴリ別CrowdWorks案件スクレイピング実行
 */
async function scrapeCrowdWorksJobsByCategory(
  page: Page,
  category: string,
  maxJobs: number = 20
): Promise<ScrapingResult> {
  const startTime = Date.now();

  try {
    console.log(`🔍 カテゴリ「${category}」の案件スクレイピング開始...`);

    // カテゴリページのURL構築
    const categoryUrl = `https://crowdworks.jp/public/jobs/group/${category}`;
    console.log(`📄 カテゴリページアクセス: ${categoryUrl}`);

    await page.goto(categoryUrl, {
      waitUntil: 'domcontentloaded',
      timeout: 30000
    });

    console.log('✅ カテゴリページ読み込み完了');

    // ページタイトル確認
    const pageTitle = await page.title();
    console.log(`📋 ページタイトル: "${pageTitle}"`);

    // 新着順ソートを設定 - URLパラメータで直接指定
    console.log('🔄 新着順ソート設定中...');
    try {
      const currentUrl = page.url();
      const newUrl = currentUrl.includes('?')
        ? `${currentUrl}&order=new`
        : `${currentUrl}?order=new`;

      await page.goto(newUrl, { waitUntil: 'domcontentloaded', timeout: 30000 });
      console.log(`✅ 新着順URL直接アクセス: ${newUrl}`);
    } catch (sortError) {
      console.log('⚠️ 新着順ソート設定失敗、デフォルト順序で続行');
    }

    // 案件一覧の要素が読み込まれるまで待機
    console.log('⏳ 案件一覧読み込み待機中...');
    try {
      // 実際のDOM構造に基づいた待機
      await page.waitForSelector('main list listitem', { timeout: 10000 });
      console.log('✅ 案件一覧要素の読み込み確認');
    } catch (error) {
      console.log('⚠️ 標準的な案件一覧要素待機失敗、他のセレクターを試行');
      // フォールバック：一般的なリスト要素を待機
      try {
        await page.waitForSelector('ul li, ol li', { timeout: 5000 });
        console.log('✅ 代替案件一覧要素の読み込み確認');
      } catch (fallbackError) {
        console.log('⚠️ 案件一覧要素が見つかりません、DOM構造を直接解析します');
      }
    }

    // 案件要素を取得
    console.log('📝 案件データ抽出中...');
    const jobs: CrowdWorksJob[] = await page.evaluate((params: { maxJobsLimit: number; categoryName: string; scrapedIds: string[] }) => {
      console.log('🔍 DOM解析開始...');

      // 直接案件リンクから抽出（デバッグで成功した方式）
      const doc = (globalThis as any).document;
      const jobLinks = doc.querySelectorAll('a[href*="/public/jobs/"]');
      console.log(`🔗 案件リンク数: ${jobLinks.length}`);

      if (jobLinks.length === 0) {
        console.log('❌ 案件リンクが見つかりません');
        return [];
      }

      // 案件詳細ページのリンクのみを対象にする（一覧ページや他のリンクを除外）
      const validJobLinks: any[] = [];
      for (let i = 0; i < jobLinks.length; i++) {
        const link = jobLinks[i];
        const href = link.getAttribute('href') || '';

        // 案件詳細ページのパターンをチェック
        if (href.match(/\/public\/jobs\/\d+$/) && !href.includes('category') && !href.includes('group')) {
          validJobLinks.push(link);
        }
      }

      console.log(`✅ 有効な案件リンク数: ${validJobLinks.length}`);

      // 最初の数件のみを安全に抽出
      const safeLimit = Math.min(validJobLinks.length, params.maxJobsLimit);
      const jobs: any[] = [];

      for (let i = 0; i < safeLimit; i++) {
        try {
          const link = validJobLinks[i];
          const href = link.getAttribute('href') || '';
          const title = link.textContent?.trim() || '';
          const url = href.startsWith('http') ? href : `https://crowdworks.jp${href}`;

          // 案件IDをURLから抽出
          const jobIdMatch = url.match(/\/public\/jobs\/(\d+)/);
          const jobId = jobIdMatch ? (jobIdMatch[1] ?? `unknown_${i}`) : `unknown_${i}`;

          if (title && url && jobId !== `unknown_${i}`) {
            // 重複チェック
            if (params.scrapedIds.includes(jobId)) {
              console.log(`⏭️ スキップ: 重複案件 ${jobId}`);
              continue;
            }

            // 親要素から追加情報を取得
            let parentElement = link.parentElement;
            let detailText = '';
            let budget = '';

            // 最大5階層まで親要素を辿る
            for (let depth = 0; depth < 5 && parentElement; depth++) {
              const parentText = parentElement.textContent || '';
              if (parentText.includes('円') && !budget) {
                // 予算情報を抽出
                const budgetMatch = parentText.match(/(\d{1,3}(?:,\d{3})*)\s*円/);
                if (budgetMatch) {
                  budget = budgetMatch[0];
                }
              }

              if (parentText.length > detailText.length && parentText.length < 1000) {
                detailText = parentText;
              }

              parentElement = parentElement.parentElement;
            }

            // 予算タイプの判定
            let budgetType: 'fixed' | 'hourly' | 'unknown' = 'unknown';
            let budgetAmount = 0;

            if (detailText.includes('固定報酬制')) {
              budgetType = 'fixed';
            } else if (detailText.includes('時間単価制')) {
              budgetType = 'hourly';
            }

            if (budget) {
              const amountStr = budget.replace(/[^0-9]/g, '');
              budgetAmount = parseInt(amountStr) || 0;
            }

            // タグ/スキルの取得
            const tags: string[] = [];
            if (detailText) {
              const skillMatches = detailText.match(/([a-zA-Z]+|[ァ-ヶー]+[\w]*)/g);
              if (skillMatches) {
                skillMatches.forEach(skill => {
                  if (skill.length > 2 && skill.length < 20) {
                    tags.push(skill);
                  }
                });
              }
            }

            // 投稿日時の取得
            let postedAt = new Date().toISOString().split('T')[0];
            const dateMatch = detailText.match(/(\d{4}年\d{2}月\d{2}日|\d{2}月\d{2}日)/);
            if (dateMatch) {
              postedAt = dateMatch[0];
            }

            // 応募者数と期限の取得
            let applicants = 0;
            let deadline = '';

            const contractMatch = detailText.match(/契約数[^\d]*(\d+)/);
            if (contractMatch) {
              applicants = parseInt(contractMatch[1] ?? '0') || 0;
            }

            const deadlineMatch = detailText.match(/あと(\d+)日|(\d+月\d+日)/);
            if (deadlineMatch) {
              deadline = deadlineMatch[0] ?? '';
            }

            jobs.push({
              id: jobId,
              title: title,
              description: detailText.substring(0, 500),
              url: url,
              budget: {
                type: budgetType,
                amount: budgetAmount,
                currency: 'JPY'
              },
              category: params.categoryName,
              tags: tags.slice(0, 10),
              client: {
                name: '匿名',
                rating: 0,
                reviewCount: 0
              },
              postedAt: postedAt,
              deadline: deadline,
              applicants: applicants,
              scrapedAt: new Date().toISOString()
            });
            console.log(`✅ 案件抽出成功: ${title} (${jobId}) - ${budget}`);
          }
        } catch (itemError) {
          console.log(`❌ 案件 ${i} の処理中にエラー:`, itemError);
          continue;
        }
      }

      console.log(`📊 合計 ${jobs.length} 件の案件を抽出しました`);
      return jobs;
    }, { maxJobsLimit: maxJobs, categoryName: category, scrapedIds: Array.from(scrapedJobsCache) });

    // 重複チェックのためキャッシュに追加
    jobs.forEach((job: CrowdWorksJob) => scrapedJobsCache.add(job.id));

    const executionTime = Date.now() - startTime;

    console.log(`🎉 カテゴリ「${category}」スクレイピング完了:`);
    console.log(`   📊 取得案件数: ${jobs.length}`);
    console.log(`   ⏱️ 実行時間: ${executionTime}ms`);

    // サンプル案件情報をログ出力
    if (jobs.length > 0) {
      console.log(`📝 サンプル案件:`);
      const sample = jobs[0];
      if (sample) {
        console.log(`   🏷️ タイトル: ${sample.title}`);
        console.log(`   💰 予算: ${sample.budget.type} ${sample.budget.amount}円`);
        console.log(`   🏢 クライアント: ${sample.client.name}`);
        console.log(`   🔗 URL: ${sample.url}`);
      }
    }

    return {
      success: true,
      jobsFound: jobs.length,
      jobs,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`❌ カテゴリ「${category}」スクレイピングエラー:`, errorMessage);

    return {
      success: false,
      jobsFound: 0,
      jobs: [],
      error: errorMessage,
      executionTime
    };
  }
}

/**
 * 指定カテゴリのCrowdWorks案件スクレイピングテスト
 */
export async function testCrowdWorksCategories(): Promise<{
  success: boolean;
  results?: { [category: string]: ScrapingResult };
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log('🚀 CrowdWorksカテゴリ案件スクレイピングテスト開始...');

    // Chromium起動
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process',
        '--no-zygote',
        '--disable-software-rasterizer',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection',
      ],
      ...(process.env['AWS_LAMBDA_FUNCTION_NAME'] ? {
        executablePath: process.env['PLAYWRIGHT_BROWSERS_PATH']
          ? `${process.env['PLAYWRIGHT_BROWSERS_PATH']}/chromium`
          : '/usr/bin/chromium'
      } : {}),
    });

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      viewport: { width: 1280, height: 720 },
    });

    const page = await context.newPage();

    console.log('✅ ブラウザ準備完了！カテゴリスクレイピング開始...');

    // 指定カテゴリをスクレイピング（ECとWeb制作）
    const categories = ['ec', 'web_products'];
    const results: { [category: string]: ScrapingResult } = {};

    for (const category of categories) {
      console.log(`\n📂 カテゴリ「${category}」処理開始...`);

      try {
        // 実装済みのカテゴリ別スクレイピング関数を使用
        const categoryResult = await scrapeCrowdWorksJobsByCategory(page, category, 20);
        results[category] = categoryResult;

        console.log(`📊 カテゴリ「${category}」完了: ${categoryResult.success ? '✅' : '❌'} (${categoryResult.jobsFound}件)`);

        if (categoryResult.success && categoryResult.jobs.length > 0) {
          const sampleJob = categoryResult.jobs[0]!; // 長さチェック済みなので安全
          console.log(`📝 サンプル案件: ${sampleJob.title}`);
        }

        // 次のカテゴリ処理前に少し待機
        await page.waitForTimeout(2000);

      } catch (categoryError) {
        console.error(`❌ カテゴリ「${category}」処理エラー:`, categoryError);
        results[category] = {
          success: false,
          jobsFound: 0,
          jobs: [],
          error: categoryError instanceof Error ? categoryError.message : String(categoryError),
          executionTime: 0
        };
      }
    }

    await context.close();

    const executionTime = Date.now() - startTime;

    // 結果サマリー
    const totalJobs = Object.values(results).reduce((sum, result) => sum + result.jobsFound, 0);
    const successCount = Object.values(results).filter(result => result.success).length;

    console.log(`\n🎉 カテゴリスクレイピングテスト完了:`);
    console.log(`   📊 処理カテゴリ数: ${categories.length}`);
    console.log(`   ✅ 成功カテゴリ数: ${successCount}`);
    console.log(`   📝 総取得案件数: ${totalJobs}件`);
    console.log(`   ⏱️ 総実行時間: ${executionTime}ms`);

    return {
      success: successCount > 0,
      results,
      executionTime,
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ カテゴリスクレイピングテスト失敗:', errorMessage);

    return {
      success: false,
      error: errorMessage,
      executionTime,
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('🔒 ブラウザクリーンアップ完了');
      } catch (closeError) {
        console.warn('⚠️ ブラウザクローズ時エラー:', closeError);
      }
    }
  }
}

/**
 * 案件詳細情報を抽出
 */
export async function scrapeCrowdWorksJobDetail(page: Page, jobUrl: string): Promise<CrowdWorksJobDetail> {
  console.log(`📄 案件詳細ページにアクセス: ${jobUrl}`);

  await page.goto(jobUrl, {
    waitUntil: 'domcontentloaded',
    timeout: 60000
  });

  await page.waitForTimeout(2000);

  const detail = await page.evaluate(() => {
    const doc = (globalThis as any).document;

    // タイトル取得（h1から正確に抽出）
    const titleElement = doc.querySelector('h1');
    const fullTitle = titleElement?.textContent?.trim() || '';
    // 案件タイトルから不要な部分を削除（より正確に）
    const title = fullTitle.replace(/\s+(ウェブデザイン|アンケート|その他).*の仕事の依頼.*$/, '').trim();

    // 案件IDをURLから抽出
    const jobId = (globalThis as any).window.location.pathname.match(/\/(\d+)$/)?.[1] || '';

    // カテゴリを取得（パンくずから）
    const categoryElement = doc.querySelector('a[href*="/public/jobs/category/"]');
    const category = categoryElement?.textContent?.trim() || '';

    // テキストベースでの情報抽出
    const pageText = doc.body?.textContent || '';

    // 支払い・予算情報を抽出
    let paymentType = '';
    let budget = '';

    const fixedPaymentMatch = pageText.match(/固定報酬制\s*([0-9,]+円\s*〜\s*[0-9,]+円|[0-9,]+円)/);
    if (fixedPaymentMatch) {
      paymentType = '固定報酬制';
      budget = fixedPaymentMatch[1];
    } else {
      const hourlyPaymentMatch = pageText.match(/時間単価制\s*([0-9,]+円\/時間\s*〜\s*[0-9,]+円\/時間|[0-9,]+円\/時間)/);
      if (hourlyPaymentMatch) {
        paymentType = '時間単価制';
        budget = hourlyPaymentMatch[1];
      }
    }

    // 日付情報を抽出
    let postDate = '';
    let applicationDeadline = '';
    let deliveryDate = '';

    const postDateMatch = pageText.match(/掲載日\s*(\d{4}年\d{2}月\d{2}日)/);
    if (postDateMatch) {
      postDate = postDateMatch[1];
    }

    const deadlineMatch = pageText.match(/応募期限\s*(\d{4}年\d{2}月\d{2}日)/);
    if (deadlineMatch) {
      applicationDeadline = deadlineMatch[1];
    }

    const deliveryMatch = pageText.match(/納品希望日\s*([^\s]+)/);
    if (deliveryMatch && deliveryMatch[1] !== '-') {
      deliveryDate = deliveryMatch[1];
    }

    // 応募状況情報を抽出
    let applicantCount = 0;
    let contractCount = 0;
    let recruitmentCount = 0;
    let favoriteCount = 0;

    const applicantMatch = pageText.match(/応募した人\s*(\d+)\s*人/);
    if (applicantMatch) applicantCount = parseInt(applicantMatch[1]);

    const contractMatch = pageText.match(/契約した人\s*(\d+)\s*人/);
    if (contractMatch) contractCount = parseInt(contractMatch[1]);

    const recruitmentMatch = pageText.match(/募集人数\s*(\d+)\s*人/);
    if (recruitmentMatch) recruitmentCount = parseInt(recruitmentMatch[1]);

    const favoriteMatch = pageText.match(/気になる！リスト\s*(\d+)\s*人/);
    if (favoriteMatch) favoriteCount = parseInt(favoriteMatch[1]);

    // クライアント情報を抽出
    const clientLinkElement = doc.querySelector('a[href*="/public/employers/"]');
    let clientName = clientLinkElement?.textContent?.trim() || '匿名';

    // anke7562のようなクライアント名も抽出
    if (clientName === '匿名' || !clientName) {
      const clientNameMatch = pageText.match(/anke\d+|[a-zA-Z0-9_]+(?=\s*本人確認)/);
      if (clientNameMatch) {
        clientName = clientNameMatch[0];
      }
    }

    // 評価情報を抽出
    let overallRating = '';
    let orderHistory = '';
    let completionRate = '';

    const ratingMatch = pageText.match(/総合評価\s*"?(\d+\.\d+)"?|"(\d+\.\d+)"/);
    if (ratingMatch) overallRating = ratingMatch[1] || ratingMatch[2];

    const historyMatch = pageText.match(/募集実績\s*"?(\d+)"?\s*件|"(\d+)"\s*件/);
    if (historyMatch) orderHistory = (historyMatch[1] || historyMatch[2]) + '件';

    const completionMatch = pageText.match(/プロジェクト完了率\s*"?(\d+)"?\s*%|"(\d+)"\s*%/);
    if (completionMatch) completionRate = (completionMatch[1] || completionMatch[2]) + '%';

    // 本人確認状態
    let identityVerified = false;
    if (pageText.includes('本人確認済み') || !pageText.includes('本人確認未提出')) {
      identityVerified = true;
    }

    // 詳細説明を取得（最も長いテーブルセルから）
    let detailedDescription = '';
    const allCells = doc.querySelectorAll('td');
    let maxLength = 0;

    allCells.forEach((cell: any) => {
      const text = cell.textContent?.trim() || '';
      if (text.length > maxLength && text.length > 200 && text.includes('概要')) {
        detailedDescription = text;
        maxLength = text.length;
      }
    });

    // フォールバック：概要が見つからない場合は最も長いセルを取得
    if (!detailedDescription) {
      maxLength = 0;
      allCells.forEach((cell: any) => {
        const text = cell.textContent?.trim() || '';
        if (text.length > maxLength && text.length > 100) {
          detailedDescription = text;
          maxLength = text.length;
        }
      });
    }

    // 最近の応募者情報を取得
    const recentApplicants: Array<{
      name: string;
      applicationDate: string;
    }> = [];

    // テーブルから応募者情報を取得
    const tables = doc.querySelectorAll('table');
    for (let i = tables.length - 1; i >= 0; i--) {
      const table = tables[i];
      const rows = table.querySelectorAll('tbody tr');

      rows.forEach((row: any) => {
        const cells = row.querySelectorAll('td');
        if (cells.length >= 2) {
          const nameCell = cells[0];
          const dateCell = cells[1];

          const nameLink = nameCell.querySelector('a');
          const name = nameLink?.textContent?.trim() || nameCell.textContent?.trim() || '';
          const applicationDate = dateCell.textContent?.trim() || '';

          // 有効な応募者データかチェック
          if (name &&
            applicationDate &&
            applicationDate.includes('/') &&
            !name.includes('クラウドワーカー') &&
            name.length < 50) {
            recentApplicants.push({
              name,
              applicationDate
            });
          }
        }
      });

      // 応募者が見つかったらループを終了
      if (recentApplicants.length > 0) {
        break;
      }
    }

    return {
      jobId,
      title: title || fullTitle, // フォールバック
      url: (globalThis as any).window.location.href,
      category,
      paymentType,
      budget,
      postDate,
      deliveryDate,
      applicationDeadline,
      desiredImages: [], // 希望イメージは現在の構造では取得困難なため空配列
      applicantCount,
      contractCount,
      recruitmentCount,
      favoriteCount,
      client: {
        name: clientName,
        url: clientLinkElement?.getAttribute('href') ?
          `https://crowdworks.jp${clientLinkElement.getAttribute('href')}` : '',
        overallRating,
        orderHistory,
        completionRate,
        thankCount: '', // ありがとう件数は現在の構造では取得困難
        identityVerified,
        orderRuleCheck: false, // 発注ルールチェックは現在の構造では取得困難
        description: '', // クライアント説明は現在の構造では取得困難
      },
      detailedDescription,
      recentApplicants: recentApplicants.map(applicant => ({
        ...applicant,
        url: '' // 応募者URLは現在の構造では取得困難
      })),
      scrapedAt: new Date().toISOString()
    };
  });

  console.log(`✅ 案件詳細情報を取得: ${detail.title}`);
  return detail;
}

/**
 * 案件詳細付きでカテゴリ別案件を取得する
 */
export async function scrapeCrowdWorksJobsByCategoryWithDetails(params: {
  category: string;
  maxJobs: number;
  maxDetails?: number;
}): Promise<{
  jobs: CrowdWorksJob[];
  jobDetails: CrowdWorksJobDetail[];
}> {
  let browser: Browser | null = null;
  const detailsFile = `details-${params.category}.json`;
  let existingDetails: CrowdWorksJobDetail[] = [];
  let existingDetailIds = new Set<string>();

  // 既存ファイル読み込み
  try {
    const fileData = await readFileAsync(detailsFile);
    if (fileData) {
      existingDetails = JSON.parse(fileData);
      existingDetailIds = new Set(existingDetails.map((d) => d.jobId));
      console.log(`📂 既存詳細データ: ${existingDetails.length}件`);
    }
  } catch (e) {
    console.log('⚠️ 既存詳細ファイルなし or 読み込み失敗');
  }

  try {
    console.log(`🔍 カテゴリ「${params.category}」の案件と詳細スクレイピング開始...`);
    browser = await chromium.launch({ headless: true, args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-dev-shm-usage'] });
    const context = await browser.newContext({ userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36' });
    const page = await context.newPage();
    const scrapingResult = await scrapeCrowdWorksJobsByCategory(page, params.category, params.maxJobs);
    if (!scrapingResult.success || scrapingResult.jobs.length === 0) {
      return { jobs: [], jobDetails: [] };
    }
    const jobs = scrapingResult.jobs;
    const maxDetailsCount = params.maxDetails ?? 3;
    // 未取得IDのみ抽出
    const detailTargets = jobs.filter(j => !existingDetailIds.has(j.id)).slice(0, maxDetailsCount);
    console.log(`📋 ${jobs.length}件中、未取得詳細: ${detailTargets.length}件`);
    const jobDetails: CrowdWorksJobDetail[] = [];
    for (let i = 0; i < detailTargets.length; i++) {
      const job = detailTargets[i]!;
      try {
        console.log(`📄 案件詳細取得中 (${i + 1}/${detailTargets.length}): ${job.title}`);
        const detail = await scrapeCrowdWorksJobDetail(page, job.url);
        jobDetails.push(detail);
        if (i < detailTargets.length - 1) {
          await page.waitForTimeout(2000);
        }
      } catch (error) {
        console.log(`❌ 案件詳細取得エラー: ${job.title}`, error);
        continue;
      }
    }
    // 既存+新規で重複排除して保存
    const mergedDetails = [...existingDetails, ...jobDetails].reduce((acc, cur) => {
      if (!acc.find(d => d.jobId === cur.jobId)) acc.push(cur);
      return acc;
    }, [] as CrowdWorksJobDetail[]);
    await writeFileAsync(detailsFile, JSON.stringify(mergedDetails, null, 2));
    console.log(`💾 詳細データ保存: ${detailsFile} (${mergedDetails.length}件)`);
    return { jobs, jobDetails: mergedDetails };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`❌ カテゴリ詳細スクレイピングエラー:`, errorMessage);
    return { jobs: [], jobDetails: [] };
  } finally {
    if (browser) {
      await browser.close();
    }
  }
}

/**
 * Lambda関数のメインハンドラー
 * EventBridgeからのスケジュール実行を処理
 */
export const lambdaHandler = async (
  event: ScheduledExecutionEvent,
  _context: Context
): Promise<ScheduledExecutionResponse> => {
  const startTime = Date.now();

  try {
    console.log('🚀 CrowdWorksスクレイピング Lambda実行開始');
    console.log('📋 イベント:', JSON.stringify(event, null, 2));

    // メイン処理: カテゴリ別スクレイピング実行
    const result = await testCrowdWorksCategories();

    const executionTime = Date.now() - startTime;

    if (result.success) {
      const summary = Object.entries(result.results || {}).map(([category, categoryResult]) =>
        `${category}: ${categoryResult.jobsFound}件`
      ).join(', ');

      const response: ScheduledExecutionResponse = {
        statusCode: 200,
        body: JSON.stringify({
          success: true,
          message: `CrowdWorksカテゴリスクレイピング完了 - ${summary}`,
          executionTime,
          timestamp: new Date().toISOString(),
          results: result.results
        }),
        executionTime,
        timestamp: new Date().toISOString()
      };

      console.log('✅ Lambda実行完了');
      console.log(`📊 実行時間: ${executionTime}ms`);
      return response;
    } else {
      const response: ScheduledExecutionResponse = {
        statusCode: 500,
        body: JSON.stringify({
          success: false,
          error: result.error || 'スクレイピング処理に失敗しました',
          executionTime,
          timestamp: new Date().toISOString()
        }),
        executionTime,
        timestamp: new Date().toISOString()
      };

      console.error('❌ Lambda実行エラー:', result.error);
      return response;
    }

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);

    const response: ScheduledExecutionResponse = {
      statusCode: 500,
      body: JSON.stringify({
        success: false,
        error: errorMessage,
        executionTime,
        timestamp: new Date().toISOString()
      }),
      executionTime,
      timestamp: new Date().toISOString()
    };

    console.error('❌ Lambda実行中の予期しないエラー:', errorMessage);
    return response;
  }
};

// API Gateway用ハンドラー（互換性維持）
export const handler = lambdaHandler;

/**
 * ログインしてカテゴリから案件詳細を取得・保存する完全ワークフロー
 */
export async function loginAndScrapeCategories(params: {
  categories: string[];  // 'ec', 'web_products'など
  maxJobsPerCategory: number;
  maxDetailsPerCategory: number;
  saveToFile?: boolean;
}): Promise<{
  success: boolean;
  loginResult?: LoginResult;
  categoryResults?: { [category: string]: ScrapingResult };
  detailResults?: { [category: string]: CrowdWorksJobDetail[] };
  savedFiles?: string[] | undefined;
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log('🚀 CrowdWorks完全ワークフロー開始...');
    console.log(`📋 対象カテゴリ: ${params.categories.join(', ')}`);
    console.log(`📊 カテゴリ毎最大案件数: ${params.maxJobsPerCategory}`);
    console.log(`📄 カテゴリ毎最大詳細数: ${params.maxDetailsPerCategory}`);

    // 1. ブラウザ起動
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process',
        '--no-zygote',
        '--disable-software-rasterizer',
        '--disable-background-timer-throttling',
        '--disable-backgrounding-occluded-windows',
        '--disable-renderer-backgrounding',
        '--disable-features=TranslateUI',
        '--disable-ipc-flooding-protection',
      ]
    });

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
    });

    const page = await context.newPage();

    // 2. ログイン実行
    console.log('🔐 CrowdWorksログイン開始...');
    const credentials = await getCrowdWorksCredentials();
    const loginResult = await loginToCrowdWorks(page, credentials);

    if (!loginResult.success) {
      throw new Error(`ログイン失敗: ${loginResult.error}`);
    }

    console.log('✅ ログイン成功');

    // 3. 各カテゴリで案件取得
    const categoryResults: { [category: string]: ScrapingResult } = {};
    const detailResults: { [category: string]: CrowdWorksJobDetail[] } = {};
    const savedFiles: string[] = [];

    for (const category of params.categories) {
      console.log(`\n📂 カテゴリ「${category}」処理開始...`);

      try {
        // カテゴリの案件一覧を取得
        const categoryResult = await scrapeCrowdWorksJobsByCategory(
          page,
          category,
          params.maxJobsPerCategory
        );

        if (!categoryResult.success) {
          console.log(`❌ カテゴリ「${category}」案件取得失敗: ${categoryResult.error}`);
          continue;
        }

        categoryResults[category] = categoryResult;
        console.log(`✅ カテゴリ「${category}」: ${categoryResult.jobsFound}件の案件を取得`);

        // 詳細情報を取得する案件を選択
        const detailTargets = categoryResult.jobs.slice(0, params.maxDetailsPerCategory);
        const categoryDetails: CrowdWorksJobDetail[] = [];

        console.log(`📄 詳細取得対象: ${detailTargets.length}件`);

        // 各案件の詳細を取得
        for (let i = 0; i < detailTargets.length; i++) {
          const job = detailTargets[i]!;
          try {
            console.log(`📄 詳細取得中 (${i + 1}/${detailTargets.length}): ${job.title}`);
            const detail = await scrapeCrowdWorksJobDetail(page, job.url);
            categoryDetails.push(detail);

            // リクエスト間隔を空ける
            if (i < detailTargets.length - 1) {
              await page.waitForTimeout(2000);
            }
          } catch (error) {
            console.log(`❌ 案件詳細取得エラー: ${job.title}`, error);
            continue;
          }
        }

        detailResults[category] = categoryDetails;
        console.log(`✅ カテゴリ「${category}」詳細取得完了: ${categoryDetails.length}件`);

        // ファイル保存（オプション）
        if (params.saveToFile) {
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

          // 案件一覧保存
          const jobsFileName = `/tmp/crowdworks-${category}-jobs-${timestamp}.json`;
          const jobsData = {
            category,
            scrapedAt: new Date().toISOString(),
            totalJobs: categoryResult.jobsFound,
            jobs: categoryResult.jobs
          };

          try {
            await writeFileAsync(jobsFileName, JSON.stringify(jobsData, null, 2));
            savedFiles.push(jobsFileName);
            console.log(`💾 案件一覧保存: ${jobsFileName}`);
          } catch (saveError) {
            console.log(`❌ 案件一覧保存エラー: ${saveError}`);
          }

          // 詳細情報保存
          if (categoryDetails.length > 0) {
            const detailsFileName = `/tmp/crowdworks-${category}-details-${timestamp}.json`;
            const detailsData = {
              category,
              scrapedAt: new Date().toISOString(),
              totalDetails: categoryDetails.length,
              details: categoryDetails
            };

            try {
              await writeFileAsync(detailsFileName, JSON.stringify(detailsData, null, 2));
              savedFiles.push(detailsFileName);
              console.log(`💾 詳細情報保存: ${detailsFileName}`);
            } catch (saveError) {
              console.log(`❌ 詳細情報保存エラー: ${saveError}`);
            }
          }
        }

      } catch (categoryError) {
        console.log(`❌ カテゴリ「${category}」処理エラー:`, categoryError);
        continue;
      }
    }

    await context.close();

    const executionTime = Date.now() - startTime;
    console.log(`\n🎯 完全ワークフロー完了 (${executionTime}ms)`);
    console.log(`📊 処理結果サマリー:`);
    console.log(`  - 処理カテゴリ数: ${Object.keys(categoryResults).length}/${params.categories.length}`);
    console.log(`  - 総案件数: ${Object.values(categoryResults).reduce((sum, result) => sum + result.jobsFound, 0)}`);
    console.log(`  - 総詳細数: ${Object.values(detailResults).reduce((sum, details) => sum + details.length, 0)}`);
    console.log(`  - 保存ファイル数: ${savedFiles.length}`);

    return {
      success: true,
      loginResult,
      categoryResults,
      detailResults,
      savedFiles: savedFiles.length > 0 ? savedFiles : undefined,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ 完全ワークフロー失敗:', errorMessage);

    return {
      success: false,
      error: errorMessage,
      executionTime
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('🔒 ブラウザクリーンアップ完了');
      } catch (closeError) {
        console.warn('⚠️ ブラウザクローズエラー:', closeError);
      }
    }
  }
}

// ファイル書き込み用のヘルパー関数
async function writeFileAsync(filePath: string, data: string): Promise<void> {
  return new Promise((resolve, reject) => {
    const fs = require('fs');
    fs.writeFile(filePath, data, (err: any) => {
      if (err) reject(err);
      else resolve();
    });
  });
}

/**
 * ログインなしでカテゴリから案件を取得するテスト（認証問題回避版）
 */
export async function testCategoryScrapingWithoutLogin(params: {
  categories: string[];
  maxJobsPerCategory: number;
  saveToFile?: boolean;
}): Promise<{
  success: boolean;
  categoryResults?: { [category: string]: ScrapingResult };
  savedFiles?: string[];
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  let browser: Browser | null = null;

  try {
    console.log('🚀 ログインなしカテゴリスクレイピングテスト開始...');
    console.log(`📋 対象カテゴリ: ${params.categories.join(', ')}`);
    console.log(`📊 カテゴリ毎最大案件数: ${params.maxJobsPerCategory}`);

    // 1. ブラウザ起動
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--single-process',
        '--no-zygote',
        '--disable-software-rasterizer'
      ]
    });

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
    });

    const page = await context.newPage();

    // 2. 各カテゴリで案件取得（ログインなし）
    const categoryResults: { [category: string]: ScrapingResult } = {};
    const savedFiles: string[] = [];

    for (const category of params.categories) {
      console.log(`\n📂 カテゴリ「${category}」処理開始...`);

      try {
        // カテゴリの案件一覧を取得（ログインなし）
        const categoryResult = await scrapeCrowdWorksJobsByCategory(
          page,
          category,
          params.maxJobsPerCategory
        );

        if (!categoryResult.success) {
          console.log(`❌ カテゴリ「${category}」案件取得失敗: ${categoryResult.error}`);
          continue;
        }

        categoryResults[category] = categoryResult;
        console.log(`✅ カテゴリ「${category}」: ${categoryResult.jobsFound}件の案件を取得`);

        // ファイル保存（オプション）
        if (params.saveToFile) {
          const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

          // 案件一覧保存
          const jobsFileName = `./crowdworks-${category}-jobs-${timestamp}.json`;
          const jobsData = {
            category,
            scrapedAt: new Date().toISOString(),
            totalJobs: categoryResult.jobsFound,
            jobs: categoryResult.jobs
          };

          try {
            await writeFileAsync(jobsFileName, JSON.stringify(jobsData, null, 2));
            savedFiles.push(jobsFileName);
            console.log(`💾 案件一覧保存: ${jobsFileName}`);
          } catch (saveError) {
            console.log(`❌ 案件一覧保存エラー: ${saveError}`);
          }
        }

      } catch (categoryError) {
        console.log(`❌ カテゴリ「${category}」処理エラー:`, categoryError);
        continue;
      }
    }

    await context.close();

    const executionTime = Date.now() - startTime;
    console.log(`\n🎯 ログインなしスクレイピング完了 (${executionTime}ms)`);
    console.log(`📊 処理結果サマリー:`);
    console.log(`  - 処理カテゴリ数: ${Object.keys(categoryResults).length}/${params.categories.length}`);
    console.log(`  - 総案件数: ${Object.values(categoryResults).reduce((sum, result) => sum + result.jobsFound, 0)}`);
    console.log(`  - 保存ファイル数: ${savedFiles.length}`);

    return {
      success: true,
      categoryResults,
      ...(savedFiles.length > 0 ? { savedFiles } : {}),
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('❌ ログインなしスクレイピング失敗:', errorMessage);

    return {
      success: false,
      error: errorMessage,
      executionTime
    };
  } finally {
    if (browser) {
      try {
        await browser.close();
        console.log('🔒 ブラウザクリーンアップ完了');
      } catch (closeError) {
        console.warn('⚠️ ブラウザクローズエラー:', closeError);
      }
    }
  }
}

/**
 * ブラウザ終了の原因を調査するためのデバッグ版テスト
 */
export async function debugBrowserLifecycle(): Promise<{
  success: boolean;
  steps: string[];
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  const steps: string[] = [];
  let browser: Browser | null = null;

  try {
    steps.push('🚀 デバッグテスト開始');
    console.log('🚀 ブラウザライフサイクルデバッグテスト開始...');

    // ブラウザ起動前の状態確認
    steps.push('📊 システム状態確認');
    console.log('📊 システム状態確認中...');

    // ブラウザ起動
    steps.push('🌐 ブラウザ起動開始');
    console.log('🌐 ブラウザ起動中...');

    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--disable-software-rasterizer'
      ]
    });

    steps.push('✅ ブラウザ起動完了');
    console.log('✅ ブラウザ起動完了');

    // ブラウザ終了イベントをリッスン
    browser.on('disconnected', () => {
      steps.push('⚠️ ブラウザ予期しない切断検出');
      console.log('⚠️ ブラウザが予期せず切断されました');
    });

    // コンテキスト作成
    steps.push('📄 コンテキスト作成開始');
    console.log('📄 コンテキスト作成中...');

    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
    });

    steps.push('✅ コンテキスト作成完了');
    console.log('✅ コンテキスト作成完了');

    // ページ作成
    steps.push('📋 ページ作成開始');
    console.log('📋 ページ作成中...');

    const page = await context.newPage();

    steps.push('✅ ページ作成完了');
    console.log('✅ ページ作成完了');

    // ページ終了イベントをリッスン
    page.on('close', () => {
      steps.push('⚠️ ページ予期しない終了検出');
      console.log('⚠️ ページが予期せず終了されました');
    });

    // シンプルなページアクセステスト
    steps.push('🌍 Google アクセステスト開始');
    console.log('🌍 Google アクセステスト開始...');

    await page.goto('https://www.google.com', {
      waitUntil: 'domcontentloaded',
      timeout: 10000
    });

    steps.push('✅ Google アクセス完了');
    console.log('✅ Google アクセス完了');

    // タイトル取得
    steps.push('📋 タイトル取得開始');
    const title = await page.title();
    steps.push(`✅ タイトル取得完了: ${title}`);
    console.log(`✅ タイトル取得完了: ${title}`);

    // 待機テスト
    steps.push('⏳ 2秒待機テスト開始');
    console.log('⏳ 2秒待機テスト開始...');
    await page.waitForTimeout(2000);
    steps.push('✅ 2秒待機完了');
    console.log('✅ 2秒待機完了');

    // CrowdWorksページアクセステスト
    steps.push('🎯 CrowdWorksトップページアクセス開始');
    console.log('🎯 CrowdWorksトップページアクセス開始...');

    await page.goto('https://crowdworks.jp', {
      waitUntil: 'domcontentloaded',
      timeout: 15000
    });

    steps.push('✅ CrowdWorksトップページアクセス完了');
    console.log('✅ CrowdWorksトップページアクセス完了');

    const cwTitle = await page.title();
    steps.push(`📋 CrowdWorksタイトル: ${cwTitle}`);
    console.log(`📋 CrowdWorksタイトル: ${cwTitle}`);

    // クリーンアップ
    steps.push('🧹 コンテキスト終了開始');
    console.log('🧹 コンテキスト終了開始...');
    await context.close();
    steps.push('✅ コンテキスト終了完了');
    console.log('✅ コンテキスト終了完了');

    const executionTime = Date.now() - startTime;
    steps.push(`🎉 デバッグテスト完了 (${executionTime}ms)`);
    console.log(`🎉 デバッグテスト完了 (${executionTime}ms)`);

    return {
      success: true,
      steps,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    steps.push(`❌ エラー発生: ${errorMessage}`);
    console.error('❌ デバッグテストでエラー:', errorMessage);

    return {
      success: false,
      steps,
      error: errorMessage,
      executionTime
    };
  } finally {
    if (browser) {
      try {
        steps.push('🔒 ブラウザ終了開始');
        console.log('🔒 ブラウザ終了開始...');
        await browser.close();
        steps.push('✅ ブラウザ終了完了');
        console.log('✅ ブラウザ終了完了');
      } catch (closeError) {
        steps.push(`⚠️ ブラウザ終了エラー: ${closeError}`);
        console.warn('⚠️ ブラウザ終了エラー:', closeError);
      }
    }
  }
}

/**
 * カテゴリ別CrowdWorks案件スクレイピング実行（デバッグ版）
 */
async function scrapeCrowdWorksJobsByCategoryDebug(
  page: Page,
  category: string,
  maxJobs: number = 20
): Promise<ScrapingResult> {
  const startTime = Date.now();

  try {
    console.log(`🔍 カテゴリ「${category}」の案件スクレイピング開始...`);

    // ページ状態の事前確認
    console.log('📊 ページ状態確認中...');
    const isConnected = page.isClosed();
    console.log(`📋 ページ状態: ${isConnected ? '閉じている' : '開いている'}`);

    if (isConnected) {
      throw new Error('ページが既に閉じられています');
    }

    // カテゴリページのURL構築
    const categoryUrl = `https://crowdworks.jp/public/jobs/group/${category}`;
    console.log(`📄 カテゴリページアクセス: ${categoryUrl}`);

    // ナビゲーション前のページ状態確認
    console.log('🌐 ナビゲーション前状態確認...');
    console.log(`📋 現在のURL: ${page.url()}`);

    await page.goto(categoryUrl, {
      waitUntil: 'domcontentloaded',
      timeout: 30000
    });

    console.log('✅ カテゴリページ読み込み完了');

    // ページタイトル確認
    const pageTitle = await page.title();
    console.log(`📋 ページタイトル: "${pageTitle}"`);

    // 新着順ソートを設定 - URLパラメータで直接指定
    console.log('🔄 新着順ソート設定中...');
    try {
      const currentUrl = page.url();
      const newUrl = currentUrl.includes('?')
        ? `${currentUrl}&order=new`
        : `${currentUrl}?order=new`;

      await page.goto(newUrl, { waitUntil: 'domcontentloaded', timeout: 30000 });
      console.log(`✅ 新着順URL直接アクセス: ${newUrl}`);
    } catch (sortError) {
      console.log('⚠️ 新着順ソート設定失敗、デフォルト順序で続行');
    }

    // DOM構造を確認
    console.log('🔍 DOM構造確認中...');
    const domInfo = await page.evaluate(() => {
      const doc = (globalThis as any).document;
      return {
        listCount: doc.querySelectorAll('list').length,
        listitemCount: doc.querySelectorAll('listitem').length,
        ulCount: doc.querySelectorAll('ul').length,
        liCount: doc.querySelectorAll('li').length,
        jobLinksCount: doc.querySelectorAll('a[href*="/public/jobs/"]').length,
        hasMainElement: !!doc.querySelector('main')
      };
    });
    console.log('📊 DOM構造:', JSON.stringify(domInfo, null, 2));

    // 案件一覧の要素が読み込まれるまで待機
    console.log('⏳ 案件一覧読み込み待機中...');
    try {
      // 実際のDOM構造に基づいた待機
      await page.waitForSelector('main list listitem', { timeout: 10000 });
      console.log('✅ 案件一覧要素の読み込み確認');
    } catch (error) {
      console.log('⚠️ 標準的な案件一覧要素待機失敗、他のセレクターを試行');
      // フォールバック：一般的なリスト要素を待機
      try {
        await page.waitForSelector('ul li, ol li', { timeout: 5000 });
        console.log('✅ 代替案件一覧要素の読み込み確認');
      } catch (fallbackError) {
        console.log('⚠️ 案件一覧要素が見つかりません、DOM構造を直接解析します');
      }
    }

    // より安全なevaluate実行
    console.log('📝 案件データ抽出中...');

    // ページ状態の再確認
    console.log('📊 データ抽出前ページ状態確認...');
    const isStillConnected = page.isClosed();
    console.log(`📋 ページ状態: ${isStillConnected ? '閉じている' : '開いている'}`);

    if (isStillConnected) {
      throw new Error('データ抽出前にページが閉じられました');
    }

    const jobs: CrowdWorksJob[] = await page.evaluate((params: { maxJobsLimit: number; categoryName: string; scrapedIds: string[] }) => {
      console.log('🔍 DOM解析開始...');

      // 直接案件リンクから抽出（デバッグで成功した方式）
      const doc = (globalThis as any).document;
      const jobLinks = doc.querySelectorAll('a[href*="/public/jobs/"]');
      console.log(`🔗 案件リンク数: ${jobLinks.length}`);

      if (jobLinks.length === 0) {
        console.log('❌ 案件リンクが見つかりません');
        return [];
      }

      // 案件詳細ページのリンクのみを対象にする（一覧ページや他のリンクを除外）
      const validJobLinks: any[] = [];
      for (let i = 0; i < jobLinks.length; i++) {
        const link = jobLinks[i];
        const href = link.getAttribute('href') || '';

        // 案件詳細ページのパターンをチェック
        if (href.match(/\/public\/jobs\/\d+$/) && !href.includes('category') && !href.includes('group')) {
          validJobLinks.push(link);
        }
      }

      console.log(`✅ 有効な案件リンク数: ${validJobLinks.length}`);

      // 最初の数件のみを安全に抽出
      const safeLimit = Math.min(validJobLinks.length, params.maxJobsLimit);
      const jobs: any[] = [];

      for (let i = 0; i < safeLimit; i++) {
        try {
          const link = validJobLinks[i];
          const href = link.getAttribute('href') || '';
          const title = link.textContent?.trim() || '';
          const url = href.startsWith('http') ? href : `https://crowdworks.jp${href}`;

          // 案件IDをURLから抽出
          const jobIdMatch = url.match(/\/public\/jobs\/(\d+)/);
          const jobId = jobIdMatch ? (jobIdMatch[1] ?? `unknown_${i}`) : `unknown_${i}`;

          if (title && url && jobId !== `unknown_${i}`) {
            // 重複チェック
            if (params.scrapedIds.includes(jobId)) {
              console.log(`⏭️ スキップ: 重複案件 ${jobId}`);
              continue;
            }

            // 親要素から追加情報を取得
            let parentElement = link.parentElement;
            let detailText = '';
            let budget = '';

            // 最大5階層まで親要素を辿る
            for (let depth = 0; depth < 5 && parentElement; depth++) {
              const parentText = parentElement.textContent || '';
              if (parentText.includes('円') && !budget) {
                // 予算情報を抽出
                const budgetMatch = parentText.match(/(\d{1,3}(?:,\d{3})*)\s*円/);
                if (budgetMatch) {
                  budget = budgetMatch[0];
                }
              }

              if (parentText.length > detailText.length && parentText.length < 1000) {
                detailText = parentText;
              }

              parentElement = parentElement.parentElement;
            }

            // 予算タイプの判定
            let budgetType: 'fixed' | 'hourly' | 'unknown' = 'unknown';
            let budgetAmount = 0;

            if (detailText.includes('固定報酬制')) {
              budgetType = 'fixed';
            } else if (detailText.includes('時間単価制')) {
              budgetType = 'hourly';
            }

            if (budget) {
              const amountStr = budget.replace(/[^0-9]/g, '');
              budgetAmount = parseInt(amountStr) || 0;
            }

            // タグ/スキルの取得
            const tags: string[] = [];
            if (detailText) {
              const skillMatches = detailText.match(/([a-zA-Z]+|[ァ-ヶー]+[\w]*)/g);
              if (skillMatches) {
                skillMatches.forEach(skill => {
                  if (skill.length > 2 && skill.length < 20) {
                    tags.push(skill);
                  }
                });
              }
            }

            // 投稿日時の取得
            let postedAt = new Date().toISOString().split('T')[0];
            const dateMatch = detailText.match(/(\d{4}年\d{2}月\d{2}日|\d{2}月\d{2}日)/);
            if (dateMatch) {
              postedAt = dateMatch[0];
            }

            // 応募者数と期限の取得
            let applicants = 0;
            let deadline = '';

            const contractMatch = detailText.match(/契約数[^\d]*(\d+)/);
            if (contractMatch) {
              applicants = parseInt(contractMatch[1] ?? '0') || 0;
            }

            const deadlineMatch = detailText.match(/あと(\d+)日|(\d+月\d+日)/);
            if (deadlineMatch) {
              deadline = deadlineMatch[0] ?? '';
            }

            jobs.push({
              id: jobId,
              title: title,
              description: detailText.substring(0, 500),
              url: url,
              budget: {
                type: budgetType,
                amount: budgetAmount,
                currency: 'JPY'
              },
              category: params.categoryName,
              tags: tags.slice(0, 10),
              client: {
                name: '匿名',
                rating: 0,
                reviewCount: 0
              },
              postedAt: postedAt,
              deadline: deadline,
              applicants: applicants,
              scrapedAt: new Date().toISOString()
            });
            console.log(`✅ 案件抽出成功: ${title} (${jobId}) - ${budget}`);
          }
        } catch (itemError) {
          console.log(`❌ 案件 ${i} の処理中にエラー:`, itemError);
          continue;
        }
      }

      console.log(`📊 合計 ${jobs.length} 件の案件を抽出しました`);
      return jobs;
    }, { maxJobsLimit: maxJobs, categoryName: category, scrapedIds: [] });

    // 重複チェックのためキャッシュに追加
    jobs.forEach((job: CrowdWorksJob) => scrapedJobsCache.add(job.id));

    const executionTime = Date.now() - startTime;

    console.log(`🎉 カテゴリ「${category}」スクレイピング完了:`);
    console.log(`   📊 取得案件数: ${jobs.length}`);
    console.log(`   ⏱️ 実行時間: ${executionTime}ms`);

    // サンプル案件情報をログ出力
    if (jobs.length > 0) {
      console.log(`📝 サンプル案件:`);
      const sample = jobs[0];
      if (sample) {
        console.log(`   🏷️ タイトル: ${sample.title}`);
        console.log(`   🔗 URL: ${sample.url}`);
      }
    }

    return {
      success: true,
      jobsFound: jobs.length,
      jobs,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`❌ カテゴリ「${category}」スクレイピングエラー:`, errorMessage);

    return {
      success: false,
      jobsFound: 0,
      jobs: [],
      error: errorMessage,
      executionTime
    };
  }
}

/**
 * カテゴリスクレイピングのデバッグ版テスト
 */
export async function debugCategoryScrapingTest(): Promise<{
  success: boolean;
  steps: string[];
  categoryResults?: { [category: string]: ScrapingResult };
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  const steps: string[] = [];
  let browser: Browser | null = null;

  try {
    steps.push('🚀 カテゴリスクレイピングデバッグテスト開始');
    console.log('🚀 カテゴリスクレイピングデバッグテスト開始...');

    // ブラウザ起動
    steps.push('🌐 ブラウザ起動中');
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--disable-software-rasterizer'
      ]
    });

    steps.push('✅ ブラウザ起動完了');

    // ブラウザイベントリスナー設定
    browser.on('disconnected', () => {
      steps.push('⚠️ ブラウザ予期しない切断検出');
      console.log('⚠️ ブラウザが予期せず切断されました');
    });

    // コンテキスト作成
    steps.push('📄 コンテキスト作成中');
    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
    });

    steps.push('✅ コンテキスト作成完了');

    // ページ作成
    steps.push('📋 ページ作成中');
    const page = await context.newPage();

    steps.push('✅ ページ作成完了');

    // ページイベントリスナー設定
    page.on('close', () => {
      steps.push('⚠️ ページ予期しない終了検出');
      console.log('⚠️ ページが予期せず終了されました');
    });

    page.on('crash', () => {
      steps.push('❌ ページクラッシュ検出');
      console.log('❌ ページがクラッシュしました');
    });

    // カテゴリテスト実行
    const categories = ['ec', 'web_products'];
    const categoryResults: { [category: string]: ScrapingResult } = {};

    for (const category of categories) {
      steps.push(`📂 カテゴリ「${category}」処理開始`);
      console.log(`\n📂 カテゴリ「${category}」処理開始...`);

      try {
        // ページ状態確認
        const isPageClosed = page.isClosed();
        if (isPageClosed) {
          steps.push(`❌ カテゴリ「${category}」: ページが閉じられています`);
          console.log(`❌ カテゴリ「${category}」: ページが既に閉じられています`);
          continue;
        }

        steps.push(`📊 カテゴリ「${category}」: デバッグ版スクレイピング実行中`);
        const categoryResult = await scrapeCrowdWorksJobsByCategoryDebug(page, category, 5);
        categoryResults[category] = categoryResult;

        if (categoryResult.success) {
          steps.push(`✅ カテゴリ「${category}」完了: ${categoryResult.jobsFound}件`);
          console.log(`✅ カテゴリ「${category}」完了: ${categoryResult.jobsFound}件`);
        } else {
          steps.push(`❌ カテゴリ「${category}」失敗: ${categoryResult.error}`);
          console.log(`❌ カテゴリ「${category}」失敗: ${categoryResult.error}`);
        }

        // カテゴリ間の待機
        steps.push(`⏳ カテゴリ間待機 (2秒)`);
        await page.waitForTimeout(2000);

      } catch (categoryError) {
        const errorMessage = categoryError instanceof Error ? categoryError.message : String(categoryError);
        steps.push(`❌ カテゴリ「${category}」エラー: ${errorMessage}`);
        console.error(`❌ カテゴリ「${category}」エラー:`, errorMessage);

        categoryResults[category] = {
          success: false,
          jobsFound: 0,
          jobs: [],
          error: errorMessage,
          executionTime: 0
        };
      }
    }

    // クリーンアップ
    steps.push('🧹 コンテキスト終了中');
    await context.close();
    steps.push('✅ コンテキスト終了完了');

    const executionTime = Date.now() - startTime;
    steps.push(`🎉 デバッグテスト完了 (${executionTime}ms)`);

    const successCount = Object.values(categoryResults).filter(result => result.success).length;
    console.log(`\n🎯 カテゴリスクレイピングデバッグテスト完了`);
    console.log(`📊 成功カテゴリ数: ${successCount}/${categories.length}`);

    return {
      success: successCount > 0,
      steps,
      categoryResults,
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    steps.push(`❌ テストエラー: ${errorMessage}`);
    console.error('❌ カテゴリスクレイピングデバッグテストエラー:', errorMessage);

    return {
      success: false,
      steps,
      error: errorMessage,
      executionTime
    };
  } finally {
    if (browser) {
      try {
        steps.push('🔒 ブラウザ終了中');
        await browser.close();
        steps.push('✅ ブラウザ終了完了');
      } catch (closeError) {
        steps.push(`⚠️ ブラウザ終了エラー: ${closeError}`);
        console.warn('⚠️ ブラウザ終了エラー:', closeError);
      }
    }
  }
}

/**
 * ファイル保存機能付きカテゴリスクレイピングテスト（デバッグ版ベース）
 */
export async function debugCategoryScrapingWithFileOutput(params: {
  categories: string[];
  maxJobsPerCategory: number;
  saveToFile?: boolean;
}): Promise<{
  success: boolean;
  steps: string[];
  categoryResults?: { [category: string]: ScrapingResult };
  savedFiles?: string[];
  error?: string;
  executionTime: number;
}> {
  const startTime = Date.now();
  const steps: string[] = [];
  const savedFiles: string[] = [];
  let browser: Browser | null = null;

  try {
    steps.push('🚀 ファイル保存機能付きカテゴリスクレイピング開始');
    console.log('🚀 ファイル保存機能付きカテゴリスクレイピング開始...');
    console.log(`📋 対象カテゴリ: ${params.categories.join(', ')}`);
    console.log(`📊 カテゴリ毎最大案件数: ${params.maxJobsPerCategory}`);
    console.log(`💾 ファイル保存: ${params.saveToFile ? '有効' : '無効'}`);

    // ブラウザ起動
    steps.push('🌐 ブラウザ起動中');
    browser = await chromium.launch({
      headless: true,
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox',
        '--disable-dev-shm-usage',
        '--disable-gpu',
        '--disable-software-rasterizer'
      ]
    });

    steps.push('✅ ブラウザ起動完了');

    // コンテキスト作成
    steps.push('📄 コンテキスト作成中');
    const context = await browser.newContext({
      userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36'
    });

    steps.push('✅ コンテキスト作成完了');

    // ページ作成
    steps.push('📋 ページ作成中');
    const page = await context.newPage();
    steps.push('✅ ページ作成完了');

    // カテゴリテスト実行
    const categoryResults: { [category: string]: ScrapingResult } = {};

    for (const category of params.categories) {
      steps.push(`📂 カテゴリ「${category}」処理開始`);
      console.log(`\n📂 カテゴリ「${category}」処理開始...`);

      try {
        // ページ状態確認
        const isPageClosed = page.isClosed();
        if (isPageClosed) {
          steps.push(`❌ カテゴリ「${category}」: ページが閉じられています`);
          console.log(`❌ カテゴリ「${category}」: ページが既に閉じられています`);
          continue;
        }

        steps.push(`📊 カテゴリ「${category}」: デバッグ版スクレイピング実行中`);
        const categoryResult = await scrapeCrowdWorksJobsByCategoryDebug(page, category, params.maxJobsPerCategory);
        categoryResults[category] = categoryResult;

        if (categoryResult.success) {
          steps.push(`✅ カテゴリ「${category}」完了: ${categoryResult.jobsFound}件`);
          console.log(`✅ カテゴリ「${category}」完了: ${categoryResult.jobsFound}件`);

          // ファイル保存（オプション）
          if (params.saveToFile && categoryResult.jobs.length > 0) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const fileName = `./crowdworks-${category}-jobs-${timestamp}.json`;

            const fileData = {
              category,
              scrapedAt: new Date().toISOString(),
              totalJobs: categoryResult.jobsFound,
              executionTime: categoryResult.executionTime,
              jobs: categoryResult.jobs
            };

            try {
              await writeFileAsync(fileName, JSON.stringify(fileData, null, 2));
              savedFiles.push(fileName);
              steps.push(`💾 ファイル保存完了: ${fileName}`);
              console.log(`💾 ファイル保存完了: ${fileName}`);
            } catch (saveError) {
              steps.push(`❌ ファイル保存エラー: ${saveError}`);
              console.log(`❌ ファイル保存エラー: ${saveError}`);
            }
          }
        } else {
          steps.push(`❌ カテゴリ「${category}」失敗: ${categoryResult.error}`);
          console.log(`❌ カテゴリ「${category}」失敗: ${categoryResult.error}`);
        }

        // カテゴリ間の待機
        if (params.categories.indexOf(category) < params.categories.length - 1) {
          steps.push(`⏳ カテゴリ間待機 (2秒)`);
          await page.waitForTimeout(2000);
        }

      } catch (categoryError) {
        const errorMessage = categoryError instanceof Error ? categoryError.message : String(categoryError);
        steps.push(`❌ カテゴリ「${category}」エラー: ${errorMessage}`);
        console.error(`❌ カテゴリ「${category}」エラー:`, errorMessage);

        categoryResults[category] = {
          success: false,
          jobsFound: 0,
          jobs: [],
          error: errorMessage,
          executionTime: 0
        };
      }
    }

    // クリーンアップ
    steps.push('🧹 コンテキスト終了中');
    await context.close();
    steps.push('✅ コンテキスト終了完了');

    const executionTime = Date.now() - startTime;
    steps.push(`🎉 ファイル保存機能付きテスト完了 (${executionTime}ms)`);

    const successCount = Object.values(categoryResults).filter(result => result.success).length;
    const totalJobs = Object.values(categoryResults).reduce((sum, result) => sum + result.jobsFound, 0);

    console.log(`\n🎯 ファイル保存機能付きカテゴリスクレイピング完了`);
    console.log(`📊 成功カテゴリ数: ${successCount}/${params.categories.length}`);
    console.log(`📝 総取得案件数: ${totalJobs}件`);
    console.log(`💾 保存ファイル数: ${savedFiles.length}件`);

    if (savedFiles.length > 0) {
      console.log(`📁 保存されたファイル:`);
      savedFiles.forEach(file => console.log(`   - ${file}`));
    }

    return {
      success: successCount > 0,
      steps,
      categoryResults,
      ...(savedFiles.length > 0 ? { savedFiles } : {}),
      executionTime
    };

  } catch (error) {
    const executionTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : String(error);
    steps.push(`❌ テストエラー: ${errorMessage}`);
    console.error('❌ ファイル保存機能付きテストエラー:', errorMessage);

    return {
      success: false,
      steps,
      error: errorMessage,
      executionTime
    };
  } finally {
    if (browser) {
      try {
        steps.push('🔒 ブラウザ終了中');
        await browser.close();
        steps.push('✅ ブラウザ終了完了');
      } catch (closeError) {
        steps.push(`⚠️ ブラウザ終了エラー: ${closeError}`);
        console.warn('⚠️ ブラウザ終了エラー:', closeError);
      }
    }
  }
}

// ファイル読み込み用ユーティリティ
async function readFileAsync(filePath: string): Promise<string | null> {
  return new Promise((resolve) => {
    const fs = require('fs');
    fs.readFile(filePath, 'utf8', (err: any, data: string) => {
      if (err) resolve(null);
      else resolve(data);
    });
  });
}
</file>

</files>
